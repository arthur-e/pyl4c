<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>pyl4c.lib.transcom API documentation</title>
<meta name="description" content="For all things related to TransCom regions but, in particular, for
the statistical summary of SMAP L4C (or other raster array data) by TransCom
â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:35%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyl4c.lib.transcom</code></h1>
</header>
<section id="section-intro">
<p>For all things related to TransCom regions but, in particular, for
the statistical summary of SMAP L4C (or other raster array data) by TransCom
region. The TransCom project seems to be poorly documented, but Carbon
Tracker [1] uses it and provides the data used here. Intended use (Example):</p>
<pre><code>&gt;&gt;&gt; f = h5py.File(file_path)
&gt;&gt;&gt; soc = f['SOC/soc_mean']
&gt;&gt;&gt; tc = TransCom()
&gt;&gt;&gt; tc.summarize_by_transcom(np.where(soc == -9999, 0, soc), 'M09')
{'Australia': [736.73413, 914.3717],
 'Eurasia Boreal': [3593.8977, 1461.0577],
  ...
 'Tropical Asia': [1294.8158, 1264.5378]}
</code></pre>
<p>Command line use:</p>
<pre><code>$ python transcom.py summarize ./files/*.h5
    --field="SOC/soc_mean"
    --output-path="./summaries.csv"

$ python transcom.py summarize ./files/*.h5
    --field="SOC/soc_mean"
    --output-path="./summaries.csv" --summaries="('nanmean',)"
</code></pre>
<ol>
<li><a href="https://www.esrl.noaa.gov/gmd/ccgg/carbontracker/download.php">https://www.esrl.noaa.gov/gmd/ccgg/carbontracker/download.php</a></li>
</ol>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyl4c.lib.transcom.TransCom"><code class="flex name class">
<span>class <span class="ident">TransCom</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransCom(object):
    &#39;&#39;&#39;
    Convenience class for doing zonal statistics over TransCom regions.
    &#39;&#39;&#39;
    # Region codes for non-terrestrial/ off-shore regions
    offshore_region_codes = range(12, 22)
    onshore_region_codes = range(1, 12)
    onshore_region_labels = ( # i.e., regions 1 through 11, inclusive
        &#39;North American Boreal&#39;,
        &#39;North American Temperate&#39;,
        &#39;South American Tropical&#39;,
        &#39;South American Temperate&#39;,
        &#39;Northern Africa&#39;,
        &#39;Southern Africa&#39;,
        &#39;Eurasia Boreal&#39;,
        &#39;Eurasia Temperate&#39;,
        &#39;Tropical Asia&#39;,
        &#39;Australia&#39;,
        &#39;Europe&#39;)
    onshore_regions = dict(zip(onshore_region_codes, onshore_region_labels))

    def __init__(self):
        f = netcdf_file(TRANSCOM_DATA, &#39;r&#39;)
        self.areas = f.variables[&#39;transcom_regions_area&#39;].data.copy()
        regions = f.variables[&#39;transcom_regions&#39;].data.copy()
        f.close()

        # TransCom array is oriented south-up, so flip it
        self.data = np.flip(regions.astype(np.int8), 0)

    def __filter__(self, arr):
        &#39;Filters the TransCom regions array to terrestrial codes only&#39;
        return np.where(
            ~np.isin(self.data, self.offshore_region_codes),
            self.data, 0)

    def __resample__(self, arr, shp):
        &#39;Nearest neighbor interpolation to a new pixel size&#39;
        # Nearest neighbor interpolation; even though ndimage&#39;s zoom()
        #   gets edge pixels wrong, it is probably the best choice here
        return resize(arr, shp, order = 0, preserve_range = True)

    @cached_property
    def __transcom_1km__(self):
        rast = self.transcom_on_ease2_grid(
            grid = &#39;M01&#39;, terrestrial = True)
        return self.__resample__(
            rast.ReadAsArray(), EASE2_GRID_PARAMS[&#39;M01&#39;][&#39;shape&#39;])

    @cached_property
    def __transcom_9km__(self):
        rast = self.transcom_on_ease2_grid(
            grid = &#39;M09&#39;, terrestrial = True)
        return self.__resample__(
            rast.ReadAsArray(), EASE2_GRID_PARAMS[&#39;M09&#39;][&#39;shape&#39;])

    @cached_property
    def __area_by_region__(self):
        &#39;Based on a 9-km EASE-Grid (2.0), calculates area in square meters&#39;
        # Reverse the dictionary so that labels identify region codes
        areas = dict((v, k) for k, v in self.onshore_regions.items())
        transcom = self.__transcom_9km__
        for i, label in self.onshore_regions.items():
            areas[label] = transcom[np.where(transcom == i)].shape[0] * 81e6
        return areas

    @property
    def __reported_area_by_region__(self):
        &#39;Reports area in square meters for each TransCom region&#39;
        # Reverse the dictionary so that labels identify region codes
        areas = dict((v, k) for k, v in self.onshore_regions.items())
        for i, label in self.onshore_regions.items():
            areas[label] = self.areas[i]
        return areas

    def as_ease2_array(self, grid = &#39;M01&#39;):
        &#39;&#39;&#39;
        Returns a numpy.ndarray that has the specified EASE-Grid 2.0 shape,
        with the TransCom classes as values.
        &#39;&#39;&#39;
        if grid == &#39;M01&#39;:
            return self.__transcom_1km__
        elif grid == &#39;M09&#39;:
            return self.__transcom_9km__
        else:
            raise ValueError(&#39;Requested grid size not available&#39;)

    def as_raster(self, terrestrial = True):
        &#39;&#39;&#39;
        Returns the TransCom data as a `gdal.Dataset`.

        Parameters
        ----------
        terrestrial : bool
            True to filter to only terrestrial TransCom regions
            (Default: True)

        Returns
        -------
        gdal.Dataset
        &#39;&#39;&#39;
        # TransCom (source) spatial reference system
        wkt0 = osr.SpatialReference()
        wkt0.ImportFromEPSG(4326)
        gt0 = (-180, 1, 0, 90, 0, -1)
        return array_to_raster(
            self.__filter__(self.data) if terrestrial else self.data,
            gt0, str(wkt0))

    def count_ease2_by_transcom(
            self, array, grid = &#39;M01&#39;, scale = 1, text_labels = False,
            nodata = -9999):
        &#39;&#39;&#39;
        Calculates the number of non-NaN/ non-missing values in each TransCom
        region within the provided array.  Calls
        `TransCom.summarize_ease2_by_transcom()` as a subroutine.

        Parameters
        ----------
        array : numpy.ndarray
            Data array with the same SRS, grid size as desired for the
            TransCom data
        grid : str
            The EASE-Grid 2.0 name for which the TransCom data should be
            aligned and resampled on (e.g., &#34;M01&#34; or &#34;M09&#34;)
        scale : int or float
            Optional scaling parameter to apply to the input array values,
            e.g., if the array values are (spatial) rates and should be
            scaled by the (equal) area of the grid cell
        text_labels : bool
            True to use the names of the TransCom regions instead of their
            region codes, in the output
        nodata : int or float
            NoData or Fill value in the array data to ignore

        Returns
        -------
        dict
        &#39;&#39;&#39;
        count = lambda arr: np.sum(np.where(np.isnan(arr), 0, 1))
        return self.summarize_ease2_by_transcom(
            array, count, grid, text_labels, nodata)

    def rescaled(self, size_degrees = 1):
        &#39;&#39;&#39;
        Rescales the TransCom grid (nominally 1-degree by 1-degree) to a
        scalar multiple equirectangular grid size; e.g., size_degrees = 0.5
        would enlarge the array from (180, 360) to (360, 720).

        Parameters
        ----------
        size_degrees : int or float
            The output (equirectangular) grid resolution in degrees

        Returns
        -------
        numpy.ndarray
        &#39;&#39;&#39;
        opts = { # Options to zoom()
            &#39;order&#39;: 0,
            &#39;zoom&#39;: (1/size_degrees),
            &#39;mode&#39;: &#39;grid-constant&#39;,
            &#39;grid_mode&#39;: True
        }
        return zoom(self.data, **opts)

    def summarize_ease2_by_transcom(
            self, array, summaries = dict(mean = np.nanmean, std = np.nanstd),
            grid = &#39;M01&#39;, scale = 1, text_labels = False, nodata = -9999):
        &#39;&#39;&#39;
        Calculates the mean and standard deviation of the input array values
        within each TransCom class.

        NOTE: The statistical summaries are accumulated as 32-bit floating
        point values, which is fastest, but will not be accurate for certain
        data types. If the input data array are large integers (e.g., soil
        organic carbon/ SOC values), then this should not be a problem.

        Parameters
        ----------
        array : numpy.ndarray
            Data array with the same SRS, grid size as desired for the
            TransCom data
        summaries : dict
            Dictionary of {label: function} for every summary statistic
            desired; function should be NumPy summary function, e.g.,
            nanmean, nansum, ...
        grid : str
            The EASE-Grid 2.0 name for which the TransCom data should be
            aligned and resampled on (e.g., &#34;M01&#34; or &#34;M09&#34;)
        scale : int or float
            Optional scaling parameter to apply to the input array values,
            e.g., if the array values are (spatial) rates and should be
            scaled by the (equal) area of the grid cell
        text_labels : bool
            True to use the names of the TransCom regions instead of their
            region codes, in the output
        nodata : int or float
            NoData or Fill value in the array data to ignore

        Returns
        -------
        dict
            Dictionary with TransCom regions as labels and a nested Dictionary
            with a  key-value pair for each desired summary statistic.
        &#39;&#39;&#39;
        assert array.ndim == 2 or (array.ndim == 3 and array.shape[0] == 1), &#39;Can only work with 1-band raster arrays&#39;
        if array.ndim == 3:
            array = array[0,...] # Unwrap 1-band raster arrays

        # Extract grid size in km; get the resampled TransCom array
        g = int(re.compile(r&#39;.*(?P&lt;km&gt;\d{2})&#39;).match(grid).groups()[0])
        transcom = getattr(self, &#39;__transcom_%dkm__&#39; % g)
        assert transcom.shape == array.shape, &#39;Input array does not match the TransCom regions grid at the specified grid size&#39;

        # Fill in NaN where there is NoData
        if nodata is not None:
            array = np.where(array == -9999, np.nan, array)
        # Determine how we will organize statistics by class label
        if text_labels:
            # Create, e.g., {&#39;Australia&#39;: {}, ...}
            stats = dict([(v, dict()) for v in self.onshore_regions.values()])
        else:
            # Create, e.g., {1: {}, 2: {}, ...}
            stats = dict([(k, dict()) for k in self.onshore_regions.keys()])

        for code, label in self.onshore_regions.items():
            i = label if text_labels else code
            query = np.multiply( # Scale cell values (Default = 1.0)
                np.where(np.isin(transcom, code), array, np.nan), scale)
            for stat_name, func in summaries.items():
                # NOTE: Runs faster if dtype of accumulator is *not* set
                stats[i][stat_name] = func(query)

        return stats

    def transcom_on_ease2_grid(self, grid = &#39;M01&#39;, terrestrial = True):
        &#39;&#39;&#39;
        Projects the equirectangular TransCom regions data onto the EASE-Grid
        2.0 spatial reference system.

        NOTE: EASE-Grid 2.0 only extends to 84 degrees latitude North or
        South, so the TransCom regions ought to be restricted to this same
        extent; but it doesn&#39;t actually matter and the projection is still
        accurate. I&#39;m making a note here in case it becomes important later:

            self.__y_coords__ = f.variables[&#39;lat&#39;].data.copy()
            idx = np.where(np.abs(self.__y_coords__) &lt; 84)[0]
            transcom = self.data[idx,:]

        Parameters
        ----------
        grid : str
            The EASE-Grid 2.0 name for which the TransCom data should be
            aligned and resampled on (e.g., &#34;M01&#34; or &#34;M09&#34;)
        terrestrial : bool
            True to filter to only terrestrial TransCom regions

        Returns
        -------
        gdal.Dataset
        &#39;&#39;&#39;
        # EASE-Grid 2.0 (target) spatial reference system
        wkt = osr.SpatialReference()
        wkt.ImportFromWkt(EPSG[EASE2_GRID_PARAMS[grid][&#39;epsg&#39;]])

        # Create a gdal.Dataset from TransCom data
        rast0 = self.as_raster(terrestrial)
        gt0 = rast0.GetGeoTransform()
        wkt0 = str(rast0.GetProjection())
        py, px = self.data.shape
        px += 12 # HACK: Output is clipped for some reason (=/)

        # The output (projected) raster&#39;s GeoTransform is difficult to
        #   determine, but this should do it automatically
        gt = gdal.AutoCreateWarpedVRT(
            rast0, str(wkt0), str(wkt), gdal.GRA_NearestNeighbour).GetGeoTransform()
        # rast0 is input raster, rast is output raster
        rast = gdal.GetDriverByName(&#39;MEM&#39;).Create(&#39;&#39;, px, py, 1, gdalconst.GDT_Int16)
        rast.SetGeoTransform(gt)
        rast.SetProjection(str(wkt))
        gdal.ReprojectImage(
            rast0, rast, str(wkt0), str(wkt), gdalconst.GRA_NearestNeighbour)
        return rast</code></pre>
</details>
<div class="desc"><p>Convenience class for doing zonal statistics over TransCom regions.</p></div>
<h3>Class variables</h3>
<dl>
<dt id="pyl4c.lib.transcom.TransCom.offshore_region_codes"><code class="name">var <span class="ident">offshore_region_codes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.lib.transcom.TransCom.onshore_region_codes"><code class="name">var <span class="ident">onshore_region_codes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.lib.transcom.TransCom.onshore_region_labels"><code class="name">var <span class="ident">onshore_region_labels</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.lib.transcom.TransCom.onshore_regions"><code class="name">var <span class="ident">onshore_regions</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.lib.transcom.TransCom.as_ease2_array"><code class="name flex">
<span>def <span class="ident">as_ease2_array</span></span>(<span>self, grid='M01')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_ease2_array(self, grid = &#39;M01&#39;):
    &#39;&#39;&#39;
    Returns a numpy.ndarray that has the specified EASE-Grid 2.0 shape,
    with the TransCom classes as values.
    &#39;&#39;&#39;
    if grid == &#39;M01&#39;:
        return self.__transcom_1km__
    elif grid == &#39;M09&#39;:
        return self.__transcom_9km__
    else:
        raise ValueError(&#39;Requested grid size not available&#39;)</code></pre>
</details>
<div class="desc"><p>Returns a numpy.ndarray that has the specified EASE-Grid 2.0 shape,
with the TransCom classes as values.</p></div>
</dd>
<dt id="pyl4c.lib.transcom.TransCom.as_raster"><code class="name flex">
<span>def <span class="ident">as_raster</span></span>(<span>self, terrestrial=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_raster(self, terrestrial = True):
    &#39;&#39;&#39;
    Returns the TransCom data as a `gdal.Dataset`.

    Parameters
    ----------
    terrestrial : bool
        True to filter to only terrestrial TransCom regions
        (Default: True)

    Returns
    -------
    gdal.Dataset
    &#39;&#39;&#39;
    # TransCom (source) spatial reference system
    wkt0 = osr.SpatialReference()
    wkt0.ImportFromEPSG(4326)
    gt0 = (-180, 1, 0, 90, 0, -1)
    return array_to_raster(
        self.__filter__(self.data) if terrestrial else self.data,
        gt0, str(wkt0))</code></pre>
</details>
<div class="desc"><p>Returns the TransCom data as a <code>gdal.Dataset</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>terrestrial</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to filter to only terrestrial TransCom regions
(Default: True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gdal.Dataset</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="pyl4c.lib.transcom.TransCom.count_ease2_by_transcom"><code class="name flex">
<span>def <span class="ident">count_ease2_by_transcom</span></span>(<span>self, array, grid='M01', scale=1, text_labels=False, nodata=-9999)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_ease2_by_transcom(
        self, array, grid = &#39;M01&#39;, scale = 1, text_labels = False,
        nodata = -9999):
    &#39;&#39;&#39;
    Calculates the number of non-NaN/ non-missing values in each TransCom
    region within the provided array.  Calls
    `TransCom.summarize_ease2_by_transcom()` as a subroutine.

    Parameters
    ----------
    array : numpy.ndarray
        Data array with the same SRS, grid size as desired for the
        TransCom data
    grid : str
        The EASE-Grid 2.0 name for which the TransCom data should be
        aligned and resampled on (e.g., &#34;M01&#34; or &#34;M09&#34;)
    scale : int or float
        Optional scaling parameter to apply to the input array values,
        e.g., if the array values are (spatial) rates and should be
        scaled by the (equal) area of the grid cell
    text_labels : bool
        True to use the names of the TransCom regions instead of their
        region codes, in the output
    nodata : int or float
        NoData or Fill value in the array data to ignore

    Returns
    -------
    dict
    &#39;&#39;&#39;
    count = lambda arr: np.sum(np.where(np.isnan(arr), 0, 1))
    return self.summarize_ease2_by_transcom(
        array, count, grid, text_labels, nodata)</code></pre>
</details>
<div class="desc"><p>Calculates the number of non-NaN/ non-missing values in each TransCom
region within the provided array.
Calls
<code><a title="pyl4c.lib.transcom.TransCom.summarize_ease2_by_transcom" href="#pyl4c.lib.transcom.TransCom.summarize_ease2_by_transcom">TransCom.summarize_ease2_by_transcom()</a></code> as a subroutine.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Data array with the same SRS, grid size as desired for the
TransCom data</dd>
<dt><strong><code>grid</code></strong> :&ensp;<code>str</code></dt>
<dd>The EASE-Grid 2.0 name for which the TransCom data should be
aligned and resampled on (e.g., "M01" or "M09")</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Optional scaling parameter to apply to the input array values,
e.g., if the array values are (spatial) rates and should be
scaled by the (equal) area of the grid cell</dd>
<dt><strong><code>text_labels</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use the names of the TransCom regions instead of their
region codes, in the output</dd>
<dt><strong><code>nodata</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>NoData or Fill value in the array data to ignore</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="pyl4c.lib.transcom.TransCom.rescaled"><code class="name flex">
<span>def <span class="ident">rescaled</span></span>(<span>self, size_degrees=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rescaled(self, size_degrees = 1):
    &#39;&#39;&#39;
    Rescales the TransCom grid (nominally 1-degree by 1-degree) to a
    scalar multiple equirectangular grid size; e.g., size_degrees = 0.5
    would enlarge the array from (180, 360) to (360, 720).

    Parameters
    ----------
    size_degrees : int or float
        The output (equirectangular) grid resolution in degrees

    Returns
    -------
    numpy.ndarray
    &#39;&#39;&#39;
    opts = { # Options to zoom()
        &#39;order&#39;: 0,
        &#39;zoom&#39;: (1/size_degrees),
        &#39;mode&#39;: &#39;grid-constant&#39;,
        &#39;grid_mode&#39;: True
    }
    return zoom(self.data, **opts)</code></pre>
</details>
<div class="desc"><p>Rescales the TransCom grid (nominally 1-degree by 1-degree) to a
scalar multiple equirectangular grid size; e.g., size_degrees = 0.5
would enlarge the array from (180, 360) to (360, 720).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>size_degrees</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The output (equirectangular) grid resolution in degrees</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="pyl4c.lib.transcom.TransCom.summarize_ease2_by_transcom"><code class="name flex">
<span>def <span class="ident">summarize_ease2_by_transcom</span></span>(<span>self,<br>array,<br>summaries={&#x27;mean&#x27;: &lt;function nanmean&gt;, &#x27;std&#x27;: &lt;function nanstd&gt;},<br>grid='M01',<br>scale=1,<br>text_labels=False,<br>nodata=-9999)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summarize_ease2_by_transcom(
        self, array, summaries = dict(mean = np.nanmean, std = np.nanstd),
        grid = &#39;M01&#39;, scale = 1, text_labels = False, nodata = -9999):
    &#39;&#39;&#39;
    Calculates the mean and standard deviation of the input array values
    within each TransCom class.

    NOTE: The statistical summaries are accumulated as 32-bit floating
    point values, which is fastest, but will not be accurate for certain
    data types. If the input data array are large integers (e.g., soil
    organic carbon/ SOC values), then this should not be a problem.

    Parameters
    ----------
    array : numpy.ndarray
        Data array with the same SRS, grid size as desired for the
        TransCom data
    summaries : dict
        Dictionary of {label: function} for every summary statistic
        desired; function should be NumPy summary function, e.g.,
        nanmean, nansum, ...
    grid : str
        The EASE-Grid 2.0 name for which the TransCom data should be
        aligned and resampled on (e.g., &#34;M01&#34; or &#34;M09&#34;)
    scale : int or float
        Optional scaling parameter to apply to the input array values,
        e.g., if the array values are (spatial) rates and should be
        scaled by the (equal) area of the grid cell
    text_labels : bool
        True to use the names of the TransCom regions instead of their
        region codes, in the output
    nodata : int or float
        NoData or Fill value in the array data to ignore

    Returns
    -------
    dict
        Dictionary with TransCom regions as labels and a nested Dictionary
        with a  key-value pair for each desired summary statistic.
    &#39;&#39;&#39;
    assert array.ndim == 2 or (array.ndim == 3 and array.shape[0] == 1), &#39;Can only work with 1-band raster arrays&#39;
    if array.ndim == 3:
        array = array[0,...] # Unwrap 1-band raster arrays

    # Extract grid size in km; get the resampled TransCom array
    g = int(re.compile(r&#39;.*(?P&lt;km&gt;\d{2})&#39;).match(grid).groups()[0])
    transcom = getattr(self, &#39;__transcom_%dkm__&#39; % g)
    assert transcom.shape == array.shape, &#39;Input array does not match the TransCom regions grid at the specified grid size&#39;

    # Fill in NaN where there is NoData
    if nodata is not None:
        array = np.where(array == -9999, np.nan, array)
    # Determine how we will organize statistics by class label
    if text_labels:
        # Create, e.g., {&#39;Australia&#39;: {}, ...}
        stats = dict([(v, dict()) for v in self.onshore_regions.values()])
    else:
        # Create, e.g., {1: {}, 2: {}, ...}
        stats = dict([(k, dict()) for k in self.onshore_regions.keys()])

    for code, label in self.onshore_regions.items():
        i = label if text_labels else code
        query = np.multiply( # Scale cell values (Default = 1.0)
            np.where(np.isin(transcom, code), array, np.nan), scale)
        for stat_name, func in summaries.items():
            # NOTE: Runs faster if dtype of accumulator is *not* set
            stats[i][stat_name] = func(query)

    return stats</code></pre>
</details>
<div class="desc"><p>Calculates the mean and standard deviation of the input array values
within each TransCom class.</p>
<p>NOTE: The statistical summaries are accumulated as 32-bit floating
point values, which is fastest, but will not be accurate for certain
data types. If the input data array are large integers (e.g., soil
organic carbon/ SOC values), then this should not be a problem.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Data array with the same SRS, grid size as desired for the
TransCom data</dd>
<dt><strong><code>summaries</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of {label: function} for every summary statistic
desired; function should be NumPy summary function, e.g.,
nanmean, nansum, &hellip;</dd>
<dt><strong><code>grid</code></strong> :&ensp;<code>str</code></dt>
<dd>The EASE-Grid 2.0 name for which the TransCom data should be
aligned and resampled on (e.g., "M01" or "M09")</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Optional scaling parameter to apply to the input array values,
e.g., if the array values are (spatial) rates and should be
scaled by the (equal) area of the grid cell</dd>
<dt><strong><code>text_labels</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use the names of the TransCom regions instead of their
region codes, in the output</dd>
<dt><strong><code>nodata</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>NoData or Fill value in the array data to ignore</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary with TransCom regions as labels and a nested Dictionary
with a
key-value pair for each desired summary statistic.</dd>
</dl></div>
</dd>
<dt id="pyl4c.lib.transcom.TransCom.transcom_on_ease2_grid"><code class="name flex">
<span>def <span class="ident">transcom_on_ease2_grid</span></span>(<span>self, grid='M01', terrestrial=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transcom_on_ease2_grid(self, grid = &#39;M01&#39;, terrestrial = True):
    &#39;&#39;&#39;
    Projects the equirectangular TransCom regions data onto the EASE-Grid
    2.0 spatial reference system.

    NOTE: EASE-Grid 2.0 only extends to 84 degrees latitude North or
    South, so the TransCom regions ought to be restricted to this same
    extent; but it doesn&#39;t actually matter and the projection is still
    accurate. I&#39;m making a note here in case it becomes important later:

        self.__y_coords__ = f.variables[&#39;lat&#39;].data.copy()
        idx = np.where(np.abs(self.__y_coords__) &lt; 84)[0]
        transcom = self.data[idx,:]

    Parameters
    ----------
    grid : str
        The EASE-Grid 2.0 name for which the TransCom data should be
        aligned and resampled on (e.g., &#34;M01&#34; or &#34;M09&#34;)
    terrestrial : bool
        True to filter to only terrestrial TransCom regions

    Returns
    -------
    gdal.Dataset
    &#39;&#39;&#39;
    # EASE-Grid 2.0 (target) spatial reference system
    wkt = osr.SpatialReference()
    wkt.ImportFromWkt(EPSG[EASE2_GRID_PARAMS[grid][&#39;epsg&#39;]])

    # Create a gdal.Dataset from TransCom data
    rast0 = self.as_raster(terrestrial)
    gt0 = rast0.GetGeoTransform()
    wkt0 = str(rast0.GetProjection())
    py, px = self.data.shape
    px += 12 # HACK: Output is clipped for some reason (=/)

    # The output (projected) raster&#39;s GeoTransform is difficult to
    #   determine, but this should do it automatically
    gt = gdal.AutoCreateWarpedVRT(
        rast0, str(wkt0), str(wkt), gdal.GRA_NearestNeighbour).GetGeoTransform()
    # rast0 is input raster, rast is output raster
    rast = gdal.GetDriverByName(&#39;MEM&#39;).Create(&#39;&#39;, px, py, 1, gdalconst.GDT_Int16)
    rast.SetGeoTransform(gt)
    rast.SetProjection(str(wkt))
    gdal.ReprojectImage(
        rast0, rast, str(wkt0), str(wkt), gdalconst.GRA_NearestNeighbour)
    return rast</code></pre>
</details>
<div class="desc"><p>Projects the equirectangular TransCom regions data onto the EASE-Grid
2.0 spatial reference system.</p>
<p>NOTE: EASE-Grid 2.0 only extends to 84 degrees latitude North or
South, so the TransCom regions ought to be restricted to this same
extent; but it doesn't actually matter and the projection is still
accurate. I'm making a note here in case it becomes important later:</p>
<pre><code>self.__y_coords__ = f.variables['lat'].data.copy()
idx = np.where(np.abs(self.__y_coords__) &lt; 84)[0]
transcom = self.data[idx,:]
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>grid</code></strong> :&ensp;<code>str</code></dt>
<dd>The EASE-Grid 2.0 name for which the TransCom data should be
aligned and resampled on (e.g., "M01" or "M09")</dd>
<dt><strong><code>terrestrial</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to filter to only terrestrial TransCom regions</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gdal.Dataset</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="pyl4c.lib.transcom.TransComCLI"><code class="flex name class">
<span>class <span class="ident">TransComCLI</span></span>
<span>(</span><span>output_path=None,<br>field='SOC/soc_mean',<br>summaries=('nanmean', 'nanstd'),<br>grid='M09',<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransComCLI(CommandLineInterface):
    &#39;&#39;&#39;
    A command-line interface (CLI) for convenience; used with Google fire.
    &#39;&#39;&#39;
    def __init__(
            self, output_path = None, field = &#39;SOC/soc_mean&#39;,
            summaries = (&#39;nanmean&#39;, &#39;nanstd&#39;), grid = &#39;M09&#39;, **kwargs):
        self._output_path = output_path
        self._field = field
        self._grid = grid
        self._summaries = summaries
        self._kwargs = kwargs
        self._kwargs[&#39;grid&#39;] = grid
        self.tc = TransCom()

    def __check__(self):
        assert self._output_path is not None,\
            &#39;You must specify an output_path with: --output-path=&#34;&#34;&#39;
        assert os.path.exists(os.path.dirname(self._output_path)),\
            &#39;Did not recognize output_path (Cannot use shortcuts like ~)&#39;

    def __dump_csv__(self, output_path, items):
        with open(output_path, &#39;w&#39;) as stream:
            writer = csv.writer(stream, delimiter = &#39;,&#39;, quotechar = &#39;&#34;&#39;)
            writer.writerow((&#39;filename&#39;, &#39;transcom_region&#39;, &#39;statistic&#39;, &#39;value&#39;))
            for each in items:
                writer.writerow(each)

    def __expand_summary__(self, items):
        &#39;Expands [&#34;A&#34;, {&#34;a&#34;: 1, &#34;b&#34;: 2}] into [(&#34;A&#34;, &#34;a&#34;, 1), (&#34;A&#34;, &#34;b&#34;, 2)]&#39;
        new_items = []
        # TODO Would be nice to generalize this using a recursive pattern
        for filename, d in items:
            for label, summary in d.items():
                for key, value in summary.items():
                    new_items.append((filename, label, key, value))
        return new_items

    def report_areas(self):
        &#39;&#39;&#39;
        Prints the reported area of each TransCom region.
        &#39;&#39;&#39;
        # NOTE: The underlying data are 32-bit floating point, so this
        #   string formatting will maximize the precision
        for k, v, in self.tc.__reported_area_by_region__.items():
            print(&#39;%s: %.0f&#39; % (k, v))

    def summarize(self, *file_paths):
        &#39;&#39;&#39;
        Creates a statistical summary by class label (TransCom region) for
        each of multiple input HDF5 files. Use:

            $ python transcom.py summarize ./files/*.h5 --field=&#34;SOC/soc_mean&#34;
                --output-path=&#34;./summaries.csv&#34;

            $ python transcom.py summarize ./files/*.h5 --field=&#34;SOC/soc_mean&#34;
                --output-path=&#34;./summaries.csv&#34; --summaries=&#34;(&#39;nanmean&#39;,)&#34;

        Parameters
        ----------
        *file_paths : str
        field : str
            Hierarchical path name of field to summarize: `--field=&#34;&lt;field&gt;&#34;`
        summaries : str
            For compatibility at the CLI, can describe the statistical summary
            functions desired as a comma-delimited string, e.g.,
            `&#34;(&#39;nanmean&#39;,&#39;nanstd&#39;)&#34;` where names refer to NumPy functions
        output_path : str
            File path where the output CSV file should be written
        **kwargs : str
            Other keyword arguments to be passed on to
            `TransCom.summarize_ease2_by_transcom()`
        &#39;&#39;&#39;
        self.__check__()
        results = []
        n = len(file_paths)
        assert n &gt; 0, &#39;No file paths given (Did you forget to specify &#34;field&#34; argument?)&#39;
        # NOTE: fire.Fire() implicitly transforms comma-delimited string into
        #   tuple; here, e.g., &#34;(&#39;nanmean&#39;, &#39;nanstd&#39;)&#34; becomes:
        #   {&#39;nanmean&#39;: np.nanmean, &#39;nanstd&#39;: np.nanstd}
        self._kwargs[&#39;summaries&#39;] = dict([
            (name, getattr(np, name)) for name in self._summaries
        ])

        # Determine what kind of files we&#39;re working with
        mode = &#39;other&#39;
        if file_paths[0].split(&#39;.&#39;)[-1] == &#39;h5&#39;:
            mode = &#39;hdf5&#39;
        elif file_paths[0].split(&#39;.&#39;)[-1] in TYPE_MAP.keys():
            mode = &#39;sparse&#39;

        with ProgressBar(len(file_paths), &#39;Summarizing files...&#39;) as progress:
            for i, filename in enumerate(file_paths):
                if mode == &#39;hdf5&#39;:
                    with h5py.File(filename, &#39;r&#39;) as hdf:
                        arr = hdf[self._field][:]

                elif mode == &#39;sparse&#39;:
                    tcf = TCFArray(filename, self._grid)
                    tcf.inflate()
                    arr = tcf.data

                elif mode == &#39;other&#39;:
                    arr, _, _ = as_array(filename, band_axis = False)

                stats = self.tc.summarize_ease2_by_transcom(arr, **self._kwargs)
                results.append((filename, stats))
                progress.update(i + 1)

        self.__dump_csv__(self._output_path, self.__expand_summary__(results))</code></pre>
</details>
<div class="desc"><p>A command-line interface (CLI) for convenience; used with Google fire.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.lib.cli.CommandLineInterface" href="cli.html#pyl4c.lib.cli.CommandLineInterface">CommandLineInterface</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.lib.transcom.TransComCLI.report_areas"><code class="name flex">
<span>def <span class="ident">report_areas</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report_areas(self):
    &#39;&#39;&#39;
    Prints the reported area of each TransCom region.
    &#39;&#39;&#39;
    # NOTE: The underlying data are 32-bit floating point, so this
    #   string formatting will maximize the precision
    for k, v, in self.tc.__reported_area_by_region__.items():
        print(&#39;%s: %.0f&#39; % (k, v))</code></pre>
</details>
<div class="desc"><p>Prints the reported area of each TransCom region.</p></div>
</dd>
<dt id="pyl4c.lib.transcom.TransComCLI.summarize"><code class="name flex">
<span>def <span class="ident">summarize</span></span>(<span>self, *file_paths)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summarize(self, *file_paths):
    &#39;&#39;&#39;
    Creates a statistical summary by class label (TransCom region) for
    each of multiple input HDF5 files. Use:

        $ python transcom.py summarize ./files/*.h5 --field=&#34;SOC/soc_mean&#34;
            --output-path=&#34;./summaries.csv&#34;

        $ python transcom.py summarize ./files/*.h5 --field=&#34;SOC/soc_mean&#34;
            --output-path=&#34;./summaries.csv&#34; --summaries=&#34;(&#39;nanmean&#39;,)&#34;

    Parameters
    ----------
    *file_paths : str
    field : str
        Hierarchical path name of field to summarize: `--field=&#34;&lt;field&gt;&#34;`
    summaries : str
        For compatibility at the CLI, can describe the statistical summary
        functions desired as a comma-delimited string, e.g.,
        `&#34;(&#39;nanmean&#39;,&#39;nanstd&#39;)&#34;` where names refer to NumPy functions
    output_path : str
        File path where the output CSV file should be written
    **kwargs : str
        Other keyword arguments to be passed on to
        `TransCom.summarize_ease2_by_transcom()`
    &#39;&#39;&#39;
    self.__check__()
    results = []
    n = len(file_paths)
    assert n &gt; 0, &#39;No file paths given (Did you forget to specify &#34;field&#34; argument?)&#39;
    # NOTE: fire.Fire() implicitly transforms comma-delimited string into
    #   tuple; here, e.g., &#34;(&#39;nanmean&#39;, &#39;nanstd&#39;)&#34; becomes:
    #   {&#39;nanmean&#39;: np.nanmean, &#39;nanstd&#39;: np.nanstd}
    self._kwargs[&#39;summaries&#39;] = dict([
        (name, getattr(np, name)) for name in self._summaries
    ])

    # Determine what kind of files we&#39;re working with
    mode = &#39;other&#39;
    if file_paths[0].split(&#39;.&#39;)[-1] == &#39;h5&#39;:
        mode = &#39;hdf5&#39;
    elif file_paths[0].split(&#39;.&#39;)[-1] in TYPE_MAP.keys():
        mode = &#39;sparse&#39;

    with ProgressBar(len(file_paths), &#39;Summarizing files...&#39;) as progress:
        for i, filename in enumerate(file_paths):
            if mode == &#39;hdf5&#39;:
                with h5py.File(filename, &#39;r&#39;) as hdf:
                    arr = hdf[self._field][:]

            elif mode == &#39;sparse&#39;:
                tcf = TCFArray(filename, self._grid)
                tcf.inflate()
                arr = tcf.data

            elif mode == &#39;other&#39;:
                arr, _, _ = as_array(filename, band_axis = False)

            stats = self.tc.summarize_ease2_by_transcom(arr, **self._kwargs)
            results.append((filename, stats))
            progress.update(i + 1)

    self.__dump_csv__(self._output_path, self.__expand_summary__(results))</code></pre>
</details>
<div class="desc"><p>Creates a statistical summary by class label (TransCom region) for
each of multiple input HDF5 files. Use:</p>
<pre><code>$ python transcom.py summarize ./files/*.h5 --field="SOC/soc_mean"
    --output-path="./summaries.csv"

$ python transcom.py summarize ./files/*.h5 --field="SOC/soc_mean"
    --output-path="./summaries.csv" --summaries="('nanmean',)"
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*file_paths</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>str</code></dt>
<dd>Hierarchical path name of field to summarize: <code>--field="&lt;field&gt;"</code></dd>
<dt><strong><code>summaries</code></strong> :&ensp;<code>str</code></dt>
<dd>For compatibility at the CLI, can describe the statistical summary
functions desired as a comma-delimited string, e.g.,
<code>"('nanmean','nanstd')"</code> where names refer to NumPy functions</dd>
<dt><strong><code>output_path</code></strong> :&ensp;<code>str</code></dt>
<dd>File path where the output CSV file should be written</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>str</code></dt>
<dd>Other keyword arguments to be passed on to
<code><a title="pyl4c.lib.transcom.TransCom.summarize_ease2_by_transcom" href="#pyl4c.lib.transcom.TransCom.summarize_ease2_by_transcom">TransCom.summarize_ease2_by_transcom()</a></code></dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.lib.cli.CommandLineInterface" href="cli.html#pyl4c.lib.cli.CommandLineInterface">CommandLineInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.lib.cli.CommandLineInterface.infer_file_mode" href="cli.html#pyl4c.lib.cli.CommandLineInterface.infer_file_mode">infer_file_mode</a></code></li>
<li><code><a title="pyl4c.lib.cli.CommandLineInterface.lookup_dtype" href="cli.html#pyl4c.lib.cli.CommandLineInterface.lookup_dtype">lookup_dtype</a></code></li>
<li><code><a title="pyl4c.lib.cli.CommandLineInterface.lookup_gdt" href="cli.html#pyl4c.lib.cli.CommandLineInterface.lookup_gdt">lookup_gdt</a></code></li>
<li><code><a title="pyl4c.lib.cli.CommandLineInterface.read_array" href="cli.html#pyl4c.lib.cli.CommandLineInterface.read_array">read_array</a></code></li>
<li><code><a title="pyl4c.lib.cli.CommandLineInterface.read_chunked" href="cli.html#pyl4c.lib.cli.CommandLineInterface.read_chunked">read_chunked</a></code></li>
<li><code><a title="pyl4c.lib.cli.CommandLineInterface.read_raster" href="cli.html#pyl4c.lib.cli.CommandLineInterface.read_raster">read_raster</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="SMAP Mission Homepage" href="https://smap.jpl.nasa.gov/">
<img src="https://arthur-e.github.io/pyl4c/templates/images/logo_SMAP.jpg" alt="">
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyl4c.lib" href="index.html">pyl4c.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyl4c.lib.transcom.TransCom" href="#pyl4c.lib.transcom.TransCom">TransCom</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.lib.transcom.TransCom.as_ease2_array" href="#pyl4c.lib.transcom.TransCom.as_ease2_array">as_ease2_array</a></code></li>
<li><code><a title="pyl4c.lib.transcom.TransCom.as_raster" href="#pyl4c.lib.transcom.TransCom.as_raster">as_raster</a></code></li>
<li><code><a title="pyl4c.lib.transcom.TransCom.count_ease2_by_transcom" href="#pyl4c.lib.transcom.TransCom.count_ease2_by_transcom">count_ease2_by_transcom</a></code></li>
<li><code><a title="pyl4c.lib.transcom.TransCom.offshore_region_codes" href="#pyl4c.lib.transcom.TransCom.offshore_region_codes">offshore_region_codes</a></code></li>
<li><code><a title="pyl4c.lib.transcom.TransCom.onshore_region_codes" href="#pyl4c.lib.transcom.TransCom.onshore_region_codes">onshore_region_codes</a></code></li>
<li><code><a title="pyl4c.lib.transcom.TransCom.onshore_region_labels" href="#pyl4c.lib.transcom.TransCom.onshore_region_labels">onshore_region_labels</a></code></li>
<li><code><a title="pyl4c.lib.transcom.TransCom.onshore_regions" href="#pyl4c.lib.transcom.TransCom.onshore_regions">onshore_regions</a></code></li>
<li><code><a title="pyl4c.lib.transcom.TransCom.rescaled" href="#pyl4c.lib.transcom.TransCom.rescaled">rescaled</a></code></li>
<li><code><a title="pyl4c.lib.transcom.TransCom.summarize_ease2_by_transcom" href="#pyl4c.lib.transcom.TransCom.summarize_ease2_by_transcom">summarize_ease2_by_transcom</a></code></li>
<li><code><a title="pyl4c.lib.transcom.TransCom.transcom_on_ease2_grid" href="#pyl4c.lib.transcom.TransCom.transcom_on_ease2_grid">transcom_on_ease2_grid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.lib.transcom.TransComCLI" href="#pyl4c.lib.transcom.TransComCLI">TransComCLI</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.lib.transcom.TransComCLI.report_areas" href="#pyl4c.lib.transcom.TransComCLI.report_areas">report_areas</a></code></li>
<li><code><a title="pyl4c.lib.transcom.TransComCLI.summarize" href="#pyl4c.lib.transcom.TransComCLI.summarize">summarize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
