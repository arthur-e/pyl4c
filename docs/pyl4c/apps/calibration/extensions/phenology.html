<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyl4c.apps.calibration.extensions.phenology API documentation</title>
<meta name="description" content="Extensions to SMAP L4C (and calibration) to support autotrophic respiration,
soil respiration, and litterfall phenologies â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyl4c.apps.calibration.extensions.phenology</code></h1>
</header>
<section id="section-intro">
<p>Extensions to SMAP L4C (and calibration) to support autotrophic respiration,
soil respiration, and litterfall phenologies.</p>
<pre><code>python phenology.py pft &lt;pft&gt; tune-reco-o2-limit
</code></pre>
<p>The "set" command and &ndash;fixed argument can be used together to, e.g., turn off
the O2 diffusion limit for a given PFT:</p>
<pre><code># Set initial value of km_oxy = 0 and keep it there (along with d_gas)
python phenology.py pft &lt;pft&gt; set km_oxy 0 tune-reco-limit
    --fixed=[d_gas,km_oxy]
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Extensions to SMAP L4C (and calibration) to support autotrophic respiration,
soil respiration, and litterfall phenologies.

    python phenology.py pft &lt;pft&gt; tune-reco-o2-limit

The &#34;set&#34; command and --fixed argument can be used together to, e.g., turn off
the O2 diffusion limit for a given PFT:

    # Set initial value of km_oxy = 0 and keep it there (along with d_gas)
    python phenology.py pft &lt;pft&gt; set km_oxy 0 tune-reco-limit
        --fixed=[d_gas,km_oxy]
&#39;&#39;&#39;

import h5py
import nlopt
import numpy as np
import matplotlib
from functools import partial
from matplotlib import pyplot
from pyl4c import suppress_warnings
from pyl4c.apps.calibration.main import CLI, CONFIG
from pyl4c.science import arrhenius
from pyl4c.stats import linear_constraint
from pyl4c.apps.calibration import GenericOptimization, BPLUT, cbar, report_fit_stats, solve_least_squares
from pyl4c.data.fixtures import restore_bplut

# Constrained optimization bounds
OPT_BOUNDS = {
    # After Davidson et al. (2012)...
    #   Median d_gas in completely dry soil conditions (soil VWC &lt; 5th
    #       percentile): 3.82
    &#39;reco_o2_limit&#39;: ( # CUE, tsoil, smsf0, smsf1, d_gas, km_oxy
        np.array((0.0,   1,    0,  25, 3, 0.01)),
        np.array((0.7, 800, 24.9, 100, 5, 0.15))),
    &#39;reco_variable_cue&#39;: ( # CUE, tsoil, smsf0, smsf1, par0, par1
        np.array((0.0,   1,    0,  25,    0,  2.01)),
        np.array((0.7, 800, 24.9, 100, 1.99, 20))),
}
NEW_PARAMETERS = (&#39;d_gas&#39;, &#39;km_oxy&#39;, &#39;par0&#39;, &#39;par1&#39;)
L4C_PARAMETERS = list(BPLUT._labels)
L4C_PARAMETERS.extend(NEW_PARAMETERS)

class PhenologyCalibrationCLI(CLI):
    &#39;&#39;&#39;
    Command line interface for calibrating L4C with various phenology
    mechanisms included.
    &#39;&#39;&#39;
    _parameters = {
        &#39;gpp&#39;: (
            &#39;LUE&#39;, &#39;tmin0&#39;, &#39;tmin1&#39;, &#39;vpd0&#39;, &#39;vpd1&#39;, &#39;smrz0&#39;, &#39;smrz1&#39;, &#39;ft0&#39;),
        &#39;reco&#39;: (
            &#39;CUE&#39;, &#39;tsoil&#39;, &#39;smsf0&#39;, &#39;smsf1&#39;),
        &#39;reco_o2_limit&#39;: (
            &#39;CUE&#39;, &#39;tsoil&#39;, &#39;smsf0&#39;, &#39;smsf1&#39;, &#39;d_gas&#39;, &#39;km_oxy&#39;),
        &#39;reco_variable_cue&#39;: (
            &#39;CUE&#39;, &#39;tsoil&#39;, &#39;smsf0&#39;, &#39;smsf1&#39;, &#39;par0&#39;, &#39;par1&#39;)
    }

    def __init__(
            self, config = CONFIG, pft = None, start = None, end = None,
            debug = True, use_legacy_pft = True):
        super().__init__(
            config = config, pft = pft, start = start, end = end,
            debug = debug, use_legacy_pft = use_legacy_pft)
        # (Re-)creates the BPLUT store using the correct (expanded) list of
        #   parameter labels
        self._init_bplut(labels = L4C_PARAMETERS)

    def _configure(
            self, q_rh, q_k, fixed, driver_fields, model = &#39;reco_o2_limit&#39;):
        &#39;Loads driver data, sets starting parameters for RECO calibration&#39;
        assert self._is_setup, &#39;Must run setup first&#39;
        assert q_rh &gt;= 0 and q_rh &lt;= 100 and q_k &gt;= 0 and q_k &lt;= 100,\
            &#39;Invalid setting for &#34;q_rh&#34; or &#34;q_k&#34; parameters&#39;
        params = self._parameters[model]
        if fixed is not None:
            assert all(p in params for p in fixed),\
                &#39;Arguments to &#34;fixed&#34; should be in: [%s]&#39; % &#39;, &#39;.join(params)
        init_params = self.bplut.flat(self._pft, params)
        # Read in data, with optional subsetting of the time axis
        t0 = self._time_start if self._time_start is not None else 0
        t1 = self._time_end if self._time_end is not None else self._nsteps
        with h5py.File(self._path_to_drivers, &#39;r&#39;) as hdf:
            self._drivers = [
                hdf[&#39;drivers/%s&#39; % field][t0:t1,self._sites]
                for field in driver_fields
            ]
        with h5py.File(self._path_to_scratch, &#39;r&#39;) as hdf:
            self._gpp_tower = hdf[&#39;tower/GPP&#39;][t0:t1,self._sites,:].mean(axis = 2)
            self._reco_tower = hdf[&#39;tower/RECO&#39;][t0:t1,self._sites,:].mean(axis = 2)
            self._site_weights = hdf[&#39;site_weights&#39;][:,self._sites]
        # L4C drivers should have no NaNs, based on how they were sourced
        for arr in self._drivers:
            assert np.all(~np.isnan(arr)), &#39;Unexpected NaNs&#39;
        return init_params

    def _tune(
            self, fit, residuals, init_params, fixed_params, step_sizes, trials,
            optimize, nlopt):
        &#39;&#39;&#39;
        Runs the optimization.

        Parameters
        ----------
        fit : function
            The function that returns fit values, given parameters
        residuals : function
            The function that returns residuals, given parameters
        init_params : tuple or list or numpy.ndarray
        fixed_params : tuple or list or numpy.ndarray
        step_sizes : tuple or list or numpy.ndarray
        trials : int
        optimize : bool
        nlopt : bool
        &#39;&#39;&#39;
        # Get bounds for the parameter search
        bounds = self._bounds(
            init_params, self._model_name, fixed_params, bounds = OPT_BOUNDS)
        params = []
        params0 = []
        scores = []
        param_space = np.linspace(bounds[0], bounds[1], 100)
        for t in range(0, trials):
            # If multiple trials, randomize the initial parameter values
            #   and score the model in each trial
            if optimize and trials &gt; 1:
                p = param_space.shape[1] # Number of parameters
                idx = np.random.randint(0, param_space.shape[0], p)
                init_params = param_space[idx,np.arange(0, p)]
                params0.append(init_params)
            if optimize and not nlopt:
                # Apply constrained, non-linear least-squares optimization
                #   NOTE: arctan loss function doesn&#39;t work well here
                if &#39;loss&#39; in kwargs.keys():
                    print(&#39;NOTE: Overriding &#34;loss&#34; function specification&#39;)
                kwargs.update({&#39;loss&#39;: &#39;linear&#39;})
                solution = solve_least_squares(
                    residuals, init_params,
                    labels = self._parameters[self._model_name],
                    bounds = bounds, **kwargs)
                fitted = solution.x.tolist()
                message = solution.message
            elif optimize and nlopt:
                opt = GenericOptimization(
                    residuals, bounds, step_size = step_sizes)
                fitted = opt.solve(init_params)
                message = &#39;Success&#39;
            else:
                fitted = [None for i in range(0, len(init_params))]
                break # Do not iterate through trials if not optimizing
            # Record the found solution and its goodness-of-fit score
            params.append(fitted)
            _, rmse_score, _, _ = self._report_fit(
                self._reco_tower, fit(fitted if optimize else init_params),
                self._site_weights, verbose = False)
            print(&#39;[%s/%s] RMSE score of last trial: %.3f&#39; % (
                str(t + 1).zfill(2), str(trials).zfill(2), rmse_score))
            scores.append(rmse_score)

        # Select the fit params with the best score
        if optimize and trials &gt; 1:
            fitted = params[np.argmin(scores)]
            init_params = params0[np.argmin(scores)]
        # Generate and print a report, update the BPLUT parameters
        self._report(
            init_params, fitted, self._parameters[self._model_name],
            &#39;RECO Optimization&#39;)
        self._report_fit(
            self._reco_tower, fit(fitted if optimize else init_params),
            self._site_weights)
        if optimize:
            user_prompt = input(&#39;Update parameters for PFT=%d? [Y/n] &#39; % self._pft)
            do_write = user_prompt == &#39;Y&#39;
            if do_write:
                print(&#39;Updating parameters for PFT=%d...&#39; % self._pft)
                self.bplut.update(self._pft, fitted,
                self._parameters[self._model_name])

    def plot_reco_o2_limit(
            self, q_rh = 75, q_k = 50, ylim = [-0.1, 3], **kwargs):
        &#39;&#39;&#39;
        Plots both the soil moisture (wetness) ramp function and the O2
        diffusion limitation curve (a function of soil volumetric water
        content).

        Parameters
        ----------
        q_rh : int
            The percentile of RH/Kmult to use in calculating Cbar
        q_k : int
            The percentile of Kmult below which RH/Kmult values are masked
        ylim : tuple or list
            Sequence of 2 values, the lower and upper limits for the vertical
            axis of the plot
        &#39;&#39;&#39;
        matplotlib.rcParams[&#39;text.usetex&#39;] = True
        matplotlib.rc(&#39;font&#39;, **{
            &#39;weight&#39; : &#39;bold&#39;,
            &#39;size&#39;   : 14
        })
        init_params = self._configure(
            q_rh, q_k, None, (&#39;tsoil&#39;, &#39;smsf&#39;), model = &#39;reco_o2_limit&#39;)
        assert not np.isnan(init_params).any(),\
            &#39;Some required parameters are undefined; run calibration first&#39;
        with h5py.File(self._path_to_drivers, &#39;r&#39;) as hdf:
            porosity = hdf[&#39;state/porosity&#39;][self._sites]
        tsoil, smsf = self._drivers
        soil_vwc = np.multiply(smsf / 100, porosity)
        self._drivers.append(soil_vwc)
        f_smsf = linear_constraint(*self.bplut[&#39;smsf&#39;][:,self._pft])
        k_mult = f_smsf(smsf) * arrhenius(tsoil, self.bplut[&#39;tsoil&#39;][0,self._pft])
        # Calculate RH as (RECO - RA)
        rh = self._reco_tower - ((1 - self.bplut[&#39;CUE&#39;][0,self._pft]) * self._gpp_tower)
        # Set negative RH values to zero
        rh = np.where(suppress_warnings(np.less)(rh, 0), 0, rh)
        cbar0 = suppress_warnings(cbar)(rh, k_mult, q_rh, q_k)
        # Update plotting parameters
        kwargs.setdefault(&#39;alpha&#39;, 0.08)
        kwargs.setdefault(&#39;marker&#39;, &#39;.&#39;)
        pyplot.scatter(smsf, suppress_warnings(np.divide)(rh, cbar0), **kwargs)
        pyplot.plot(*self._ramp(smsf, &#39;smsf&#39;), &#39;k-&#39;, label = &#39;Substrate Diffusion&#39;)
        domain, _ = self._ramp(smsf, &#39;smsf&#39;)
        conc_O2 = init_params[4] * 0.2095 * np.power(0.8 - np.multiply(domain / 100, 0.8), 4/3)
        pyplot.plot(domain, conc_O2 / (init_params[5] + conc_O2), &#39;r-&#39;, label = &#39;O2 Diffusion&#39;)
        pyplot.xlabel(&#39;Surface Soil Moisture Wetness (\%)&#39;)
        pyplot.ylabel(r&#39;$R_H$/$\bar{C}$&#39;)
        pyplot.title(&#39;RH Response in PFT=%d at Maximum Soil Porosity&#39; % self._pft)
        pyplot.ylim(*ylim)
        pyplot.legend()
        pyplot.show()

    def tune_reco_o2_limit(
            self, q_rh = 75, q_k = 50, fixed = None, optimize = True,
            nlopt = True, trials = 1, infer_diff_coefs = True, **kwargs):
        &#39;&#39;&#39;
        Optimizes RECO for a model that includes an O2 diffusion limitation
        with Michaelis-Menten kinetics. The 9-km mean L4C RECO is fit to the
        tower-observed RECO using constrained, non-linear least-squares
        optimization.
        Considerations:
            1) Negative RH values (i.e., NPP &gt; RECO) are set to zero.

        Parameters
        ----------
        q_rh : int
            The percentile of RH/Kmult to use in calculating Cbar
        q_k : int
            The percentile of Kmult below which RH/Kmult values are masked
        fixed : tuple or list
            Zero or more parameters whose values should be fixed
            (i.e, NOT optimized)
        optimize : bool
            False to only report parameters and their fit statistics instead
            of optimizing (Default: True)
        nlopt : bool
            True to use the nlopt library for optimization (Default: True)
        trials : int
            Number of searches of the parameter space to perform; if &gt;1,
            initial parameters are randomized for each trial
        infer_diff_coefs : bool
            True to infer the diffusion coefficients based on characteristic
            soil moisture conditions (Default: True); if False, coefficients
            will be fit to the tower respiration data
        **kwargs
            Any number of additional keyword arguments to
            scipy.optimize.least_squares()
        &#39;&#39;&#39;
        def k_mult(params):
            # Calculate K_mult* based on current parameters
            #   *K_mult but including O2 diffusion limitation
            f_tsoil = partial(arrhenius, beta0 = params[1])
            f_smsf  = linear_constraint(params[2], params[3])
            tsoil, smsf, soil_vwc, porosity = self._drivers
            conc_O2 = concentration_O2(params, soil_vwc, porosity)
            mm_O2 = conc_O2 / (params[5] + conc_O2) # km_oxy param
            return f_tsoil(tsoil) * np.min(
                np.stack((f_smsf(smsf), mm_O2)), axis = 0)

        def concentration_O2(params, soil_vwc, porosity):
            air_frac_O2 = 0.2095 # Liters of O2 per liter of air (20.95%)
            d_gas = params[4]
            return d_gas * air_frac_O2 * np.power(porosity - soil_vwc, 4/3)

        @suppress_warnings
        def reco(params):
            # Calculate RH as (RECO - RA) or (RECO - (faut * GPP));
            ra = ((1 - params[0]) * self._gpp_tower)
            rh = self._reco_tower - ra
            rh = np.where(rh &lt; 0, 0, rh) # Mask out negative RH values
            # Compute Cbar with globals &#34;q_rh&#34; and &#34;q_k&#34;
            kmult0 = k_mult(params)
            cbar0 = cbar(rh, kmult0, q_rh, q_k)
            return ra + (kmult0 * cbar0)

        def residuals(params):
            # Objective function: Difference between tower RECO and L4C RECO
            reco0 = reco(params)
            diff = np.subtract(self._reco_tower, reco0)
            # Multiply by the tower weights
            return (self._site_weights * diff)[np.isfinite(diff)]

        self._model_name = &#39;reco_o2_limit&#39;
        if infer_diff_coefs and fixed is not None:
            raise ValueError(&#39;Cannot set both --infer-diff-coefs and --fixed&#39;)
        init_params = self._configure(
            q_rh, q_k, fixed, (&#39;tsoil&#39;, &#39;smsf&#39;), model = self._model_name)
        # Set defaults where needed
        if np.isnan(init_params).any():
            init_params[np.isnan(init_params)] = np.array(
                [0.4, 270, 10, 50, 3.78, 0.105])[np.isnan(init_params)]
        with h5py.File(self._path_to_drivers, &#39;r&#39;) as hdf:
            porosity = hdf[&#39;state/porosity&#39;][self._sites]
        # NOTE: Converting from &#34;wetness&#34; to volumetric water content (VWC)
        _, smsf = self._drivers
        soil_vwc = np.multiply(smsf / 100, porosity)
        self._drivers.extend((soil_vwc, porosity))

        # Optionally, instead of fitting d_gas and km_oxy, we can infer their
        #   values based on the soil moisture distribution
        if infer_diff_coefs:
            a = np.power(np.subtract(porosity, soil_vwc), 4/3)
            soil_vwc_ptiles = np.percentile(soil_vwc, (5, 50))
            # d_gas when soil is completely dry assuming soil [O2] = atm. [O2]
            d_gas = np.median(1 / a[soil_vwc &lt;= soil_vwc_ptiles[0]])
            km_oxy = np.median(
                d_gas * 0.2095 * np.power(porosity - soil_vwc_ptiles[1], 4/3))
            print(&#39;Inferred coefficients: d_gas = %.2f; km_oxy = %.3f&#39; % (d_gas, km_oxy))
            init_params[4] = d_gas
            init_params[5] = km_oxy
            fixed = [] if fixed is None else fixed
            fixed = set(fixed).union((&#39;d_gas&#39;, &#39;km_oxy&#39;))
        self._tune( # Step sizes specified here
            reco, residuals, init_params, fixed, (0.01, 1, 0.1, 0.1, 0.1, 0.002),
            trials, optimize, nlopt)

    def plot_variable_cue(
            self, q_rh = 75, q_k = 50, ylim=[-0.1, 1.1], **kwargs):
        &#39;&#39;&#39;
        Plots empirical carbon-use efficiency (CUE) against photosynthetically
        active radiation (PAR).

        Parameters
        ----------
        q_rh : int
            The percentile of RH/Kmult to use in calculating Cbar
        q_k : int
            The percentile of Kmult below which RH/Kmult values are masked
        ylim : tuple or list
            Sequence of 2 values, the lower and upper limits for the vertical
            axis of the plot
        &#39;&#39;&#39;
        @suppress_warnings
        def empirical_cue(ra, gpp, pclip = (1, 99)):
            cue0 = (1 - np.divide(ra, np.where(gpp &gt; 0, gpp, np.nan)))
            cue0[cue0 &lt; np.nanpercentile(cue0, pclip[0])] = np.nan
            cue0[cue0 &gt; np.nanpercentile(cue0, pclip[1])] = np.nan
            return cue0

        with h5py.File(self._path_to_drivers, &#39;r&#39;) as hdf:
            soc = hdf[&#39;state/soil_organic_carbon&#39;][:,self._sites,:].mean(axis = 2)

        matplotlib.rcParams[&#39;text.usetex&#39;] = True
        matplotlib.rc(&#39;font&#39;, **{
            &#39;weight&#39; : &#39;bold&#39;,
            &#39;size&#39;   : 14
        })
        # Update plotting parameters
        kwargs.setdefault(&#39;alpha&#39;, 0.08)
        kwargs.setdefault(&#39;marker&#39;, &#39;.&#39;)
        init_params = self._configure(
            q_rh, q_k, None, (&#39;tsoil&#39;, &#39;smsf&#39;, &#39;par&#39;), model = &#39;reco_variable_cue&#39;)
        assert not np.isnan(init_params).any(),\
            &#39;Some required parameters are undefined; run calibration first&#39;
        with h5py.File(self._path_to_drivers, &#39;r&#39;) as hdf:
            porosity = hdf[&#39;state/porosity&#39;][self._sites]
        tsoil, smsf, par = self._drivers
        f_par = linear_constraint(*self.bplut[&#39;par&#39;][:,self._pft].tolist())
        # Generate (fixed) TSOIL and SMSF ramp functions
        f_tsoil = partial(arrhenius, beta0 = self.bplut[&#39;tsoil&#39;][0,self._pft])
        f_smsf  = linear_constraint(*self.bplut[&#39;smsf&#39;][:,self._pft].tolist())
        kmult = f_tsoil(tsoil) * f_smsf(smsf)
        rh = np.stack([
            kmult * soc[i,...] * self.bplut[&#39;decay_rates&#39;][i,self._pft]
            for i in range(0, 3)
        ], axis = 0)
        rh[1,...] = rh[1,...] * (1 - self.bplut[&#39;f_structural&#39;][0,self._pft])
        ra = self._reco_tower - rh.sum(axis = 0)
        ra = np.where(suppress_warnings(np.less)(ra, 0), np.nan, ra)
        kwargs.setdefault(&#39;alpha&#39;, 0.05)
        kwargs.setdefault(&#39;marker&#39;, &#39;.&#39;)
        pyplot.scatter(par, empirical_cue(ra, self._gpp_tower), **kwargs)
        pyplot.xlabel(&#39;Photosynthetically Active Radiation (PAR)&#39;)
        pyplot.ylabel(&#39;Empirical CUE (1 - $R_A$/GPP)&#39;)
        pyplot.title(&#39;PFT=%d&#39; % self._pft)
        domain = np.arange(np.nanmin(par), np.nanmax(par), 0.1)
        ramp = self._constrain(domain, &#39;par&#39;)
        pyplot.plot(domain, self.bplut[&#39;CUE&#39;][0,self._pft] * ramp, &#39;k-&#39;)
        pyplot.ylim(*ylim)
        pyplot.show()

    def tune_variable_cue(
            self, q_rh = 75, q_k = 50, fixed = None, optimize = True,
            nlopt = True, trials = 1, **kwargs):
        &#39;&#39;&#39;
        Optimizes RECO for a model that includes the Kok effect (CUE varies
        linearly with PAR). The 9-km mean L4C RECO is fit to the
        tower-observed RECO using constrained, non-linear least-squares
        optimization.
        Considerations:
            1) Negative RH values (i.e., NPP &gt; RECO) are set to zero.

        Parameters
        ----------
        q_rh : int
            The percentile of RH/Kmult to use in calculating Cbar
        q_k : int
            The percentile of Kmult below which RH/Kmult values are masked
        fixed : tuple or list
            Zero or more parameters whose values should be fixed
            (i.e, NOT optimized)
        optimize : bool
            False to only report parameters and their fit statistics instead
            of optimizing (Default: True)
        nlopt : bool
            True to use the nlopt library for optimization (Default: True)
        trials : int
            Number of searches of the parameter space to perform; if &gt;1,
            initial parameters are randomized for each trial
        **kwargs
            Any number of additional keyword arguments to
            scipy.optimize.least_squares()
        &#39;&#39;&#39;
        def k_mult(params):
            # Calculate K_mult based on current parameters
            f_tsoil = partial(arrhenius, beta0 = params[1])
            f_smsf  = linear_constraint(params[2], params[3])
            tsoil, smsf, _ = self._drivers
            return f_tsoil(tsoil) * f_smsf(smsf)

        @suppress_warnings
        def reco(params):
            f_par = linear_constraint(params[-2], params[-1])
            _, _, par = self._drivers
            ra = ((1 - (f_par(par) * params[0])) * self._gpp_tower)
            # Calculate RH as (RECO - RA) or (RECO - (faut * GPP));
            rh = self._reco_tower - ra
            rh = np.where(rh &lt; 0, 0, rh) # Mask out negative RH values
            # Compute Cbar with globals &#34;q_rh&#34; and &#34;q_k&#34;
            kmult0 = k_mult(params)
            cbar0 = cbar(rh, kmult0, q_rh, q_k)
            return ra + (kmult0 * cbar0)

        def residuals(params):
            # Objective function: Difference between tower RECO and L4C RECO
            reco0 = reco(params)
            diff = np.subtract(self._reco_tower, reco0)
            # Multiply by the tower weights
            return (self._site_weights * diff)[np.isfinite(diff)]

        self._model_name = &#39;reco_variable_cue&#39;
        init_params = self._configure(
            q_rh, q_k, fixed, (&#39;tsoil&#39;, &#39;smsf&#39;, &#39;par&#39;), model = self._model_name)
        # Set defaults where needed
        if np.isnan(init_params).any():
            init_params[np.isnan(init_params)] = np.array(
                [0.4, 270, 10, 50, 1, 5])[np.isnan(init_params)]
        self._tune( # Step sizes specified here
            reco, residuals, init_params, fixed, (0.01, 1, 0.1, 0.1, 0.02, 0.02),
            trials, optimize, nlopt)


if __name__ == &#39;__main__&#39;:
    import fire
    fire.Fire(PhenologyCalibrationCLI)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyl4c.apps.calibration.extensions.phenology.PhenologyCalibrationCLI"><code class="flex name class">
<span>class <span class="ident">PhenologyCalibrationCLI</span></span>
<span>(</span><span>config='/usr/local/dev/pyl4c/pyl4c/data/files/config_calibration.json', pft=None, start=None, end=None, debug=True, use_legacy_pft=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Command line interface for calibrating L4C with various phenology
mechanisms included.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PhenologyCalibrationCLI(CLI):
    &#39;&#39;&#39;
    Command line interface for calibrating L4C with various phenology
    mechanisms included.
    &#39;&#39;&#39;
    _parameters = {
        &#39;gpp&#39;: (
            &#39;LUE&#39;, &#39;tmin0&#39;, &#39;tmin1&#39;, &#39;vpd0&#39;, &#39;vpd1&#39;, &#39;smrz0&#39;, &#39;smrz1&#39;, &#39;ft0&#39;),
        &#39;reco&#39;: (
            &#39;CUE&#39;, &#39;tsoil&#39;, &#39;smsf0&#39;, &#39;smsf1&#39;),
        &#39;reco_o2_limit&#39;: (
            &#39;CUE&#39;, &#39;tsoil&#39;, &#39;smsf0&#39;, &#39;smsf1&#39;, &#39;d_gas&#39;, &#39;km_oxy&#39;),
        &#39;reco_variable_cue&#39;: (
            &#39;CUE&#39;, &#39;tsoil&#39;, &#39;smsf0&#39;, &#39;smsf1&#39;, &#39;par0&#39;, &#39;par1&#39;)
    }

    def __init__(
            self, config = CONFIG, pft = None, start = None, end = None,
            debug = True, use_legacy_pft = True):
        super().__init__(
            config = config, pft = pft, start = start, end = end,
            debug = debug, use_legacy_pft = use_legacy_pft)
        # (Re-)creates the BPLUT store using the correct (expanded) list of
        #   parameter labels
        self._init_bplut(labels = L4C_PARAMETERS)

    def _configure(
            self, q_rh, q_k, fixed, driver_fields, model = &#39;reco_o2_limit&#39;):
        &#39;Loads driver data, sets starting parameters for RECO calibration&#39;
        assert self._is_setup, &#39;Must run setup first&#39;
        assert q_rh &gt;= 0 and q_rh &lt;= 100 and q_k &gt;= 0 and q_k &lt;= 100,\
            &#39;Invalid setting for &#34;q_rh&#34; or &#34;q_k&#34; parameters&#39;
        params = self._parameters[model]
        if fixed is not None:
            assert all(p in params for p in fixed),\
                &#39;Arguments to &#34;fixed&#34; should be in: [%s]&#39; % &#39;, &#39;.join(params)
        init_params = self.bplut.flat(self._pft, params)
        # Read in data, with optional subsetting of the time axis
        t0 = self._time_start if self._time_start is not None else 0
        t1 = self._time_end if self._time_end is not None else self._nsteps
        with h5py.File(self._path_to_drivers, &#39;r&#39;) as hdf:
            self._drivers = [
                hdf[&#39;drivers/%s&#39; % field][t0:t1,self._sites]
                for field in driver_fields
            ]
        with h5py.File(self._path_to_scratch, &#39;r&#39;) as hdf:
            self._gpp_tower = hdf[&#39;tower/GPP&#39;][t0:t1,self._sites,:].mean(axis = 2)
            self._reco_tower = hdf[&#39;tower/RECO&#39;][t0:t1,self._sites,:].mean(axis = 2)
            self._site_weights = hdf[&#39;site_weights&#39;][:,self._sites]
        # L4C drivers should have no NaNs, based on how they were sourced
        for arr in self._drivers:
            assert np.all(~np.isnan(arr)), &#39;Unexpected NaNs&#39;
        return init_params

    def _tune(
            self, fit, residuals, init_params, fixed_params, step_sizes, trials,
            optimize, nlopt):
        &#39;&#39;&#39;
        Runs the optimization.

        Parameters
        ----------
        fit : function
            The function that returns fit values, given parameters
        residuals : function
            The function that returns residuals, given parameters
        init_params : tuple or list or numpy.ndarray
        fixed_params : tuple or list or numpy.ndarray
        step_sizes : tuple or list or numpy.ndarray
        trials : int
        optimize : bool
        nlopt : bool
        &#39;&#39;&#39;
        # Get bounds for the parameter search
        bounds = self._bounds(
            init_params, self._model_name, fixed_params, bounds = OPT_BOUNDS)
        params = []
        params0 = []
        scores = []
        param_space = np.linspace(bounds[0], bounds[1], 100)
        for t in range(0, trials):
            # If multiple trials, randomize the initial parameter values
            #   and score the model in each trial
            if optimize and trials &gt; 1:
                p = param_space.shape[1] # Number of parameters
                idx = np.random.randint(0, param_space.shape[0], p)
                init_params = param_space[idx,np.arange(0, p)]
                params0.append(init_params)
            if optimize and not nlopt:
                # Apply constrained, non-linear least-squares optimization
                #   NOTE: arctan loss function doesn&#39;t work well here
                if &#39;loss&#39; in kwargs.keys():
                    print(&#39;NOTE: Overriding &#34;loss&#34; function specification&#39;)
                kwargs.update({&#39;loss&#39;: &#39;linear&#39;})
                solution = solve_least_squares(
                    residuals, init_params,
                    labels = self._parameters[self._model_name],
                    bounds = bounds, **kwargs)
                fitted = solution.x.tolist()
                message = solution.message
            elif optimize and nlopt:
                opt = GenericOptimization(
                    residuals, bounds, step_size = step_sizes)
                fitted = opt.solve(init_params)
                message = &#39;Success&#39;
            else:
                fitted = [None for i in range(0, len(init_params))]
                break # Do not iterate through trials if not optimizing
            # Record the found solution and its goodness-of-fit score
            params.append(fitted)
            _, rmse_score, _, _ = self._report_fit(
                self._reco_tower, fit(fitted if optimize else init_params),
                self._site_weights, verbose = False)
            print(&#39;[%s/%s] RMSE score of last trial: %.3f&#39; % (
                str(t + 1).zfill(2), str(trials).zfill(2), rmse_score))
            scores.append(rmse_score)

        # Select the fit params with the best score
        if optimize and trials &gt; 1:
            fitted = params[np.argmin(scores)]
            init_params = params0[np.argmin(scores)]
        # Generate and print a report, update the BPLUT parameters
        self._report(
            init_params, fitted, self._parameters[self._model_name],
            &#39;RECO Optimization&#39;)
        self._report_fit(
            self._reco_tower, fit(fitted if optimize else init_params),
            self._site_weights)
        if optimize:
            user_prompt = input(&#39;Update parameters for PFT=%d? [Y/n] &#39; % self._pft)
            do_write = user_prompt == &#39;Y&#39;
            if do_write:
                print(&#39;Updating parameters for PFT=%d...&#39; % self._pft)
                self.bplut.update(self._pft, fitted,
                self._parameters[self._model_name])

    def plot_reco_o2_limit(
            self, q_rh = 75, q_k = 50, ylim = [-0.1, 3], **kwargs):
        &#39;&#39;&#39;
        Plots both the soil moisture (wetness) ramp function and the O2
        diffusion limitation curve (a function of soil volumetric water
        content).

        Parameters
        ----------
        q_rh : int
            The percentile of RH/Kmult to use in calculating Cbar
        q_k : int
            The percentile of Kmult below which RH/Kmult values are masked
        ylim : tuple or list
            Sequence of 2 values, the lower and upper limits for the vertical
            axis of the plot
        &#39;&#39;&#39;
        matplotlib.rcParams[&#39;text.usetex&#39;] = True
        matplotlib.rc(&#39;font&#39;, **{
            &#39;weight&#39; : &#39;bold&#39;,
            &#39;size&#39;   : 14
        })
        init_params = self._configure(
            q_rh, q_k, None, (&#39;tsoil&#39;, &#39;smsf&#39;), model = &#39;reco_o2_limit&#39;)
        assert not np.isnan(init_params).any(),\
            &#39;Some required parameters are undefined; run calibration first&#39;
        with h5py.File(self._path_to_drivers, &#39;r&#39;) as hdf:
            porosity = hdf[&#39;state/porosity&#39;][self._sites]
        tsoil, smsf = self._drivers
        soil_vwc = np.multiply(smsf / 100, porosity)
        self._drivers.append(soil_vwc)
        f_smsf = linear_constraint(*self.bplut[&#39;smsf&#39;][:,self._pft])
        k_mult = f_smsf(smsf) * arrhenius(tsoil, self.bplut[&#39;tsoil&#39;][0,self._pft])
        # Calculate RH as (RECO - RA)
        rh = self._reco_tower - ((1 - self.bplut[&#39;CUE&#39;][0,self._pft]) * self._gpp_tower)
        # Set negative RH values to zero
        rh = np.where(suppress_warnings(np.less)(rh, 0), 0, rh)
        cbar0 = suppress_warnings(cbar)(rh, k_mult, q_rh, q_k)
        # Update plotting parameters
        kwargs.setdefault(&#39;alpha&#39;, 0.08)
        kwargs.setdefault(&#39;marker&#39;, &#39;.&#39;)
        pyplot.scatter(smsf, suppress_warnings(np.divide)(rh, cbar0), **kwargs)
        pyplot.plot(*self._ramp(smsf, &#39;smsf&#39;), &#39;k-&#39;, label = &#39;Substrate Diffusion&#39;)
        domain, _ = self._ramp(smsf, &#39;smsf&#39;)
        conc_O2 = init_params[4] * 0.2095 * np.power(0.8 - np.multiply(domain / 100, 0.8), 4/3)
        pyplot.plot(domain, conc_O2 / (init_params[5] + conc_O2), &#39;r-&#39;, label = &#39;O2 Diffusion&#39;)
        pyplot.xlabel(&#39;Surface Soil Moisture Wetness (\%)&#39;)
        pyplot.ylabel(r&#39;$R_H$/$\bar{C}$&#39;)
        pyplot.title(&#39;RH Response in PFT=%d at Maximum Soil Porosity&#39; % self._pft)
        pyplot.ylim(*ylim)
        pyplot.legend()
        pyplot.show()

    def tune_reco_o2_limit(
            self, q_rh = 75, q_k = 50, fixed = None, optimize = True,
            nlopt = True, trials = 1, infer_diff_coefs = True, **kwargs):
        &#39;&#39;&#39;
        Optimizes RECO for a model that includes an O2 diffusion limitation
        with Michaelis-Menten kinetics. The 9-km mean L4C RECO is fit to the
        tower-observed RECO using constrained, non-linear least-squares
        optimization.
        Considerations:
            1) Negative RH values (i.e., NPP &gt; RECO) are set to zero.

        Parameters
        ----------
        q_rh : int
            The percentile of RH/Kmult to use in calculating Cbar
        q_k : int
            The percentile of Kmult below which RH/Kmult values are masked
        fixed : tuple or list
            Zero or more parameters whose values should be fixed
            (i.e, NOT optimized)
        optimize : bool
            False to only report parameters and their fit statistics instead
            of optimizing (Default: True)
        nlopt : bool
            True to use the nlopt library for optimization (Default: True)
        trials : int
            Number of searches of the parameter space to perform; if &gt;1,
            initial parameters are randomized for each trial
        infer_diff_coefs : bool
            True to infer the diffusion coefficients based on characteristic
            soil moisture conditions (Default: True); if False, coefficients
            will be fit to the tower respiration data
        **kwargs
            Any number of additional keyword arguments to
            scipy.optimize.least_squares()
        &#39;&#39;&#39;
        def k_mult(params):
            # Calculate K_mult* based on current parameters
            #   *K_mult but including O2 diffusion limitation
            f_tsoil = partial(arrhenius, beta0 = params[1])
            f_smsf  = linear_constraint(params[2], params[3])
            tsoil, smsf, soil_vwc, porosity = self._drivers
            conc_O2 = concentration_O2(params, soil_vwc, porosity)
            mm_O2 = conc_O2 / (params[5] + conc_O2) # km_oxy param
            return f_tsoil(tsoil) * np.min(
                np.stack((f_smsf(smsf), mm_O2)), axis = 0)

        def concentration_O2(params, soil_vwc, porosity):
            air_frac_O2 = 0.2095 # Liters of O2 per liter of air (20.95%)
            d_gas = params[4]
            return d_gas * air_frac_O2 * np.power(porosity - soil_vwc, 4/3)

        @suppress_warnings
        def reco(params):
            # Calculate RH as (RECO - RA) or (RECO - (faut * GPP));
            ra = ((1 - params[0]) * self._gpp_tower)
            rh = self._reco_tower - ra
            rh = np.where(rh &lt; 0, 0, rh) # Mask out negative RH values
            # Compute Cbar with globals &#34;q_rh&#34; and &#34;q_k&#34;
            kmult0 = k_mult(params)
            cbar0 = cbar(rh, kmult0, q_rh, q_k)
            return ra + (kmult0 * cbar0)

        def residuals(params):
            # Objective function: Difference between tower RECO and L4C RECO
            reco0 = reco(params)
            diff = np.subtract(self._reco_tower, reco0)
            # Multiply by the tower weights
            return (self._site_weights * diff)[np.isfinite(diff)]

        self._model_name = &#39;reco_o2_limit&#39;
        if infer_diff_coefs and fixed is not None:
            raise ValueError(&#39;Cannot set both --infer-diff-coefs and --fixed&#39;)
        init_params = self._configure(
            q_rh, q_k, fixed, (&#39;tsoil&#39;, &#39;smsf&#39;), model = self._model_name)
        # Set defaults where needed
        if np.isnan(init_params).any():
            init_params[np.isnan(init_params)] = np.array(
                [0.4, 270, 10, 50, 3.78, 0.105])[np.isnan(init_params)]
        with h5py.File(self._path_to_drivers, &#39;r&#39;) as hdf:
            porosity = hdf[&#39;state/porosity&#39;][self._sites]
        # NOTE: Converting from &#34;wetness&#34; to volumetric water content (VWC)
        _, smsf = self._drivers
        soil_vwc = np.multiply(smsf / 100, porosity)
        self._drivers.extend((soil_vwc, porosity))

        # Optionally, instead of fitting d_gas and km_oxy, we can infer their
        #   values based on the soil moisture distribution
        if infer_diff_coefs:
            a = np.power(np.subtract(porosity, soil_vwc), 4/3)
            soil_vwc_ptiles = np.percentile(soil_vwc, (5, 50))
            # d_gas when soil is completely dry assuming soil [O2] = atm. [O2]
            d_gas = np.median(1 / a[soil_vwc &lt;= soil_vwc_ptiles[0]])
            km_oxy = np.median(
                d_gas * 0.2095 * np.power(porosity - soil_vwc_ptiles[1], 4/3))
            print(&#39;Inferred coefficients: d_gas = %.2f; km_oxy = %.3f&#39; % (d_gas, km_oxy))
            init_params[4] = d_gas
            init_params[5] = km_oxy
            fixed = [] if fixed is None else fixed
            fixed = set(fixed).union((&#39;d_gas&#39;, &#39;km_oxy&#39;))
        self._tune( # Step sizes specified here
            reco, residuals, init_params, fixed, (0.01, 1, 0.1, 0.1, 0.1, 0.002),
            trials, optimize, nlopt)

    def plot_variable_cue(
            self, q_rh = 75, q_k = 50, ylim=[-0.1, 1.1], **kwargs):
        &#39;&#39;&#39;
        Plots empirical carbon-use efficiency (CUE) against photosynthetically
        active radiation (PAR).

        Parameters
        ----------
        q_rh : int
            The percentile of RH/Kmult to use in calculating Cbar
        q_k : int
            The percentile of Kmult below which RH/Kmult values are masked
        ylim : tuple or list
            Sequence of 2 values, the lower and upper limits for the vertical
            axis of the plot
        &#39;&#39;&#39;
        @suppress_warnings
        def empirical_cue(ra, gpp, pclip = (1, 99)):
            cue0 = (1 - np.divide(ra, np.where(gpp &gt; 0, gpp, np.nan)))
            cue0[cue0 &lt; np.nanpercentile(cue0, pclip[0])] = np.nan
            cue0[cue0 &gt; np.nanpercentile(cue0, pclip[1])] = np.nan
            return cue0

        with h5py.File(self._path_to_drivers, &#39;r&#39;) as hdf:
            soc = hdf[&#39;state/soil_organic_carbon&#39;][:,self._sites,:].mean(axis = 2)

        matplotlib.rcParams[&#39;text.usetex&#39;] = True
        matplotlib.rc(&#39;font&#39;, **{
            &#39;weight&#39; : &#39;bold&#39;,
            &#39;size&#39;   : 14
        })
        # Update plotting parameters
        kwargs.setdefault(&#39;alpha&#39;, 0.08)
        kwargs.setdefault(&#39;marker&#39;, &#39;.&#39;)
        init_params = self._configure(
            q_rh, q_k, None, (&#39;tsoil&#39;, &#39;smsf&#39;, &#39;par&#39;), model = &#39;reco_variable_cue&#39;)
        assert not np.isnan(init_params).any(),\
            &#39;Some required parameters are undefined; run calibration first&#39;
        with h5py.File(self._path_to_drivers, &#39;r&#39;) as hdf:
            porosity = hdf[&#39;state/porosity&#39;][self._sites]
        tsoil, smsf, par = self._drivers
        f_par = linear_constraint(*self.bplut[&#39;par&#39;][:,self._pft].tolist())
        # Generate (fixed) TSOIL and SMSF ramp functions
        f_tsoil = partial(arrhenius, beta0 = self.bplut[&#39;tsoil&#39;][0,self._pft])
        f_smsf  = linear_constraint(*self.bplut[&#39;smsf&#39;][:,self._pft].tolist())
        kmult = f_tsoil(tsoil) * f_smsf(smsf)
        rh = np.stack([
            kmult * soc[i,...] * self.bplut[&#39;decay_rates&#39;][i,self._pft]
            for i in range(0, 3)
        ], axis = 0)
        rh[1,...] = rh[1,...] * (1 - self.bplut[&#39;f_structural&#39;][0,self._pft])
        ra = self._reco_tower - rh.sum(axis = 0)
        ra = np.where(suppress_warnings(np.less)(ra, 0), np.nan, ra)
        kwargs.setdefault(&#39;alpha&#39;, 0.05)
        kwargs.setdefault(&#39;marker&#39;, &#39;.&#39;)
        pyplot.scatter(par, empirical_cue(ra, self._gpp_tower), **kwargs)
        pyplot.xlabel(&#39;Photosynthetically Active Radiation (PAR)&#39;)
        pyplot.ylabel(&#39;Empirical CUE (1 - $R_A$/GPP)&#39;)
        pyplot.title(&#39;PFT=%d&#39; % self._pft)
        domain = np.arange(np.nanmin(par), np.nanmax(par), 0.1)
        ramp = self._constrain(domain, &#39;par&#39;)
        pyplot.plot(domain, self.bplut[&#39;CUE&#39;][0,self._pft] * ramp, &#39;k-&#39;)
        pyplot.ylim(*ylim)
        pyplot.show()

    def tune_variable_cue(
            self, q_rh = 75, q_k = 50, fixed = None, optimize = True,
            nlopt = True, trials = 1, **kwargs):
        &#39;&#39;&#39;
        Optimizes RECO for a model that includes the Kok effect (CUE varies
        linearly with PAR). The 9-km mean L4C RECO is fit to the
        tower-observed RECO using constrained, non-linear least-squares
        optimization.
        Considerations:
            1) Negative RH values (i.e., NPP &gt; RECO) are set to zero.

        Parameters
        ----------
        q_rh : int
            The percentile of RH/Kmult to use in calculating Cbar
        q_k : int
            The percentile of Kmult below which RH/Kmult values are masked
        fixed : tuple or list
            Zero or more parameters whose values should be fixed
            (i.e, NOT optimized)
        optimize : bool
            False to only report parameters and their fit statistics instead
            of optimizing (Default: True)
        nlopt : bool
            True to use the nlopt library for optimization (Default: True)
        trials : int
            Number of searches of the parameter space to perform; if &gt;1,
            initial parameters are randomized for each trial
        **kwargs
            Any number of additional keyword arguments to
            scipy.optimize.least_squares()
        &#39;&#39;&#39;
        def k_mult(params):
            # Calculate K_mult based on current parameters
            f_tsoil = partial(arrhenius, beta0 = params[1])
            f_smsf  = linear_constraint(params[2], params[3])
            tsoil, smsf, _ = self._drivers
            return f_tsoil(tsoil) * f_smsf(smsf)

        @suppress_warnings
        def reco(params):
            f_par = linear_constraint(params[-2], params[-1])
            _, _, par = self._drivers
            ra = ((1 - (f_par(par) * params[0])) * self._gpp_tower)
            # Calculate RH as (RECO - RA) or (RECO - (faut * GPP));
            rh = self._reco_tower - ra
            rh = np.where(rh &lt; 0, 0, rh) # Mask out negative RH values
            # Compute Cbar with globals &#34;q_rh&#34; and &#34;q_k&#34;
            kmult0 = k_mult(params)
            cbar0 = cbar(rh, kmult0, q_rh, q_k)
            return ra + (kmult0 * cbar0)

        def residuals(params):
            # Objective function: Difference between tower RECO and L4C RECO
            reco0 = reco(params)
            diff = np.subtract(self._reco_tower, reco0)
            # Multiply by the tower weights
            return (self._site_weights * diff)[np.isfinite(diff)]

        self._model_name = &#39;reco_variable_cue&#39;
        init_params = self._configure(
            q_rh, q_k, fixed, (&#39;tsoil&#39;, &#39;smsf&#39;, &#39;par&#39;), model = self._model_name)
        # Set defaults where needed
        if np.isnan(init_params).any():
            init_params[np.isnan(init_params)] = np.array(
                [0.4, 270, 10, 50, 1, 5])[np.isnan(init_params)]
        self._tune( # Step sizes specified here
            reco, residuals, init_params, fixed, (0.01, 1, 0.1, 0.1, 0.02, 0.02),
            trials, optimize, nlopt)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.calibration.main.CLI" href="../main.html#pyl4c.apps.calibration.main.CLI">CLI</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.calibration.extensions.phenology.PhenologyCalibrationCLI.plot_reco_o2_limit"><code class="name flex">
<span>def <span class="ident">plot_reco_o2_limit</span></span>(<span>self, q_rh=75, q_k=50, ylim=[-0.1, 3], **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots both the soil moisture (wetness) ramp function and the O2
diffusion limitation curve (a function of soil volumetric water
content).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>q_rh</code></strong> :&ensp;<code>int</code></dt>
<dd>The percentile of RH/Kmult to use in calculating Cbar</dd>
<dt><strong><code>q_k</code></strong> :&ensp;<code>int</code></dt>
<dd>The percentile of Kmult below which RH/Kmult values are masked</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>tuple</code> or <code>list</code></dt>
<dd>Sequence of 2 values, the lower and upper limits for the vertical
axis of the plot</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_reco_o2_limit(
        self, q_rh = 75, q_k = 50, ylim = [-0.1, 3], **kwargs):
    &#39;&#39;&#39;
    Plots both the soil moisture (wetness) ramp function and the O2
    diffusion limitation curve (a function of soil volumetric water
    content).

    Parameters
    ----------
    q_rh : int
        The percentile of RH/Kmult to use in calculating Cbar
    q_k : int
        The percentile of Kmult below which RH/Kmult values are masked
    ylim : tuple or list
        Sequence of 2 values, the lower and upper limits for the vertical
        axis of the plot
    &#39;&#39;&#39;
    matplotlib.rcParams[&#39;text.usetex&#39;] = True
    matplotlib.rc(&#39;font&#39;, **{
        &#39;weight&#39; : &#39;bold&#39;,
        &#39;size&#39;   : 14
    })
    init_params = self._configure(
        q_rh, q_k, None, (&#39;tsoil&#39;, &#39;smsf&#39;), model = &#39;reco_o2_limit&#39;)
    assert not np.isnan(init_params).any(),\
        &#39;Some required parameters are undefined; run calibration first&#39;
    with h5py.File(self._path_to_drivers, &#39;r&#39;) as hdf:
        porosity = hdf[&#39;state/porosity&#39;][self._sites]
    tsoil, smsf = self._drivers
    soil_vwc = np.multiply(smsf / 100, porosity)
    self._drivers.append(soil_vwc)
    f_smsf = linear_constraint(*self.bplut[&#39;smsf&#39;][:,self._pft])
    k_mult = f_smsf(smsf) * arrhenius(tsoil, self.bplut[&#39;tsoil&#39;][0,self._pft])
    # Calculate RH as (RECO - RA)
    rh = self._reco_tower - ((1 - self.bplut[&#39;CUE&#39;][0,self._pft]) * self._gpp_tower)
    # Set negative RH values to zero
    rh = np.where(suppress_warnings(np.less)(rh, 0), 0, rh)
    cbar0 = suppress_warnings(cbar)(rh, k_mult, q_rh, q_k)
    # Update plotting parameters
    kwargs.setdefault(&#39;alpha&#39;, 0.08)
    kwargs.setdefault(&#39;marker&#39;, &#39;.&#39;)
    pyplot.scatter(smsf, suppress_warnings(np.divide)(rh, cbar0), **kwargs)
    pyplot.plot(*self._ramp(smsf, &#39;smsf&#39;), &#39;k-&#39;, label = &#39;Substrate Diffusion&#39;)
    domain, _ = self._ramp(smsf, &#39;smsf&#39;)
    conc_O2 = init_params[4] * 0.2095 * np.power(0.8 - np.multiply(domain / 100, 0.8), 4/3)
    pyplot.plot(domain, conc_O2 / (init_params[5] + conc_O2), &#39;r-&#39;, label = &#39;O2 Diffusion&#39;)
    pyplot.xlabel(&#39;Surface Soil Moisture Wetness (\%)&#39;)
    pyplot.ylabel(r&#39;$R_H$/$\bar{C}$&#39;)
    pyplot.title(&#39;RH Response in PFT=%d at Maximum Soil Porosity&#39; % self._pft)
    pyplot.ylim(*ylim)
    pyplot.legend()
    pyplot.show()</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.calibration.extensions.phenology.PhenologyCalibrationCLI.plot_variable_cue"><code class="name flex">
<span>def <span class="ident">plot_variable_cue</span></span>(<span>self, q_rh=75, q_k=50, ylim=[-0.1, 1.1], **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots empirical carbon-use efficiency (CUE) against photosynthetically
active radiation (PAR).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>q_rh</code></strong> :&ensp;<code>int</code></dt>
<dd>The percentile of RH/Kmult to use in calculating Cbar</dd>
<dt><strong><code>q_k</code></strong> :&ensp;<code>int</code></dt>
<dd>The percentile of Kmult below which RH/Kmult values are masked</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>tuple</code> or <code>list</code></dt>
<dd>Sequence of 2 values, the lower and upper limits for the vertical
axis of the plot</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_variable_cue(
        self, q_rh = 75, q_k = 50, ylim=[-0.1, 1.1], **kwargs):
    &#39;&#39;&#39;
    Plots empirical carbon-use efficiency (CUE) against photosynthetically
    active radiation (PAR).

    Parameters
    ----------
    q_rh : int
        The percentile of RH/Kmult to use in calculating Cbar
    q_k : int
        The percentile of Kmult below which RH/Kmult values are masked
    ylim : tuple or list
        Sequence of 2 values, the lower and upper limits for the vertical
        axis of the plot
    &#39;&#39;&#39;
    @suppress_warnings
    def empirical_cue(ra, gpp, pclip = (1, 99)):
        cue0 = (1 - np.divide(ra, np.where(gpp &gt; 0, gpp, np.nan)))
        cue0[cue0 &lt; np.nanpercentile(cue0, pclip[0])] = np.nan
        cue0[cue0 &gt; np.nanpercentile(cue0, pclip[1])] = np.nan
        return cue0

    with h5py.File(self._path_to_drivers, &#39;r&#39;) as hdf:
        soc = hdf[&#39;state/soil_organic_carbon&#39;][:,self._sites,:].mean(axis = 2)

    matplotlib.rcParams[&#39;text.usetex&#39;] = True
    matplotlib.rc(&#39;font&#39;, **{
        &#39;weight&#39; : &#39;bold&#39;,
        &#39;size&#39;   : 14
    })
    # Update plotting parameters
    kwargs.setdefault(&#39;alpha&#39;, 0.08)
    kwargs.setdefault(&#39;marker&#39;, &#39;.&#39;)
    init_params = self._configure(
        q_rh, q_k, None, (&#39;tsoil&#39;, &#39;smsf&#39;, &#39;par&#39;), model = &#39;reco_variable_cue&#39;)
    assert not np.isnan(init_params).any(),\
        &#39;Some required parameters are undefined; run calibration first&#39;
    with h5py.File(self._path_to_drivers, &#39;r&#39;) as hdf:
        porosity = hdf[&#39;state/porosity&#39;][self._sites]
    tsoil, smsf, par = self._drivers
    f_par = linear_constraint(*self.bplut[&#39;par&#39;][:,self._pft].tolist())
    # Generate (fixed) TSOIL and SMSF ramp functions
    f_tsoil = partial(arrhenius, beta0 = self.bplut[&#39;tsoil&#39;][0,self._pft])
    f_smsf  = linear_constraint(*self.bplut[&#39;smsf&#39;][:,self._pft].tolist())
    kmult = f_tsoil(tsoil) * f_smsf(smsf)
    rh = np.stack([
        kmult * soc[i,...] * self.bplut[&#39;decay_rates&#39;][i,self._pft]
        for i in range(0, 3)
    ], axis = 0)
    rh[1,...] = rh[1,...] * (1 - self.bplut[&#39;f_structural&#39;][0,self._pft])
    ra = self._reco_tower - rh.sum(axis = 0)
    ra = np.where(suppress_warnings(np.less)(ra, 0), np.nan, ra)
    kwargs.setdefault(&#39;alpha&#39;, 0.05)
    kwargs.setdefault(&#39;marker&#39;, &#39;.&#39;)
    pyplot.scatter(par, empirical_cue(ra, self._gpp_tower), **kwargs)
    pyplot.xlabel(&#39;Photosynthetically Active Radiation (PAR)&#39;)
    pyplot.ylabel(&#39;Empirical CUE (1 - $R_A$/GPP)&#39;)
    pyplot.title(&#39;PFT=%d&#39; % self._pft)
    domain = np.arange(np.nanmin(par), np.nanmax(par), 0.1)
    ramp = self._constrain(domain, &#39;par&#39;)
    pyplot.plot(domain, self.bplut[&#39;CUE&#39;][0,self._pft] * ramp, &#39;k-&#39;)
    pyplot.ylim(*ylim)
    pyplot.show()</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.calibration.extensions.phenology.PhenologyCalibrationCLI.tune_reco_o2_limit"><code class="name flex">
<span>def <span class="ident">tune_reco_o2_limit</span></span>(<span>self, q_rh=75, q_k=50, fixed=None, optimize=True, nlopt=True, trials=1, infer_diff_coefs=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Optimizes RECO for a model that includes an O2 diffusion limitation
with Michaelis-Menten kinetics. The 9-km mean L4C RECO is fit to the
tower-observed RECO using constrained, non-linear least-squares
optimization.</p>
<h2 id="considerations">Considerations</h2>
<p>1) Negative RH values (i.e., NPP &gt; RECO) are set to zero.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>q_rh</code></strong> :&ensp;<code>int</code></dt>
<dd>The percentile of RH/Kmult to use in calculating Cbar</dd>
<dt><strong><code>q_k</code></strong> :&ensp;<code>int</code></dt>
<dd>The percentile of Kmult below which RH/Kmult values are masked</dd>
<dt><strong><code>fixed</code></strong> :&ensp;<code>tuple</code> or <code>list</code></dt>
<dd>Zero or more parameters whose values should be fixed
(i.e, NOT optimized)</dd>
<dt><strong><code>optimize</code></strong> :&ensp;<code>bool</code></dt>
<dd>False to only report parameters and their fit statistics instead
of optimizing (Default: True)</dd>
<dt><strong><code>nlopt</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use the nlopt library for optimization (Default: True)</dd>
<dt><strong><code>trials</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of searches of the parameter space to perform; if &gt;1,
initial parameters are randomized for each trial</dd>
<dt><strong><code>infer_diff_coefs</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to infer the diffusion coefficients based on characteristic
soil moisture conditions (Default: True); if False, coefficients
will be fit to the tower respiration data</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any number of additional keyword arguments to
scipy.optimize.least_squares()</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tune_reco_o2_limit(
        self, q_rh = 75, q_k = 50, fixed = None, optimize = True,
        nlopt = True, trials = 1, infer_diff_coefs = True, **kwargs):
    &#39;&#39;&#39;
    Optimizes RECO for a model that includes an O2 diffusion limitation
    with Michaelis-Menten kinetics. The 9-km mean L4C RECO is fit to the
    tower-observed RECO using constrained, non-linear least-squares
    optimization.
    Considerations:
        1) Negative RH values (i.e., NPP &gt; RECO) are set to zero.

    Parameters
    ----------
    q_rh : int
        The percentile of RH/Kmult to use in calculating Cbar
    q_k : int
        The percentile of Kmult below which RH/Kmult values are masked
    fixed : tuple or list
        Zero or more parameters whose values should be fixed
        (i.e, NOT optimized)
    optimize : bool
        False to only report parameters and their fit statistics instead
        of optimizing (Default: True)
    nlopt : bool
        True to use the nlopt library for optimization (Default: True)
    trials : int
        Number of searches of the parameter space to perform; if &gt;1,
        initial parameters are randomized for each trial
    infer_diff_coefs : bool
        True to infer the diffusion coefficients based on characteristic
        soil moisture conditions (Default: True); if False, coefficients
        will be fit to the tower respiration data
    **kwargs
        Any number of additional keyword arguments to
        scipy.optimize.least_squares()
    &#39;&#39;&#39;
    def k_mult(params):
        # Calculate K_mult* based on current parameters
        #   *K_mult but including O2 diffusion limitation
        f_tsoil = partial(arrhenius, beta0 = params[1])
        f_smsf  = linear_constraint(params[2], params[3])
        tsoil, smsf, soil_vwc, porosity = self._drivers
        conc_O2 = concentration_O2(params, soil_vwc, porosity)
        mm_O2 = conc_O2 / (params[5] + conc_O2) # km_oxy param
        return f_tsoil(tsoil) * np.min(
            np.stack((f_smsf(smsf), mm_O2)), axis = 0)

    def concentration_O2(params, soil_vwc, porosity):
        air_frac_O2 = 0.2095 # Liters of O2 per liter of air (20.95%)
        d_gas = params[4]
        return d_gas * air_frac_O2 * np.power(porosity - soil_vwc, 4/3)

    @suppress_warnings
    def reco(params):
        # Calculate RH as (RECO - RA) or (RECO - (faut * GPP));
        ra = ((1 - params[0]) * self._gpp_tower)
        rh = self._reco_tower - ra
        rh = np.where(rh &lt; 0, 0, rh) # Mask out negative RH values
        # Compute Cbar with globals &#34;q_rh&#34; and &#34;q_k&#34;
        kmult0 = k_mult(params)
        cbar0 = cbar(rh, kmult0, q_rh, q_k)
        return ra + (kmult0 * cbar0)

    def residuals(params):
        # Objective function: Difference between tower RECO and L4C RECO
        reco0 = reco(params)
        diff = np.subtract(self._reco_tower, reco0)
        # Multiply by the tower weights
        return (self._site_weights * diff)[np.isfinite(diff)]

    self._model_name = &#39;reco_o2_limit&#39;
    if infer_diff_coefs and fixed is not None:
        raise ValueError(&#39;Cannot set both --infer-diff-coefs and --fixed&#39;)
    init_params = self._configure(
        q_rh, q_k, fixed, (&#39;tsoil&#39;, &#39;smsf&#39;), model = self._model_name)
    # Set defaults where needed
    if np.isnan(init_params).any():
        init_params[np.isnan(init_params)] = np.array(
            [0.4, 270, 10, 50, 3.78, 0.105])[np.isnan(init_params)]
    with h5py.File(self._path_to_drivers, &#39;r&#39;) as hdf:
        porosity = hdf[&#39;state/porosity&#39;][self._sites]
    # NOTE: Converting from &#34;wetness&#34; to volumetric water content (VWC)
    _, smsf = self._drivers
    soil_vwc = np.multiply(smsf / 100, porosity)
    self._drivers.extend((soil_vwc, porosity))

    # Optionally, instead of fitting d_gas and km_oxy, we can infer their
    #   values based on the soil moisture distribution
    if infer_diff_coefs:
        a = np.power(np.subtract(porosity, soil_vwc), 4/3)
        soil_vwc_ptiles = np.percentile(soil_vwc, (5, 50))
        # d_gas when soil is completely dry assuming soil [O2] = atm. [O2]
        d_gas = np.median(1 / a[soil_vwc &lt;= soil_vwc_ptiles[0]])
        km_oxy = np.median(
            d_gas * 0.2095 * np.power(porosity - soil_vwc_ptiles[1], 4/3))
        print(&#39;Inferred coefficients: d_gas = %.2f; km_oxy = %.3f&#39; % (d_gas, km_oxy))
        init_params[4] = d_gas
        init_params[5] = km_oxy
        fixed = [] if fixed is None else fixed
        fixed = set(fixed).union((&#39;d_gas&#39;, &#39;km_oxy&#39;))
    self._tune( # Step sizes specified here
        reco, residuals, init_params, fixed, (0.01, 1, 0.1, 0.1, 0.1, 0.002),
        trials, optimize, nlopt)</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.calibration.extensions.phenology.PhenologyCalibrationCLI.tune_variable_cue"><code class="name flex">
<span>def <span class="ident">tune_variable_cue</span></span>(<span>self, q_rh=75, q_k=50, fixed=None, optimize=True, nlopt=True, trials=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Optimizes RECO for a model that includes the Kok effect (CUE varies
linearly with PAR). The 9-km mean L4C RECO is fit to the
tower-observed RECO using constrained, non-linear least-squares
optimization.</p>
<h2 id="considerations">Considerations</h2>
<p>1) Negative RH values (i.e., NPP &gt; RECO) are set to zero.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>q_rh</code></strong> :&ensp;<code>int</code></dt>
<dd>The percentile of RH/Kmult to use in calculating Cbar</dd>
<dt><strong><code>q_k</code></strong> :&ensp;<code>int</code></dt>
<dd>The percentile of Kmult below which RH/Kmult values are masked</dd>
<dt><strong><code>fixed</code></strong> :&ensp;<code>tuple</code> or <code>list</code></dt>
<dd>Zero or more parameters whose values should be fixed
(i.e, NOT optimized)</dd>
<dt><strong><code>optimize</code></strong> :&ensp;<code>bool</code></dt>
<dd>False to only report parameters and their fit statistics instead
of optimizing (Default: True)</dd>
<dt><strong><code>nlopt</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use the nlopt library for optimization (Default: True)</dd>
<dt><strong><code>trials</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of searches of the parameter space to perform; if &gt;1,
initial parameters are randomized for each trial</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any number of additional keyword arguments to
scipy.optimize.least_squares()</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tune_variable_cue(
        self, q_rh = 75, q_k = 50, fixed = None, optimize = True,
        nlopt = True, trials = 1, **kwargs):
    &#39;&#39;&#39;
    Optimizes RECO for a model that includes the Kok effect (CUE varies
    linearly with PAR). The 9-km mean L4C RECO is fit to the
    tower-observed RECO using constrained, non-linear least-squares
    optimization.
    Considerations:
        1) Negative RH values (i.e., NPP &gt; RECO) are set to zero.

    Parameters
    ----------
    q_rh : int
        The percentile of RH/Kmult to use in calculating Cbar
    q_k : int
        The percentile of Kmult below which RH/Kmult values are masked
    fixed : tuple or list
        Zero or more parameters whose values should be fixed
        (i.e, NOT optimized)
    optimize : bool
        False to only report parameters and their fit statistics instead
        of optimizing (Default: True)
    nlopt : bool
        True to use the nlopt library for optimization (Default: True)
    trials : int
        Number of searches of the parameter space to perform; if &gt;1,
        initial parameters are randomized for each trial
    **kwargs
        Any number of additional keyword arguments to
        scipy.optimize.least_squares()
    &#39;&#39;&#39;
    def k_mult(params):
        # Calculate K_mult based on current parameters
        f_tsoil = partial(arrhenius, beta0 = params[1])
        f_smsf  = linear_constraint(params[2], params[3])
        tsoil, smsf, _ = self._drivers
        return f_tsoil(tsoil) * f_smsf(smsf)

    @suppress_warnings
    def reco(params):
        f_par = linear_constraint(params[-2], params[-1])
        _, _, par = self._drivers
        ra = ((1 - (f_par(par) * params[0])) * self._gpp_tower)
        # Calculate RH as (RECO - RA) or (RECO - (faut * GPP));
        rh = self._reco_tower - ra
        rh = np.where(rh &lt; 0, 0, rh) # Mask out negative RH values
        # Compute Cbar with globals &#34;q_rh&#34; and &#34;q_k&#34;
        kmult0 = k_mult(params)
        cbar0 = cbar(rh, kmult0, q_rh, q_k)
        return ra + (kmult0 * cbar0)

    def residuals(params):
        # Objective function: Difference between tower RECO and L4C RECO
        reco0 = reco(params)
        diff = np.subtract(self._reco_tower, reco0)
        # Multiply by the tower weights
        return (self._site_weights * diff)[np.isfinite(diff)]

    self._model_name = &#39;reco_variable_cue&#39;
    init_params = self._configure(
        q_rh, q_k, fixed, (&#39;tsoil&#39;, &#39;smsf&#39;, &#39;par&#39;), model = self._model_name)
    # Set defaults where needed
    if np.isnan(init_params).any():
        init_params[np.isnan(init_params)] = np.array(
            [0.4, 270, 10, 50, 1, 5])[np.isnan(init_params)]
    self._tune( # Step sizes specified here
        reco, residuals, init_params, fixed, (0.01, 1, 0.1, 0.1, 0.02, 0.02),
        trials, optimize, nlopt)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.calibration.main.CLI" href="../main.html#pyl4c.apps.calibration.main.CLI">CLI</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.calibration.main.CLI.filter" href="../main.html#pyl4c.apps.calibration.main.CLI.filter">filter</a></code></li>
<li><code><a title="pyl4c.apps.calibration.main.CLI.filter_all" href="../main.html#pyl4c.apps.calibration.main.CLI.filter_all">filter_all</a></code></li>
<li><code><a title="pyl4c.apps.calibration.main.CLI.filter_preview" href="../main.html#pyl4c.apps.calibration.main.CLI.filter_preview">filter_preview</a></code></li>
<li><code><a title="pyl4c.apps.calibration.main.CLI.pft" href="../main.html#pyl4c.apps.calibration.main.CLI.pft">pft</a></code></li>
<li><code><a title="pyl4c.apps.calibration.main.CLI.plot_gpp" href="../main.html#pyl4c.apps.calibration.main.CLI.plot_gpp">plot_gpp</a></code></li>
<li><code><a title="pyl4c.apps.calibration.main.CLI.plot_reco" href="../main.html#pyl4c.apps.calibration.main.CLI.plot_reco">plot_reco</a></code></li>
<li><code><a title="pyl4c.apps.calibration.main.CLI.reset" href="../main.html#pyl4c.apps.calibration.main.CLI.reset">reset</a></code></li>
<li><code><a title="pyl4c.apps.calibration.main.CLI.set" href="../main.html#pyl4c.apps.calibration.main.CLI.set">set</a></code></li>
<li><code><a title="pyl4c.apps.calibration.main.CLI.setup" href="../main.html#pyl4c.apps.calibration.main.CLI.setup">setup</a></code></li>
<li><code><a title="pyl4c.apps.calibration.main.CLI.tune_gpp" href="../main.html#pyl4c.apps.calibration.main.CLI.tune_gpp">tune_gpp</a></code></li>
<li><code><a title="pyl4c.apps.calibration.main.CLI.tune_reco" href="../main.html#pyl4c.apps.calibration.main.CLI.tune_reco">tune_reco</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyl4c.apps.calibration.extensions" href="index.html">pyl4c.apps.calibration.extensions</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyl4c.apps.calibration.extensions.phenology.PhenologyCalibrationCLI" href="#pyl4c.apps.calibration.extensions.phenology.PhenologyCalibrationCLI">PhenologyCalibrationCLI</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.calibration.extensions.phenology.PhenologyCalibrationCLI.plot_reco_o2_limit" href="#pyl4c.apps.calibration.extensions.phenology.PhenologyCalibrationCLI.plot_reco_o2_limit">plot_reco_o2_limit</a></code></li>
<li><code><a title="pyl4c.apps.calibration.extensions.phenology.PhenologyCalibrationCLI.plot_variable_cue" href="#pyl4c.apps.calibration.extensions.phenology.PhenologyCalibrationCLI.plot_variable_cue">plot_variable_cue</a></code></li>
<li><code><a title="pyl4c.apps.calibration.extensions.phenology.PhenologyCalibrationCLI.tune_reco_o2_limit" href="#pyl4c.apps.calibration.extensions.phenology.PhenologyCalibrationCLI.tune_reco_o2_limit">tune_reco_o2_limit</a></code></li>
<li><code><a title="pyl4c.apps.calibration.extensions.phenology.PhenologyCalibrationCLI.tune_variable_cue" href="#pyl4c.apps.calibration.extensions.phenology.PhenologyCalibrationCLI.tune_variable_cue">tune_variable_cue</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>