<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyl4c.apps.l4c.extensions.cosore API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyl4c.apps.l4c.extensions.cosore</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
&#39;&#39;&#39;

import pickle
import datetime
import numpy as np
import h5py
from pyl4c import suppress_warnings
from pyl4c.science import ordinals365
from pyl4c.stats import linear_constraint
from pyl4c.lib.cli import ProgressBar
from pyl4c.apps.l4c import L4CStratifiedState
from pyl4c.apps.l4c.io import L4CStreamingInputDataset
from pyl4c.apps.l4c.main import L4CForwardProcessPoint
from pyl4c.apps.l4c.extensions.hydrology import O2DiffusionLimitMixin, StratifiedRespirationMixin, StratifiedLitterfallMixin

class LitterfallMixin:
    &#39;&#39;&#39;
    Implements support for a litterfall phenology in the soil organic carbon
    (SOC) decomposition model as a mix-in. Should not be instantiated directly.
    &#39;&#39;&#39;
    def soc(self, rh, t):
        &#39;&#39;&#39;
        Calculate change in SOC for a single time step.

        Parameters
        ----------
        rh : numpy.ndarray
            (3 x N x M) array of RH at the current time step
        t : int
            Current time step

        Returns
        -------
        numpy.ndarray
        &#39;&#39;&#39;
        # Change in SOC according to diff. eq. in Jones et al. (2017)
        doy = self._doy[t] - 1 # Get DOY on [1,365] then on [0,364] for Python
        litter = self.constants.litterfall[doy,...]
        dc1 = (litter * self.constants.f_metabolic) - rh[0,...]
        dc2 = (litter * (1 - self.constants.f_metabolic)) - rh[1,...]
        dc3 = (self.constants.f_structural * rh[1,...]) - rh[2,...]
        return (dc1, dc2, dc3)


class L4CPrescribedGPPModel(L4CForwardProcessPoint):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    DRIVERS_INDEX = (&#39;tsoil&#39;, &#39;smsf&#39;)
    FLUX_INDEX = (&#39;rh&#39;, &#39;nee&#39;)
    DIAGNOSTICS_INDEX = (&#39;f_tsoil&#39;, &#39;f_smsf&#39;)
    REQUIRED_CONFIGURATION = (&#39;bplut&#39;, &#39;inputs_file_path&#39;, &#39;site_count&#39;, &#39;soc_data_path&#39;)

    def __init__(
            self, config, stream = True, use_legacy_pft = False,
            verbose = True, debug = False):
        super().__init__(
            config = config, stream = stream, use_legacy_pft = use_legacy_pft,
            verbose = verbose, debug = debug)

        if config[&#39;extra_parameters&#39;] is not None:
            with open(config[&#39;extra_parameters&#39;], &#39;rb&#39;) as file:
                data_dict = pickle.load(file)
            # Identify the extra parameters
            params = set(data_dict.keys()).difference(self._bplut.keys())
            # Set invalid PFT codes to PFT 0
            self._pft = np.where(self._pft &gt; max(self.PFT_CODES), 0, self._pft)
            # Vectorize the new parameters
            try:
                self._extra_params = dict([
                    (p, data_dict[p][0,self._pft]) for p in params
                ])
            except IndexError:
                # Some older parameter datasets have inconsistent dimensions
                self._extra_params = dict([
                    (p, data_dict[p][self._pft]) for p in params
                ])

    @suppress_warnings
    def _load_state(self, hdf, keys):
        &#39;&#39;&#39;
        Overrides original _load_state() so as to accept an alternate source
        of SOC data, without having to duplicate all the other data in the
        drivers HDF5.
        &#39;&#39;&#39;
        soc_path = self.config[&#39;soc_data_path&#39;]
        with open(soc_path, &#39;rb&#39;) as file:
            _, soil_organic_carbon = pickle.load(file)
        shp = (1, self.config[&#39;time_steps&#39;], self.config[&#39;site_count&#39;], 81)
        init_state = []
        new_state = []
        for p, key in enumerate(keys):
            # Create an empty state array, allocated T time steps
            new_state.append(np.full(shp, np.nan))
            if key.startswith(&#39;soc&#39;):
                arr = soil_organic_carbon[p,...]
                # Filter out any NoData, which (should) only correspond to
                #   1-km subgrid pixels that are outside the PFT range [1, 8]
                init_state.append(
                    np.where(arr &lt; 0, np.nan, arr).reshape((1, 1, *shp[2:])))
            else:
                init_state.append(np.full((1, 1, *shp[2:]), np.nan))
        return (init_state, new_state)

    def _setup(self, config, hdf):
        &#39;Load point site PFTs, state data, driver data&#39;
        # Get the starting time index, if specified
        if &#39;start&#39; in config.keys():
            if config[&#39;start&#39;] is not None:
                try:
                    ts0 = datetime.datetime.strptime(
                        config[&#39;start&#39;], &#39;%Y-%m-%dT%H:%M:%S&#39;)
                except ValueError:
                    ts0 = datetime.datetime.strptime(
                        config[&#39;start&#39;], &#39;%Y-%m-%d&#39;)
                self._t0 = np.argwhere(
                    np.logical_and(np.logical_and(
                        hdf[&#39;time&#39;][:,0] == ts0.year,
                        hdf[&#39;time&#39;][:,1] == ts0.month),
                        hdf[&#39;time&#39;][:,2] == ts0.day)
                    ).flatten().tolist().pop()
        if &#39;end&#39; in config.keys():
            if config[&#39;end&#39;] is not None:
                try:
                    ts1 = datetime.datetime.strptime(
                        config[&#39;end&#39;], &#39;%Y-%m-%dT%H:%M:%S&#39;)
                except ValueError:
                    ts1 = datetime.datetime.strptime(
                        config[&#39;end&#39;], &#39;%Y-%m-%d&#39;)
                self._t1 = np.argwhere(
                    np.logical_and(np.logical_and(
                        hdf[&#39;time&#39;][:,0] == ts1.year,
                        hdf[&#39;time&#39;][:,1] == ts1.month),
                        hdf[&#39;time&#39;][:,2] == ts1.day)
                    ).flatten().tolist().pop()

        # And check that the correct number of steps were specified
        assert config[&#39;time_steps&#39;] == (hdf[&#39;time&#39;].shape[0] - self._t0)\
            or config[&#39;time_steps&#39;] == (self._t1 - self._t0),\
            &#39;Parameter &#34;time_steps&#34; does not match the number of time steps suggested by &#34;start&#34; parameter and the &#34;time&#34; field&#39;

        self._print(&#39;Accessing state and drivers data...&#39;)
        if self._use_legacy_pft:
            self._pft = hdf[&#39;legacy/lc_dom&#39;][:].swapaxes(0, 1)
        else:
            self._pft = hdf[&#39;state/PFT&#39;][:]

        # Initialize containers for various datasets
        self._setup_data_storage(config, hdf)

        # SET STATE
        self._print(&#39;Loading state...&#39;)
        keys = list(self.STATE_INDEX)
        if self._debug:
            keys.extend(self.DIAGNOSTICS_INDEX)
        init_state, new_state = self._load_state(hdf, keys)
        if len(init_state) &gt; 0:
            self.state_initial = np.concatenate(init_state, axis = 0)
        if len(new_state) &gt; 0:
            self.state = np.concatenate(new_state, axis = 0)
        self.state.labels = keys

        # LOAD CONSTANTS
        self._print(&#39;Loading constants...&#39;)
        self._load_constants()

        # INITIALIZE CONSTRAINT FUNCTIONS
        self._print(&#39;Creating linear constraint functions...&#39;)
        self._load_constraints(
            self._pft, filter(lambda x: x not in (&#39;apar&#39;,), self.DRIVERS_INDEX))

    def run(self, gpp, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        gpp : numpy.ndarray
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: `None`)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, gpp, fields_rh):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve intial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            rh, k_mult = self.rh(
                state, zip(hdf.index(t + self._t0, *fields_rh), fields_rh))
            npp = gpp * self.constants.CUE
            d_soc = self.soc(rh, t + self._t0)
            # Record fluxes for this time step
            self.fluxes.update(&#39;rh&#39;, t, rh.sum(axis = 0))
            self.fluxes.update(&#39;nee&#39;, t, rh.sum(axis = 0) - npp)
            # Record diagnostics at this time step
            if self._debug:
                # In debug mode, k_mult is not a single quantity but multiple;
                #   the order of k_mult_fields MUST match the order of the
                #   return signature for rh()
                k_mult_fields = (&#39;f_tsoil&#39;, &#39;f_smsf&#39;)
                if all(f in self.DIAGNOSTICS_INDEX for f in k_mult_fields):
                    for k, key in enumerate(self.DIAGNOSTICS_INDEX):
                        if key in k_mult_fields:
                            idx = k_mult_fields.index(key)
                            self.state.update(key, t, k_mult[idx])

            # Treat Kmult and Emult differently (i.e., break out the former
            #   but not the latter) because that is what L4C Ops does
            if &#39;t_mult&#39; in self.STATE_INDEX:
                self.state.update(&#39;t_mult&#39;, t, k_mult[0])
            if &#39;w_mult&#39; in self.STATE_INDEX:
                self.state.update(&#39;w_mult&#39;, t, k_mult[1])
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

        # Fill in out-of-bounds SMSF with 100% wetness
        fill = {&#39;tsoil&#39;: (np.nan, np.nan), &#39;smsf&#39;: (0, 100)}
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS, fill) as hdf:
            fields_rh = [&#39;tsoil&#39;, &#39;smsf&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(t, gpp[t,...], fields_rh)
                    self._time_idx += 1
                    progress.update(t)


class L4CPrescribedGPPModelWithKokEffect(L4CPrescribedGPPModel):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data. Also includes modeling of
    the Kok effect; see `pyl4c.apps.l4c.extensions.phenology.L4CWithKokEffect`.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    DRIVERS_INDEX = (&#39;tsoil&#39;, &#39;smsf&#39;, &#39;par&#39;)

    def run(self, gpp, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        gpp : numpy.ndarray
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: `None`)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, gpp, fields_rh):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve intial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            rh, k_mult = self.rh(
                state, zip(hdf.index(t + self._t0, *fields_rh), fields_rh))
            # NOTE: Different in this model:
            #   CUE is constrained by PAR
            par = hdf.index(t + self._t0, &#39;par&#39;)
            cue = self.constrain(par[0], &#39;par&#39;) * self.constants.CUE
            npp = gpp * cue
            d_soc = self.soc(rh, t + self._t0)
            # Record fluxes for this time step
            self.fluxes.update(&#39;rh&#39;, t, rh.sum(axis = 0))
            self.fluxes.update(&#39;nee&#39;, t, rh.sum(axis = 0) - npp)
            # Record diagnostics at this time step
            if self._debug:
                # In debug mode, k_mult is not a single quantity but multiple;
                #   the order of k_mult_fields MUST match the order of the
                #   return signature for rh()
                k_mult_fields = (&#39;f_tsoil&#39;, &#39;f_smsf&#39;)
                if all(f in self.DIAGNOSTICS_INDEX for f in k_mult_fields):
                    for k, key in enumerate(self.DIAGNOSTICS_INDEX):
                        if key in k_mult_fields:
                            idx = k_mult_fields.index(key)
                            self.state.update(key, t, k_mult[idx])

            # Treat Kmult and Emult differently (i.e., break out the former
            #   but not the latter) because that is what L4C Ops does
            if &#39;t_mult&#39; in self.STATE_INDEX:
                self.state.update(&#39;t_mult&#39;, t, k_mult[0])
            if &#39;w_mult&#39; in self.STATE_INDEX:
                self.state.update(&#39;w_mult&#39;, t, k_mult[1])
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

        # Fill in out-of-bounds SMSF with 100% wetness
        fill = {&#39;tsoil&#39;: (np.nan, np.nan), &#39;smsf&#39;: (0, 100)}
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS, fill) as hdf:
            fields_rh = [&#39;tsoil&#39;, &#39;smsf&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(t, gpp[t,...], fields_rh)
                    self._time_idx += 1
                    progress.update(t)


class L4CPrescribedGPPModelWithO2Limit(
        L4CPrescribedGPPModel, O2DiffusionLimitMixin):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data. Also includes modeling of
    an O2 diffusion limit on heterotrophic respiration; see
    `pyl4c.apps.l4c.extensions.phenology.L4CWithO2Diffusion`.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    DRIVERS_INDEX = (&#39;tsoil&#39;, &#39;smsf&#39;)
    DIAGNOSTICS_INDEX = (&#39;f_tsoil&#39;, &#39;f_smsf&#39;, &#39;conc_O2&#39;, &#39;mm_O2&#39;)
    AIR_FRAC_O2 = 0.2095 # Liters of O2 per liter of air (20.95%)

    def __init__(
            self, config, stream = True, verbose = True, debug = False):
        super().__init__(
            config = config, stream = stream, verbose = verbose, debug = debug)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            # Read in porosity, copy to 1-km subgrid
            self._porosity = hdf[&#39;state/porosity&#39;][:][:,np.newaxis]\
                .repeat(81, axis = 1)

    def run(self, gpp, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        gpp : numpy.ndarray
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: `None`)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, gpp, fields_rh):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve intial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            rh, k_mult = self.rh(
                state, zip(hdf.index(t + self._t0, *fields_rh), fields_rh))
            npp = gpp * self.constants.CUE
            d_soc = self.soc(rh, t + self._t0)
            # Record fluxes for this time step
            self.fluxes.update(&#39;rh&#39;, t, rh.sum(axis = 0))
            self.fluxes.update(&#39;nee&#39;, t, rh.sum(axis = 0) - npp)
            # Record diagnostics at this time step
            if self._debug:
                # In debug mode, k_mult is not a single quantity but multiple;
                #   the order of k_mult_fields MUST match the order of the
                #   return signature for rh()
                k_mult_fields = (&#39;f_tsoil&#39;, &#39;f_smsf&#39;, &#39;conc_O2&#39;, &#39;mm_O2&#39;)
                if all(f in self.DIAGNOSTICS_INDEX for f in k_mult_fields):
                    for k, key in enumerate(self.DIAGNOSTICS_INDEX):
                        if key in k_mult_fields:
                            idx = k_mult_fields.index(key)
                            self.state.update(key, t, k_mult[idx])

            # Treat Kmult and Emult differently (i.e., break out the former
            #   but not the latter) because that is what L4C Ops does
            if &#39;t_mult&#39; in self.STATE_INDEX:
                self.state.update(&#39;t_mult&#39;, t, k_mult[0])
            if &#39;w_mult&#39; in self.STATE_INDEX:
                self.state.update(&#39;w_mult&#39;, t, k_mult[1])
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

        # Fill in out-of-bounds SMSF with 100% wetness
        fill = {&#39;tsoil&#39;: (np.nan, np.nan), &#39;smsf&#39;: (0, 100)}
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS, fill) as hdf:
            fields_rh = [&#39;tsoil&#39;, &#39;smsf&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(t, gpp[t,...], fields_rh)
                    self._time_idx += 1
                    progress.update(t)


class L4CPrescribedGPPModelWithLitterfallPhenology(
        LitterfallMixin, L4CPrescribedGPPModel):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data. Also includes modeling of
    the CASA litterfall phenology scheme; see
    `pyl4c.apps.l4c.extensions.phenology.L4CWithLitterfallPhenology`.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    def __init__(
            self, config, stream = True, verbose = True, debug = False):
        super().__init__(
            config = config, stream = stream, verbose = verbose, debug = debug)
        # It is necessary to have a way to look up the day of year for
        #   indexing the litterfall array, which is (365 x N x 81)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            dt = [datetime.date(*t) for t in hdf[&#39;time&#39;][:].tolist()]
            self._doy = ordinals365(dt)
        # Set the daily litterfall
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        # Overwrite the daily litterfall that was set in the parent model
        self.constants.add(litterfall, &#39;litterfall&#39;)


class L4CPrescribedGPPModelWithSoilProfile(
        StratifiedRespirationMixin, StratifiedLitterfallMixin,
        L4CPrescribedGPPModel):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data. Also includes modeling of
    the vertical soil profile.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    sm_profiles : str
        File path to HDF5 file containing soil moisture profiles
    litterfall_schedule : bool
        True if litterfall is a function of day-of-year (DOY); False if
        litterfall is a pre-computed fraction of daily NPP (Default: False)
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    CONSTANTS_INDEX = (
        &#39;CUE&#39;, &#39;LUE&#39;, &#39;f_metabolic&#39;, &#39;f_structural&#39;, &#39;decay_rates&#39;,
        &#39;k_depth_decay&#39;)
    # All DEPTHS must be positive
    DEPTHS = np.array((0.05, 0.15, 0.35, 0.75, 1.5, 3.0))\
        .reshape((6,1)) # meters
    # Get change in depth (layer thickness)
    DELTA_Z = (DEPTHS - np.vstack((0, DEPTHS[:-1])))\
        .reshape((DEPTHS.size, 1, 1))
    DIFFUSIVITY = 2e-4 # m2 yr-1 (Yi et al. 2020)

    def __init__(
            self, config, sm_profiles, litterfall_schedule = False,
            stream = True, verbose = True, debug = False):
        super().__init__(
            config = config, stream = stream, verbose = verbose, debug = debug)
        self._multilayer = True # Multiple soil layers
        self._scheduled = litterfall_schedule
        # After Yi et al. (2020), diffusivity declines linearly with depth to
        #   3 meters; also convert to units of m2 day-1
        self.diffusivity = (self.DIFFUSIVITY / 365) *\
            linear_constraint(0, 3, form = &#39;reversed&#39;)(np.abs(self.DEPTHS))
        self.profiles_file_path = sm_profiles
        # Initialize the vertically discretized state
        self.state_by_depth = np.full((
            1 + len(self.DIAGNOSTICS_INDEX), config[&#39;time_steps&#39;],
            self.DEPTHS.size, config[&#39;site_count&#39;], 81
        ), np.nan, dtype = np.float32)

    @property
    def state_by_depth(self):
        return self._state_by_depth

    @state_by_depth.setter
    def state_by_depth(self, new):
        self._state_by_depth.data = new

    def run(self, gpp, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        gpp : numpy.ndarray
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: `None`)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, gpp, fields_rh, soil_t, soil_m, litterfall):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve intial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            rh, k_mult = self.rh(state, (soil_t, soil_m))
            npp = gpp * self.constants.CUE
            # NOTE: Litterfall inputs may not scheduled
            d_soc = self.soc(
                state, rh, litterfall, t + self._t0,
                scheduled = self._scheduled)
            # Update RH in each soil layer, convert from g C m-3 to g C m-2
            rh = np.nansum(rh, axis = 0) * self.DELTA_Z
            self.state_by_depth.update(&#39;rh&#39;, t, rh)
            # Update NEE, taking sum of RH across all soil layers
            self.fluxes.update(&#39;nee&#39;, t, np.nansum(rh, axis = 0) - npp)
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

        # Load supplemental datasets
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            porosity = hdf[&#39;state/porosity&#39;][:]
            # Calculate extent of soil layers, given bedrock depth
            bedrock = hdf[&#39;LAND_MODEL_CONSTANTS/depth_to_bedrock_m&#39;][:]
            layer_mask = self.DEPTHS &lt; bedrock
            # &#34;surface_temp&#34; is used for the surface layer (0-5 cm)
            soil_t = []
            soil_t.append(hdf[&#39;L4SM_DAILY_MEAN/surface_temp&#39;][self._t0:,:])
            for i in range(1, self.DEPTHS.size):
                soil_t.append(
                    hdf[&#39;L4SM_DAILY_MEAN/soil_temp_layer%d&#39; % i][self._t0:,:])
            soil_t = np.stack(soil_t)
            # Mask out measurements below bedrock depth
            soil_t.swapaxes(1, 2)[~layer_mask,...] = np.nan
        with h5py.File(self.profiles_file_path, &#39;r&#39;) as hdf:
            soil_m = 100 * np.divide(
                hdf[&#39;soil_moisture_vwc&#39;][:,self._t0:,:], porosity)
            # Clip f(SM) response, as wetness values might be unrealistic
            #   given problems in ice-filled soil layers
            soil_m[soil_m &gt; 100] = 100
            # Mask out measurements below bedrock depth
            soil_m.swapaxes(1, 2)[~layer_mask,...] = np.nan
        porosity = None
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS) as hdf:
            fields_rh = [&#39;tsoil&#39;, &#39;smsf&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(t, gpp[t,...], fields_rh, soil_t[:,t,:,None],
                        soil_m[:,t,:,None], litterfall)
                    self._time_idx += 1
                    progress.update(t)


class L4CPrescribedGPPModelWithSoilProfileAndO2Limit(
        O2DiffusionLimitMixin, L4CPrescribedGPPModelWithSoilProfile):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data. Also includes modeling of
    the vertical soil profile AND an O2 diffusion limit.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    sm_profiles : str
        File path to HDF5 file containing soil moisture profiles
    litterfall_schedule : bool
        True if litterfall is a function of day-of-year (DOY); False if
        litterfall is a pre-computed fraction of daily NPP (Default: False)
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    DIAGNOSTICS_INDEX = (&#39;f_tsoil&#39;, &#39;f_smsf&#39;, &#39;conc_O2&#39;, &#39;mm_O2&#39;)
    AIR_FRAC_O2 = 0.2095 # Liters of O2 per liter of air (20.95%)

    def __init__(
            self, config, sm_profiles, litterfall_schedule = False,
            stream = True, verbose = True, debug = False):
        super().__init__(
            config = config, sm_profiles = sm_profiles,
            litterfall_schedule = litterfall_schedule, stream = stream,
            verbose = verbose, debug = debug)
        # Read in porosity, copy to 1-km subgrid
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            self._porosity = hdf[&#39;state/porosity&#39;][:][:,np.newaxis]\
                .repeat(81, axis = 1)


class L4CPrescribedGPPModelWithSoilProfileAndLitterfall(
        L4CPrescribedGPPModelWithSoilProfile):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data. Also includes modeling of
    the vertical soil profile AND a litterfall phenology

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    sm_profiles : str
        File path to HDF5 file containing soil moisture profiles
    litterfall_schedule : bool
        NOTE: Cannot be changed, defaults to True; see
        `pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile`
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    def __init__(
            self, config, sm_profiles, litterfall_schedule = True,
            stream = True, verbose = True, debug = False):
        super().__init__(
            config = config, sm_profiles = sm_profiles,
            litterfall_schedule = True, stream = stream,
            verbose = verbose, debug = debug)
        # It is necessary to have a way to look up the day of year for
        #   indexing the litterfall array, which is (365 x N x 81)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            dt = [datetime.date(*t[:]) for t in hdf[&#39;time&#39;][:].tolist()]
            self._doy = ordinals365(dt)
        # Set the daily litterfall
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        # Overwrite the daily litterfall that was set in the parent model
        self.constants.add(litterfall, &#39;litterfall&#39;)


class L4CPrescribedGPPModelWithO2LimitAndLitterfallPhenology(
        LitterfallMixin, L4CPrescribedGPPModelWithO2Limit):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data. Also includes modeling of
    the CASA litterfall phenology scheme; see
    `pyl4c.apps.l4c.extensions.phenology.L4CWithLitterfallPhenology`.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    def __init__(
            self, config, stream = True, verbose = True, debug = False):
        super().__init__(
            config = config, stream = stream, verbose = verbose, debug = debug)
        # It is necessary to have a way to look up the day of year for
        #   indexing the litterfall array, which is (365 x N x 81)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            dt = [datetime.date(*t) for t in hdf[&#39;time&#39;][:].tolist()]
            self._doy = ordinals365(dt)
        # Set the daily litterfall
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        # Overwrite the daily litterfall that was set in the parent model
        self.constants.add(litterfall, &#39;litterfall&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel"><code class="flex name class">
<span>class <span class="ident">L4CPrescribedGPPModel</span></span>
<span>(</span><span>config, stream=True, use_legacy_pft=False, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Variation on L4CForwardProcessPoint where GPP is not calculated but is
prescribed by the user. This can be used for developing or testing SOC
and respiration sub-models with fixed GPP data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of configuration parameters</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use L4CStreamingInputDataset instead of reading in all driver
data; this reduces memory use but increases I/O</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to print all output to stdout</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to store additional diagnostic information from each time step</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CPrescribedGPPModel(L4CForwardProcessPoint):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    DRIVERS_INDEX = (&#39;tsoil&#39;, &#39;smsf&#39;)
    FLUX_INDEX = (&#39;rh&#39;, &#39;nee&#39;)
    DIAGNOSTICS_INDEX = (&#39;f_tsoil&#39;, &#39;f_smsf&#39;)
    REQUIRED_CONFIGURATION = (&#39;bplut&#39;, &#39;inputs_file_path&#39;, &#39;site_count&#39;, &#39;soc_data_path&#39;)

    def __init__(
            self, config, stream = True, use_legacy_pft = False,
            verbose = True, debug = False):
        super().__init__(
            config = config, stream = stream, use_legacy_pft = use_legacy_pft,
            verbose = verbose, debug = debug)

        if config[&#39;extra_parameters&#39;] is not None:
            with open(config[&#39;extra_parameters&#39;], &#39;rb&#39;) as file:
                data_dict = pickle.load(file)
            # Identify the extra parameters
            params = set(data_dict.keys()).difference(self._bplut.keys())
            # Set invalid PFT codes to PFT 0
            self._pft = np.where(self._pft &gt; max(self.PFT_CODES), 0, self._pft)
            # Vectorize the new parameters
            try:
                self._extra_params = dict([
                    (p, data_dict[p][0,self._pft]) for p in params
                ])
            except IndexError:
                # Some older parameter datasets have inconsistent dimensions
                self._extra_params = dict([
                    (p, data_dict[p][self._pft]) for p in params
                ])

    @suppress_warnings
    def _load_state(self, hdf, keys):
        &#39;&#39;&#39;
        Overrides original _load_state() so as to accept an alternate source
        of SOC data, without having to duplicate all the other data in the
        drivers HDF5.
        &#39;&#39;&#39;
        soc_path = self.config[&#39;soc_data_path&#39;]
        with open(soc_path, &#39;rb&#39;) as file:
            _, soil_organic_carbon = pickle.load(file)
        shp = (1, self.config[&#39;time_steps&#39;], self.config[&#39;site_count&#39;], 81)
        init_state = []
        new_state = []
        for p, key in enumerate(keys):
            # Create an empty state array, allocated T time steps
            new_state.append(np.full(shp, np.nan))
            if key.startswith(&#39;soc&#39;):
                arr = soil_organic_carbon[p,...]
                # Filter out any NoData, which (should) only correspond to
                #   1-km subgrid pixels that are outside the PFT range [1, 8]
                init_state.append(
                    np.where(arr &lt; 0, np.nan, arr).reshape((1, 1, *shp[2:])))
            else:
                init_state.append(np.full((1, 1, *shp[2:]), np.nan))
        return (init_state, new_state)

    def _setup(self, config, hdf):
        &#39;Load point site PFTs, state data, driver data&#39;
        # Get the starting time index, if specified
        if &#39;start&#39; in config.keys():
            if config[&#39;start&#39;] is not None:
                try:
                    ts0 = datetime.datetime.strptime(
                        config[&#39;start&#39;], &#39;%Y-%m-%dT%H:%M:%S&#39;)
                except ValueError:
                    ts0 = datetime.datetime.strptime(
                        config[&#39;start&#39;], &#39;%Y-%m-%d&#39;)
                self._t0 = np.argwhere(
                    np.logical_and(np.logical_and(
                        hdf[&#39;time&#39;][:,0] == ts0.year,
                        hdf[&#39;time&#39;][:,1] == ts0.month),
                        hdf[&#39;time&#39;][:,2] == ts0.day)
                    ).flatten().tolist().pop()
        if &#39;end&#39; in config.keys():
            if config[&#39;end&#39;] is not None:
                try:
                    ts1 = datetime.datetime.strptime(
                        config[&#39;end&#39;], &#39;%Y-%m-%dT%H:%M:%S&#39;)
                except ValueError:
                    ts1 = datetime.datetime.strptime(
                        config[&#39;end&#39;], &#39;%Y-%m-%d&#39;)
                self._t1 = np.argwhere(
                    np.logical_and(np.logical_and(
                        hdf[&#39;time&#39;][:,0] == ts1.year,
                        hdf[&#39;time&#39;][:,1] == ts1.month),
                        hdf[&#39;time&#39;][:,2] == ts1.day)
                    ).flatten().tolist().pop()

        # And check that the correct number of steps were specified
        assert config[&#39;time_steps&#39;] == (hdf[&#39;time&#39;].shape[0] - self._t0)\
            or config[&#39;time_steps&#39;] == (self._t1 - self._t0),\
            &#39;Parameter &#34;time_steps&#34; does not match the number of time steps suggested by &#34;start&#34; parameter and the &#34;time&#34; field&#39;

        self._print(&#39;Accessing state and drivers data...&#39;)
        if self._use_legacy_pft:
            self._pft = hdf[&#39;legacy/lc_dom&#39;][:].swapaxes(0, 1)
        else:
            self._pft = hdf[&#39;state/PFT&#39;][:]

        # Initialize containers for various datasets
        self._setup_data_storage(config, hdf)

        # SET STATE
        self._print(&#39;Loading state...&#39;)
        keys = list(self.STATE_INDEX)
        if self._debug:
            keys.extend(self.DIAGNOSTICS_INDEX)
        init_state, new_state = self._load_state(hdf, keys)
        if len(init_state) &gt; 0:
            self.state_initial = np.concatenate(init_state, axis = 0)
        if len(new_state) &gt; 0:
            self.state = np.concatenate(new_state, axis = 0)
        self.state.labels = keys

        # LOAD CONSTANTS
        self._print(&#39;Loading constants...&#39;)
        self._load_constants()

        # INITIALIZE CONSTRAINT FUNCTIONS
        self._print(&#39;Creating linear constraint functions...&#39;)
        self._load_constraints(
            self._pft, filter(lambda x: x not in (&#39;apar&#39;,), self.DRIVERS_INDEX))

    def run(self, gpp, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        gpp : numpy.ndarray
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: `None`)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, gpp, fields_rh):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve intial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            rh, k_mult = self.rh(
                state, zip(hdf.index(t + self._t0, *fields_rh), fields_rh))
            npp = gpp * self.constants.CUE
            d_soc = self.soc(rh, t + self._t0)
            # Record fluxes for this time step
            self.fluxes.update(&#39;rh&#39;, t, rh.sum(axis = 0))
            self.fluxes.update(&#39;nee&#39;, t, rh.sum(axis = 0) - npp)
            # Record diagnostics at this time step
            if self._debug:
                # In debug mode, k_mult is not a single quantity but multiple;
                #   the order of k_mult_fields MUST match the order of the
                #   return signature for rh()
                k_mult_fields = (&#39;f_tsoil&#39;, &#39;f_smsf&#39;)
                if all(f in self.DIAGNOSTICS_INDEX for f in k_mult_fields):
                    for k, key in enumerate(self.DIAGNOSTICS_INDEX):
                        if key in k_mult_fields:
                            idx = k_mult_fields.index(key)
                            self.state.update(key, t, k_mult[idx])

            # Treat Kmult and Emult differently (i.e., break out the former
            #   but not the latter) because that is what L4C Ops does
            if &#39;t_mult&#39; in self.STATE_INDEX:
                self.state.update(&#39;t_mult&#39;, t, k_mult[0])
            if &#39;w_mult&#39; in self.STATE_INDEX:
                self.state.update(&#39;w_mult&#39;, t, k_mult[1])
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

        # Fill in out-of-bounds SMSF with 100% wetness
        fill = {&#39;tsoil&#39;: (np.nan, np.nan), &#39;smsf&#39;: (0, 100)}
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS, fill) as hdf:
            fields_rh = [&#39;tsoil&#39;, &#39;smsf&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(t, gpp[t,...], fields_rh)
                    self._time_idx += 1
                    progress.update(t)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithKokEffect" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithKokEffect">L4CPrescribedGPPModelWithKokEffect</a></li>
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithLitterfallPhenology" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithLitterfallPhenology">L4CPrescribedGPPModelWithLitterfallPhenology</a></li>
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit">L4CPrescribedGPPModelWithO2Limit</a></li>
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile">L4CPrescribedGPPModelWithSoilProfile</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.DIAGNOSTICS_INDEX"><code class="name">var <span class="ident">DIAGNOSTICS_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.DRIVERS_INDEX"><code class="name">var <span class="ident">DRIVERS_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.FLUX_INDEX"><code class="name">var <span class="ident">FLUX_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.REQUIRED_CONFIGURATION"><code class="name">var <span class="ident">REQUIRED_CONFIGURATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, gpp, steps=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A forward run in serial over multiple time steps; currently works in
streaming mode ONLY.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gpp</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>steps</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of time steps to run or None to run through the end of the
available time steps (exhaust driver data) (Default: <code>None</code>)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, gpp, steps = None):
    &#39;&#39;&#39;
    A forward run in serial over multiple time steps; currently works in
    streaming mode ONLY.

    Parameters
    ----------
    gpp : numpy.ndarray
    steps : int
        Number of time steps to run or None to run through the end of the
        available time steps (exhaust driver data) (Default: `None`)
    &#39;&#39;&#39;
    @suppress_warnings
    def step(t, gpp, fields_rh):
        &#39;Calculate fluxes, new states for the next time step t&#39;
        if t == 0:
            # Retrieve intial SOC pool sizes
            state = self.state_initial[0:3,0,...]
        else:
            # Retrieve SOC in each pool from prior step
            state = self.state.data[0:3,t-1,...]
        # Calculate fluxes, new states
        rh, k_mult = self.rh(
            state, zip(hdf.index(t + self._t0, *fields_rh), fields_rh))
        npp = gpp * self.constants.CUE
        d_soc = self.soc(rh, t + self._t0)
        # Record fluxes for this time step
        self.fluxes.update(&#39;rh&#39;, t, rh.sum(axis = 0))
        self.fluxes.update(&#39;nee&#39;, t, rh.sum(axis = 0) - npp)
        # Record diagnostics at this time step
        if self._debug:
            # In debug mode, k_mult is not a single quantity but multiple;
            #   the order of k_mult_fields MUST match the order of the
            #   return signature for rh()
            k_mult_fields = (&#39;f_tsoil&#39;, &#39;f_smsf&#39;)
            if all(f in self.DIAGNOSTICS_INDEX for f in k_mult_fields):
                for k, key in enumerate(self.DIAGNOSTICS_INDEX):
                    if key in k_mult_fields:
                        idx = k_mult_fields.index(key)
                        self.state.update(key, t, k_mult[idx])

        # Treat Kmult and Emult differently (i.e., break out the former
        #   but not the latter) because that is what L4C Ops does
        if &#39;t_mult&#39; in self.STATE_INDEX:
            self.state.update(&#39;t_mult&#39;, t, k_mult[0])
        if &#39;w_mult&#39; in self.STATE_INDEX:
            self.state.update(&#39;w_mult&#39;, t, k_mult[1])
        # Update the SOC state
        for p in range(1, 4):
            if t == 0:
                # At time t=0, we have no state to advance, so update
                #   the state at t=0 based on the initial state
                delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                self.state.update(
                    &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
            else:
                self.state.advance(
                    &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

    # Fill in out-of-bounds SMSF with 100% wetness
    fill = {&#39;tsoil&#39;: (np.nan, np.nan), &#39;smsf&#39;: (0, 100)}
    with L4CStreamingInputDataset(
            self.file_path, self.CONSTANTS, self.BOUNDS, fill) as hdf:
        fields_rh = [&#39;tsoil&#39;, &#39;smsf&#39;]
        num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
        with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
            for t in range(self._time_idx + 1, num_steps):
                step(t, gpp[t,...], fields_rh)
                self._time_idx += 1
                progress.update(t)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain">constrain</a></code></li>
<li><code><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp">gpp</a></code></li>
<li><code><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint.rh" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.rh">rh</a></code></li>
<li><code><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint.soc" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.soc">soc</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithKokEffect"><code class="flex name class">
<span>class <span class="ident">L4CPrescribedGPPModelWithKokEffect</span></span>
<span>(</span><span>config, stream=True, use_legacy_pft=False, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Variation on L4CForwardProcessPoint where GPP is not calculated but is
prescribed by the user. This can be used for developing or testing SOC
and respiration sub-models with fixed GPP data. Also includes modeling of
the Kok effect; see <code><a title="pyl4c.apps.l4c.extensions.phenology.L4CWithKokEffect" href="phenology.html#pyl4c.apps.l4c.extensions.phenology.L4CWithKokEffect">L4CWithKokEffect</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of configuration parameters</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use L4CStreamingInputDataset instead of reading in all driver
data; this reduces memory use but increases I/O</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to print all output to stdout</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to store additional diagnostic information from each time step</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CPrescribedGPPModelWithKokEffect(L4CPrescribedGPPModel):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data. Also includes modeling of
    the Kok effect; see `pyl4c.apps.l4c.extensions.phenology.L4CWithKokEffect`.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    DRIVERS_INDEX = (&#39;tsoil&#39;, &#39;smsf&#39;, &#39;par&#39;)

    def run(self, gpp, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        gpp : numpy.ndarray
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: `None`)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, gpp, fields_rh):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve intial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            rh, k_mult = self.rh(
                state, zip(hdf.index(t + self._t0, *fields_rh), fields_rh))
            # NOTE: Different in this model:
            #   CUE is constrained by PAR
            par = hdf.index(t + self._t0, &#39;par&#39;)
            cue = self.constrain(par[0], &#39;par&#39;) * self.constants.CUE
            npp = gpp * cue
            d_soc = self.soc(rh, t + self._t0)
            # Record fluxes for this time step
            self.fluxes.update(&#39;rh&#39;, t, rh.sum(axis = 0))
            self.fluxes.update(&#39;nee&#39;, t, rh.sum(axis = 0) - npp)
            # Record diagnostics at this time step
            if self._debug:
                # In debug mode, k_mult is not a single quantity but multiple;
                #   the order of k_mult_fields MUST match the order of the
                #   return signature for rh()
                k_mult_fields = (&#39;f_tsoil&#39;, &#39;f_smsf&#39;)
                if all(f in self.DIAGNOSTICS_INDEX for f in k_mult_fields):
                    for k, key in enumerate(self.DIAGNOSTICS_INDEX):
                        if key in k_mult_fields:
                            idx = k_mult_fields.index(key)
                            self.state.update(key, t, k_mult[idx])

            # Treat Kmult and Emult differently (i.e., break out the former
            #   but not the latter) because that is what L4C Ops does
            if &#39;t_mult&#39; in self.STATE_INDEX:
                self.state.update(&#39;t_mult&#39;, t, k_mult[0])
            if &#39;w_mult&#39; in self.STATE_INDEX:
                self.state.update(&#39;w_mult&#39;, t, k_mult[1])
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

        # Fill in out-of-bounds SMSF with 100% wetness
        fill = {&#39;tsoil&#39;: (np.nan, np.nan), &#39;smsf&#39;: (0, 100)}
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS, fill) as hdf:
            fields_rh = [&#39;tsoil&#39;, &#39;smsf&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(t, gpp[t,...], fields_rh)
                    self._time_idx += 1
                    progress.update(t)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel">L4CPrescribedGPPModel</a></li>
<li><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithKokEffect.DRIVERS_INDEX"><code class="name">var <span class="ident">DRIVERS_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel">L4CPrescribedGPPModel</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.constrain" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain">constrain</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.gpp" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp">gpp</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.rh" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.rh">rh</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.run" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.run">run</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.soc" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.soc">soc</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithLitterfallPhenology"><code class="flex name class">
<span>class <span class="ident">L4CPrescribedGPPModelWithLitterfallPhenology</span></span>
<span>(</span><span>config, stream=True, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Variation on L4CForwardProcessPoint where GPP is not calculated but is
prescribed by the user. This can be used for developing or testing SOC
and respiration sub-models with fixed GPP data. Also includes modeling of
the CASA litterfall phenology scheme; see
<code><a title="pyl4c.apps.l4c.extensions.phenology.L4CWithLitterfallPhenology" href="phenology.html#pyl4c.apps.l4c.extensions.phenology.L4CWithLitterfallPhenology">L4CWithLitterfallPhenology</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of configuration parameters</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use L4CStreamingInputDataset instead of reading in all driver
data; this reduces memory use but increases I/O</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to print all output to stdout</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to store additional diagnostic information from each time step</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CPrescribedGPPModelWithLitterfallPhenology(
        LitterfallMixin, L4CPrescribedGPPModel):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data. Also includes modeling of
    the CASA litterfall phenology scheme; see
    `pyl4c.apps.l4c.extensions.phenology.L4CWithLitterfallPhenology`.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    def __init__(
            self, config, stream = True, verbose = True, debug = False):
        super().__init__(
            config = config, stream = stream, verbose = verbose, debug = debug)
        # It is necessary to have a way to look up the day of year for
        #   indexing the litterfall array, which is (365 x N x 81)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            dt = [datetime.date(*t) for t in hdf[&#39;time&#39;][:].tolist()]
            self._doy = ordinals365(dt)
        # Set the daily litterfall
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        # Overwrite the daily litterfall that was set in the parent model
        self.constants.add(litterfall, &#39;litterfall&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.cosore.LitterfallMixin" href="#pyl4c.apps.l4c.extensions.cosore.LitterfallMixin">LitterfallMixin</a></li>
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel">L4CPrescribedGPPModel</a></li>
<li><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.extensions.cosore.LitterfallMixin" href="#pyl4c.apps.l4c.extensions.cosore.LitterfallMixin">LitterfallMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.LitterfallMixin.soc" href="#pyl4c.apps.l4c.extensions.cosore.LitterfallMixin.soc">soc</a></code></li>
</ul>
</li>
<li><code><b><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel">L4CPrescribedGPPModel</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.constrain" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain">constrain</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.gpp" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp">gpp</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.rh" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.rh">rh</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.run" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.run">run</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit"><code class="flex name class">
<span>class <span class="ident">L4CPrescribedGPPModelWithO2Limit</span></span>
<span>(</span><span>config, stream=True, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Variation on L4CForwardProcessPoint where GPP is not calculated but is
prescribed by the user. This can be used for developing or testing SOC
and respiration sub-models with fixed GPP data. Also includes modeling of
an O2 diffusion limit on heterotrophic respiration; see
<code><a title="pyl4c.apps.l4c.extensions.phenology.L4CWithO2Diffusion" href="phenology.html#pyl4c.apps.l4c.extensions.phenology.L4CWithO2Diffusion">L4CWithO2Diffusion</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of configuration parameters</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use L4CStreamingInputDataset instead of reading in all driver
data; this reduces memory use but increases I/O</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to print all output to stdout</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to store additional diagnostic information from each time step</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CPrescribedGPPModelWithO2Limit(
        L4CPrescribedGPPModel, O2DiffusionLimitMixin):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data. Also includes modeling of
    an O2 diffusion limit on heterotrophic respiration; see
    `pyl4c.apps.l4c.extensions.phenology.L4CWithO2Diffusion`.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    DRIVERS_INDEX = (&#39;tsoil&#39;, &#39;smsf&#39;)
    DIAGNOSTICS_INDEX = (&#39;f_tsoil&#39;, &#39;f_smsf&#39;, &#39;conc_O2&#39;, &#39;mm_O2&#39;)
    AIR_FRAC_O2 = 0.2095 # Liters of O2 per liter of air (20.95%)

    def __init__(
            self, config, stream = True, verbose = True, debug = False):
        super().__init__(
            config = config, stream = stream, verbose = verbose, debug = debug)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            # Read in porosity, copy to 1-km subgrid
            self._porosity = hdf[&#39;state/porosity&#39;][:][:,np.newaxis]\
                .repeat(81, axis = 1)

    def run(self, gpp, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        gpp : numpy.ndarray
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: `None`)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, gpp, fields_rh):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve intial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            rh, k_mult = self.rh(
                state, zip(hdf.index(t + self._t0, *fields_rh), fields_rh))
            npp = gpp * self.constants.CUE
            d_soc = self.soc(rh, t + self._t0)
            # Record fluxes for this time step
            self.fluxes.update(&#39;rh&#39;, t, rh.sum(axis = 0))
            self.fluxes.update(&#39;nee&#39;, t, rh.sum(axis = 0) - npp)
            # Record diagnostics at this time step
            if self._debug:
                # In debug mode, k_mult is not a single quantity but multiple;
                #   the order of k_mult_fields MUST match the order of the
                #   return signature for rh()
                k_mult_fields = (&#39;f_tsoil&#39;, &#39;f_smsf&#39;, &#39;conc_O2&#39;, &#39;mm_O2&#39;)
                if all(f in self.DIAGNOSTICS_INDEX for f in k_mult_fields):
                    for k, key in enumerate(self.DIAGNOSTICS_INDEX):
                        if key in k_mult_fields:
                            idx = k_mult_fields.index(key)
                            self.state.update(key, t, k_mult[idx])

            # Treat Kmult and Emult differently (i.e., break out the former
            #   but not the latter) because that is what L4C Ops does
            if &#39;t_mult&#39; in self.STATE_INDEX:
                self.state.update(&#39;t_mult&#39;, t, k_mult[0])
            if &#39;w_mult&#39; in self.STATE_INDEX:
                self.state.update(&#39;w_mult&#39;, t, k_mult[1])
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

        # Fill in out-of-bounds SMSF with 100% wetness
        fill = {&#39;tsoil&#39;: (np.nan, np.nan), &#39;smsf&#39;: (0, 100)}
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS, fill) as hdf:
            fields_rh = [&#39;tsoil&#39;, &#39;smsf&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(t, gpp[t,...], fields_rh)
                    self._time_idx += 1
                    progress.update(t)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel">L4CPrescribedGPPModel</a></li>
<li><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin">O2DiffusionLimitMixin</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2LimitAndLitterfallPhenology" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2LimitAndLitterfallPhenology">L4CPrescribedGPPModelWithO2LimitAndLitterfallPhenology</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit.AIR_FRAC_O2"><code class="name">var <span class="ident">AIR_FRAC_O2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit.DIAGNOSTICS_INDEX"><code class="name">var <span class="ident">DIAGNOSTICS_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit.DRIVERS_INDEX"><code class="name">var <span class="ident">DRIVERS_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel">L4CPrescribedGPPModel</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.constrain" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain">constrain</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.gpp" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp">gpp</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.rh" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.rh">rh</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.run" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.run">run</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.soc" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.soc">soc</a></code></li>
</ul>
</li>
<li><code><b><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin">O2DiffusionLimitMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.concentration_O2" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.concentration_O2">concentration_O2</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2LimitAndLitterfallPhenology"><code class="flex name class">
<span>class <span class="ident">L4CPrescribedGPPModelWithO2LimitAndLitterfallPhenology</span></span>
<span>(</span><span>config, stream=True, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Variation on L4CForwardProcessPoint where GPP is not calculated but is
prescribed by the user. This can be used for developing or testing SOC
and respiration sub-models with fixed GPP data. Also includes modeling of
the CASA litterfall phenology scheme; see
<code><a title="pyl4c.apps.l4c.extensions.phenology.L4CWithLitterfallPhenology" href="phenology.html#pyl4c.apps.l4c.extensions.phenology.L4CWithLitterfallPhenology">L4CWithLitterfallPhenology</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of configuration parameters</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use L4CStreamingInputDataset instead of reading in all driver
data; this reduces memory use but increases I/O</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to print all output to stdout</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to store additional diagnostic information from each time step</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CPrescribedGPPModelWithO2LimitAndLitterfallPhenology(
        LitterfallMixin, L4CPrescribedGPPModelWithO2Limit):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data. Also includes modeling of
    the CASA litterfall phenology scheme; see
    `pyl4c.apps.l4c.extensions.phenology.L4CWithLitterfallPhenology`.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    def __init__(
            self, config, stream = True, verbose = True, debug = False):
        super().__init__(
            config = config, stream = stream, verbose = verbose, debug = debug)
        # It is necessary to have a way to look up the day of year for
        #   indexing the litterfall array, which is (365 x N x 81)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            dt = [datetime.date(*t) for t in hdf[&#39;time&#39;][:].tolist()]
            self._doy = ordinals365(dt)
        # Set the daily litterfall
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        # Overwrite the daily litterfall that was set in the parent model
        self.constants.add(litterfall, &#39;litterfall&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.cosore.LitterfallMixin" href="#pyl4c.apps.l4c.extensions.cosore.LitterfallMixin">LitterfallMixin</a></li>
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit">L4CPrescribedGPPModelWithO2Limit</a></li>
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel">L4CPrescribedGPPModel</a></li>
<li><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin">O2DiffusionLimitMixin</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.extensions.cosore.LitterfallMixin" href="#pyl4c.apps.l4c.extensions.cosore.LitterfallMixin">LitterfallMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.LitterfallMixin.soc" href="#pyl4c.apps.l4c.extensions.cosore.LitterfallMixin.soc">soc</a></code></li>
</ul>
</li>
<li><code><b><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit">L4CPrescribedGPPModelWithO2Limit</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit.concentration_O2" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.concentration_O2">concentration_O2</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit.constrain" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain">constrain</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit.gpp" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp">gpp</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit.rh" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.rh">rh</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit.run" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.run">run</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile"><code class="flex name class">
<span>class <span class="ident">L4CPrescribedGPPModelWithSoilProfile</span></span>
<span>(</span><span>config, sm_profiles, litterfall_schedule=False, stream=True, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Variation on L4CForwardProcessPoint where GPP is not calculated but is
prescribed by the user. This can be used for developing or testing SOC
and respiration sub-models with fixed GPP data. Also includes modeling of
the vertical soil profile.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of configuration parameters</dd>
<dt><strong><code>sm_profiles</code></strong> :&ensp;<code>str</code></dt>
<dd>File path to HDF5 file containing soil moisture profiles</dd>
<dt><strong><code>litterfall_schedule</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if litterfall is a function of day-of-year (DOY); False if
litterfall is a pre-computed fraction of daily NPP (Default: False)</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use L4CStreamingInputDataset instead of reading in all driver
data; this reduces memory use but increases I/O</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to print all output to stdout</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to store additional diagnostic information from each time step</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CPrescribedGPPModelWithSoilProfile(
        StratifiedRespirationMixin, StratifiedLitterfallMixin,
        L4CPrescribedGPPModel):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data. Also includes modeling of
    the vertical soil profile.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    sm_profiles : str
        File path to HDF5 file containing soil moisture profiles
    litterfall_schedule : bool
        True if litterfall is a function of day-of-year (DOY); False if
        litterfall is a pre-computed fraction of daily NPP (Default: False)
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    CONSTANTS_INDEX = (
        &#39;CUE&#39;, &#39;LUE&#39;, &#39;f_metabolic&#39;, &#39;f_structural&#39;, &#39;decay_rates&#39;,
        &#39;k_depth_decay&#39;)
    # All DEPTHS must be positive
    DEPTHS = np.array((0.05, 0.15, 0.35, 0.75, 1.5, 3.0))\
        .reshape((6,1)) # meters
    # Get change in depth (layer thickness)
    DELTA_Z = (DEPTHS - np.vstack((0, DEPTHS[:-1])))\
        .reshape((DEPTHS.size, 1, 1))
    DIFFUSIVITY = 2e-4 # m2 yr-1 (Yi et al. 2020)

    def __init__(
            self, config, sm_profiles, litterfall_schedule = False,
            stream = True, verbose = True, debug = False):
        super().__init__(
            config = config, stream = stream, verbose = verbose, debug = debug)
        self._multilayer = True # Multiple soil layers
        self._scheduled = litterfall_schedule
        # After Yi et al. (2020), diffusivity declines linearly with depth to
        #   3 meters; also convert to units of m2 day-1
        self.diffusivity = (self.DIFFUSIVITY / 365) *\
            linear_constraint(0, 3, form = &#39;reversed&#39;)(np.abs(self.DEPTHS))
        self.profiles_file_path = sm_profiles
        # Initialize the vertically discretized state
        self.state_by_depth = np.full((
            1 + len(self.DIAGNOSTICS_INDEX), config[&#39;time_steps&#39;],
            self.DEPTHS.size, config[&#39;site_count&#39;], 81
        ), np.nan, dtype = np.float32)

    @property
    def state_by_depth(self):
        return self._state_by_depth

    @state_by_depth.setter
    def state_by_depth(self, new):
        self._state_by_depth.data = new

    def run(self, gpp, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        gpp : numpy.ndarray
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: `None`)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, gpp, fields_rh, soil_t, soil_m, litterfall):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve intial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            rh, k_mult = self.rh(state, (soil_t, soil_m))
            npp = gpp * self.constants.CUE
            # NOTE: Litterfall inputs may not scheduled
            d_soc = self.soc(
                state, rh, litterfall, t + self._t0,
                scheduled = self._scheduled)
            # Update RH in each soil layer, convert from g C m-3 to g C m-2
            rh = np.nansum(rh, axis = 0) * self.DELTA_Z
            self.state_by_depth.update(&#39;rh&#39;, t, rh)
            # Update NEE, taking sum of RH across all soil layers
            self.fluxes.update(&#39;nee&#39;, t, np.nansum(rh, axis = 0) - npp)
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

        # Load supplemental datasets
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            porosity = hdf[&#39;state/porosity&#39;][:]
            # Calculate extent of soil layers, given bedrock depth
            bedrock = hdf[&#39;LAND_MODEL_CONSTANTS/depth_to_bedrock_m&#39;][:]
            layer_mask = self.DEPTHS &lt; bedrock
            # &#34;surface_temp&#34; is used for the surface layer (0-5 cm)
            soil_t = []
            soil_t.append(hdf[&#39;L4SM_DAILY_MEAN/surface_temp&#39;][self._t0:,:])
            for i in range(1, self.DEPTHS.size):
                soil_t.append(
                    hdf[&#39;L4SM_DAILY_MEAN/soil_temp_layer%d&#39; % i][self._t0:,:])
            soil_t = np.stack(soil_t)
            # Mask out measurements below bedrock depth
            soil_t.swapaxes(1, 2)[~layer_mask,...] = np.nan
        with h5py.File(self.profiles_file_path, &#39;r&#39;) as hdf:
            soil_m = 100 * np.divide(
                hdf[&#39;soil_moisture_vwc&#39;][:,self._t0:,:], porosity)
            # Clip f(SM) response, as wetness values might be unrealistic
            #   given problems in ice-filled soil layers
            soil_m[soil_m &gt; 100] = 100
            # Mask out measurements below bedrock depth
            soil_m.swapaxes(1, 2)[~layer_mask,...] = np.nan
        porosity = None
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS) as hdf:
            fields_rh = [&#39;tsoil&#39;, &#39;smsf&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(t, gpp[t,...], fields_rh, soil_t[:,t,:,None],
                        soil_m[:,t,:,None], litterfall)
                    self._time_idx += 1
                    progress.update(t)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin">StratifiedRespirationMixin</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin">StratifiedLitterfallMixin</a></li>
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel">L4CPrescribedGPPModel</a></li>
<li><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndLitterfall" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndLitterfall">L4CPrescribedGPPModelWithSoilProfileAndLitterfall</a></li>
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndO2Limit" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndO2Limit">L4CPrescribedGPPModelWithSoilProfileAndO2Limit</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.CONSTANTS_INDEX"><code class="name">var <span class="ident">CONSTANTS_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.DELTA_Z"><code class="name">var <span class="ident">DELTA_Z</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.DEPTHS"><code class="name">var <span class="ident">DEPTHS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.DIFFUSIVITY"><code class="name">var <span class="ident">DIFFUSIVITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.state_by_depth"><code class="name">var <span class="ident">state_by_depth</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state_by_depth(self):
    return self._state_by_depth</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin">StratifiedRespirationMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin.rh" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin.rh">rh</a></code></li>
</ul>
</li>
<li><code><b><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin">StratifiedLitterfallMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin.soc" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin.soc">soc</a></code></li>
</ul>
</li>
<li><code><b><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel">L4CPrescribedGPPModel</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.run" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.run">run</a></code></li>
</ul>
</li>
<li><code><b><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel">L4CPrescribedGPPModel</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.constrain" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain">constrain</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.gpp" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp">gpp</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndLitterfall"><code class="flex name class">
<span>class <span class="ident">L4CPrescribedGPPModelWithSoilProfileAndLitterfall</span></span>
<span>(</span><span>config, sm_profiles, litterfall_schedule=True, stream=True, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Variation on L4CForwardProcessPoint where GPP is not calculated but is
prescribed by the user. This can be used for developing or testing SOC
and respiration sub-models with fixed GPP data. Also includes modeling of
the vertical soil profile AND a litterfall phenology</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of configuration parameters</dd>
<dt><strong><code>sm_profiles</code></strong> :&ensp;<code>str</code></dt>
<dd>File path to HDF5 file containing soil moisture profiles</dd>
<dt><strong><code>litterfall_schedule</code></strong> :&ensp;<code>bool</code></dt>
<dd>NOTE: Cannot be changed, defaults to True; see
<code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile">L4CPrescribedGPPModelWithSoilProfile</a></code></dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use L4CStreamingInputDataset instead of reading in all driver
data; this reduces memory use but increases I/O</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to print all output to stdout</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to store additional diagnostic information from each time step</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CPrescribedGPPModelWithSoilProfileAndLitterfall(
        L4CPrescribedGPPModelWithSoilProfile):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data. Also includes modeling of
    the vertical soil profile AND a litterfall phenology

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    sm_profiles : str
        File path to HDF5 file containing soil moisture profiles
    litterfall_schedule : bool
        NOTE: Cannot be changed, defaults to True; see
        `pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile`
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    def __init__(
            self, config, sm_profiles, litterfall_schedule = True,
            stream = True, verbose = True, debug = False):
        super().__init__(
            config = config, sm_profiles = sm_profiles,
            litterfall_schedule = True, stream = stream,
            verbose = verbose, debug = debug)
        # It is necessary to have a way to look up the day of year for
        #   indexing the litterfall array, which is (365 x N x 81)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            dt = [datetime.date(*t[:]) for t in hdf[&#39;time&#39;][:].tolist()]
            self._doy = ordinals365(dt)
        # Set the daily litterfall
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        # Overwrite the daily litterfall that was set in the parent model
        self.constants.add(litterfall, &#39;litterfall&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile">L4CPrescribedGPPModelWithSoilProfile</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin">StratifiedRespirationMixin</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin">StratifiedLitterfallMixin</a></li>
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel">L4CPrescribedGPPModel</a></li>
<li><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile">L4CPrescribedGPPModelWithSoilProfile</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.constrain" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain">constrain</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.gpp" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp">gpp</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.rh" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin.rh">rh</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.run" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.run">run</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.soc" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin.soc">soc</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndO2Limit"><code class="flex name class">
<span>class <span class="ident">L4CPrescribedGPPModelWithSoilProfileAndO2Limit</span></span>
<span>(</span><span>config, sm_profiles, litterfall_schedule=False, stream=True, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Variation on L4CForwardProcessPoint where GPP is not calculated but is
prescribed by the user. This can be used for developing or testing SOC
and respiration sub-models with fixed GPP data. Also includes modeling of
the vertical soil profile AND an O2 diffusion limit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of configuration parameters</dd>
<dt><strong><code>sm_profiles</code></strong> :&ensp;<code>str</code></dt>
<dd>File path to HDF5 file containing soil moisture profiles</dd>
<dt><strong><code>litterfall_schedule</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if litterfall is a function of day-of-year (DOY); False if
litterfall is a pre-computed fraction of daily NPP (Default: False)</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use L4CStreamingInputDataset instead of reading in all driver
data; this reduces memory use but increases I/O</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to print all output to stdout</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to store additional diagnostic information from each time step</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CPrescribedGPPModelWithSoilProfileAndO2Limit(
        O2DiffusionLimitMixin, L4CPrescribedGPPModelWithSoilProfile):
    &#39;&#39;&#39;
    Variation on L4CForwardProcessPoint where GPP is not calculated but is
    prescribed by the user. This can be used for developing or testing SOC
    and respiration sub-models with fixed GPP data. Also includes modeling of
    the vertical soil profile AND an O2 diffusion limit.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    sm_profiles : str
        File path to HDF5 file containing soil moisture profiles
    litterfall_schedule : bool
        True if litterfall is a function of day-of-year (DOY); False if
        litterfall is a pre-computed fraction of daily NPP (Default: False)
    stream : bool
        True to use L4CStreamingInputDataset instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    DIAGNOSTICS_INDEX = (&#39;f_tsoil&#39;, &#39;f_smsf&#39;, &#39;conc_O2&#39;, &#39;mm_O2&#39;)
    AIR_FRAC_O2 = 0.2095 # Liters of O2 per liter of air (20.95%)

    def __init__(
            self, config, sm_profiles, litterfall_schedule = False,
            stream = True, verbose = True, debug = False):
        super().__init__(
            config = config, sm_profiles = sm_profiles,
            litterfall_schedule = litterfall_schedule, stream = stream,
            verbose = verbose, debug = debug)
        # Read in porosity, copy to 1-km subgrid
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            self._porosity = hdf[&#39;state/porosity&#39;][:][:,np.newaxis]\
                .repeat(81, axis = 1)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin">O2DiffusionLimitMixin</a></li>
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile">L4CPrescribedGPPModelWithSoilProfile</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin">StratifiedRespirationMixin</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin">StratifiedLitterfallMixin</a></li>
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel">L4CPrescribedGPPModel</a></li>
<li><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndO2Limit.AIR_FRAC_O2"><code class="name">var <span class="ident">AIR_FRAC_O2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndO2Limit.DIAGNOSTICS_INDEX"><code class="name">var <span class="ident">DIAGNOSTICS_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin">O2DiffusionLimitMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.concentration_O2" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.concentration_O2">concentration_O2</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.rh" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.rh">rh</a></code></li>
</ul>
</li>
<li><code><b><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile">L4CPrescribedGPPModelWithSoilProfile</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.constrain" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain">constrain</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.gpp" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp">gpp</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.run" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.run">run</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.soc" href="hydrology.html#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin.soc">soc</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyl4c.apps.l4c.extensions.cosore.LitterfallMixin"><code class="flex name class">
<span>class <span class="ident">LitterfallMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Implements support for a litterfall phenology in the soil organic carbon
(SOC) decomposition model as a mix-in. Should not be instantiated directly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LitterfallMixin:
    &#39;&#39;&#39;
    Implements support for a litterfall phenology in the soil organic carbon
    (SOC) decomposition model as a mix-in. Should not be instantiated directly.
    &#39;&#39;&#39;
    def soc(self, rh, t):
        &#39;&#39;&#39;
        Calculate change in SOC for a single time step.

        Parameters
        ----------
        rh : numpy.ndarray
            (3 x N x M) array of RH at the current time step
        t : int
            Current time step

        Returns
        -------
        numpy.ndarray
        &#39;&#39;&#39;
        # Change in SOC according to diff. eq. in Jones et al. (2017)
        doy = self._doy[t] - 1 # Get DOY on [1,365] then on [0,364] for Python
        litter = self.constants.litterfall[doy,...]
        dc1 = (litter * self.constants.f_metabolic) - rh[0,...]
        dc2 = (litter * (1 - self.constants.f_metabolic)) - rh[1,...]
        dc3 = (self.constants.f_structural * rh[1,...]) - rh[2,...]
        return (dc1, dc2, dc3)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithLitterfallPhenology" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithLitterfallPhenology">L4CPrescribedGPPModelWithLitterfallPhenology</a></li>
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2LimitAndLitterfallPhenology" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2LimitAndLitterfallPhenology">L4CPrescribedGPPModelWithO2LimitAndLitterfallPhenology</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.cosore.LitterfallMixin.soc"><code class="name flex">
<span>def <span class="ident">soc</span></span>(<span>self, rh, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate change in SOC for a single time step.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rh</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>(3 x N x M) array of RH at the current time step</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>int</code></dt>
<dd>Current time step</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soc(self, rh, t):
    &#39;&#39;&#39;
    Calculate change in SOC for a single time step.

    Parameters
    ----------
    rh : numpy.ndarray
        (3 x N x M) array of RH at the current time step
    t : int
        Current time step

    Returns
    -------
    numpy.ndarray
    &#39;&#39;&#39;
    # Change in SOC according to diff. eq. in Jones et al. (2017)
    doy = self._doy[t] - 1 # Get DOY on [1,365] then on [0,364] for Python
    litter = self.constants.litterfall[doy,...]
    dc1 = (litter * self.constants.f_metabolic) - rh[0,...]
    dc2 = (litter * (1 - self.constants.f_metabolic)) - rh[1,...]
    dc3 = (self.constants.f_structural * rh[1,...]) - rh[2,...]
    return (dc1, dc2, dc3)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyl4c.apps.l4c.extensions" href="index.html">pyl4c.apps.l4c.extensions</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel">L4CPrescribedGPPModel</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.DIAGNOSTICS_INDEX" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.DIAGNOSTICS_INDEX">DIAGNOSTICS_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.DRIVERS_INDEX" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.DRIVERS_INDEX">DRIVERS_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.FLUX_INDEX" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.FLUX_INDEX">FLUX_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.REQUIRED_CONFIGURATION" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.REQUIRED_CONFIGURATION">REQUIRED_CONFIGURATION</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.run" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModel.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithKokEffect" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithKokEffect">L4CPrescribedGPPModelWithKokEffect</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithKokEffect.DRIVERS_INDEX" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithKokEffect.DRIVERS_INDEX">DRIVERS_INDEX</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithLitterfallPhenology" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithLitterfallPhenology">L4CPrescribedGPPModelWithLitterfallPhenology</a></code></h4>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit">L4CPrescribedGPPModelWithO2Limit</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit.AIR_FRAC_O2" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit.AIR_FRAC_O2">AIR_FRAC_O2</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit.DIAGNOSTICS_INDEX" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit.DIAGNOSTICS_INDEX">DIAGNOSTICS_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit.DRIVERS_INDEX" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit.DRIVERS_INDEX">DRIVERS_INDEX</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2LimitAndLitterfallPhenology" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2LimitAndLitterfallPhenology">L4CPrescribedGPPModelWithO2LimitAndLitterfallPhenology</a></code></h4>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile">L4CPrescribedGPPModelWithSoilProfile</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.CONSTANTS_INDEX" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.CONSTANTS_INDEX">CONSTANTS_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.DELTA_Z" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.DELTA_Z">DELTA_Z</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.DEPTHS" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.DEPTHS">DEPTHS</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.DIFFUSIVITY" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.DIFFUSIVITY">DIFFUSIVITY</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.state_by_depth" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile.state_by_depth">state_by_depth</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndLitterfall" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndLitterfall">L4CPrescribedGPPModelWithSoilProfileAndLitterfall</a></code></h4>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndO2Limit" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndO2Limit">L4CPrescribedGPPModelWithSoilProfileAndO2Limit</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndO2Limit.AIR_FRAC_O2" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndO2Limit.AIR_FRAC_O2">AIR_FRAC_O2</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndO2Limit.DIAGNOSTICS_INDEX" href="#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndO2Limit.DIAGNOSTICS_INDEX">DIAGNOSTICS_INDEX</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.cosore.LitterfallMixin" href="#pyl4c.apps.l4c.extensions.cosore.LitterfallMixin">LitterfallMixin</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.extensions.cosore.LitterfallMixin.soc" href="#pyl4c.apps.l4c.extensions.cosore.LitterfallMixin.soc">soc</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>