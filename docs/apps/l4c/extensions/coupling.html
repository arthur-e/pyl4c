<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyl4c.apps.l4c.extensions.coupling API documentation</title>
<meta name="description" content="Couplers for L4C and other models." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:35%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyl4c.apps.l4c.extensions.coupling</code></h1>
</header>
<section id="section-intro">
<p>Couplers for L4C and other models.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Couplers for L4C and other models.
&#39;&#39;&#39;

import datetime
import pickle
import numpy as np
import h5py
from pyl4c import suppress_warnings
from pyl4c.science import ordinals365
from pyl4c.lib.cli import ProgressBar
from pyl4c.apps.l4c.io import L4CStreamingInputDataset
from pyl4c.apps.l4c.main import L4CForwardProcessPoint
from pyl4c.apps.l4c.extensions.damm import DAMMDecompositionModel2, g_cm3_to_g_m2
from pyl4c.apps.l4c.extensions.phenology import L4CPhenologyProcess

class L4CEnhancedDecomposition(L4CPhenologyProcess):
    &#39;&#39;&#39;
    Variation on SMAP L4C model, with two improvements to the SOC deomposition
    model:

    1. The RH sub-model is modified to include an O2 diffusion limitation.
        Driver data are the same as for any L4C Science run, so additional
        configuration data must be provided: &#34;soc_data_path&#34; and
        &#34;extra_parameters&#34;.
    2. The SOC sub-model is modified to include a litterfall phenology.
        Driver data are the same as for any L4C Science run, except that
        litterfall is different.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    stream : bool
        True to use `L4CStreamingInputDataset` instead of reading in all
        driver data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    PFT_CODES = range(1, 9)
    DIAGNOSTICS_INDEX = (&#39;f_tsoil&#39;, &#39;f_smsf&#39;, &#39;conc_O2&#39;, &#39;mm_O2&#39;)
    STATE_INDEX = (&#39;soc1&#39;, &#39;soc2&#39;, &#39;soc3&#39;)
    AIR_FRAC_O2 = 0.2095 # Liters of O2 per liter of air (20.95%)

    def __init__(
            self, config, stream = True, verbose = True, debug = False):
        super().__init__(
            config = config, stream = stream, verbose = verbose, debug = debug)
        # For the litterfall phenology: It is necessary to have a way to look
        #   up the day of year for indexing the litterfall array, which is
        #   (365 x N x 81)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            dt = [datetime.date(*t[:-1]) for t in hdf[&#39;time&#39;][:].tolist()]
            self._doy = ordinals365(dt)
        # For the O2 diffusion limit: Read in porosity, copy to 1-km subgrid
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            self._porosity = hdf[&#39;state/porosity&#39;][:][:,np.newaxis]\
                .repeat(81, axis = 1)

    def concentration_O2(self, soil_vwc):
        &#39;&#39;&#39;
        Concentration of O2 given soil vegetation water content (VWC).

        Parameters
        ----------
        soil_vwc : float or numpy.ndarray
            The soil moisture volumetric water content (m3 m-3)

        Returns
        -------
        float or numpy.ndarray
            The O2 concentration in soil pore spaces (dimensionless, L L-1)
        &#39;&#39;&#39;
        d_gas = self._extra_params[&#39;d_gas&#39;]
        return d_gas * self.AIR_FRAC_O2 * np.power(
            self._porosity - soil_vwc, 4/3)

    def rh(self, state, drivers):
        &#39;&#39;&#39;
        Calculate heterotrophic respiration (RH) for a single time step.

        Parameters
        ----------
        state : numpy.ndarray
            `(3 x N x M)` array of current SOC state in each pool
        drivers : list or tuple
            Nested sequence of (driver: `numpy.ndarray`, label: `str`) pairs

        Returns
        -------
        numpy.ndarray
            Heterotrophic respiration (g C m-2 day-1)
        &#39;&#39;&#39;
        # Translate Tsoil and SMSF into environmental constraints on RH
        tsoil, smsf = drivers
        f_tsoil = self.constrain(*tsoil)
        f_smsf = self.constrain(*smsf)
        smsf, _ = smsf # Pop off the label &#34;smsf&#34; and just get the data
        # NOTE: Converting from &#34;wetness&#34; to volumetric water content (VWC)
        #   (in % units); this requires multiplying (wetness * porosity) as
        #   (wetness = VWC / porosity)
        soil_vwc = np.multiply(smsf / 100, self._porosity)
        conc_O2 = self.concentration_O2(soil_vwc)
        mm_O2 = conc_O2 / (self._extra_params[&#39;km_oxy&#39;] + conc_O2)
        # Take the minimum of the SMSF and Soil VWC constraint
        k_mult = f_tsoil * np.min(np.stack((f_smsf, mm_O2)), axis = 0)
        k_mult = k_mult[np.newaxis,...].repeat(3, axis = 0)
        # NOTE: These are true decay rates for 2nd and 3rd pools, so it
        #   is straightforward to multiply them against SOC
        rh = k_mult * self.constants.decay_rates * state
        # &#34;the adjustment...to account for material transferred into the
        #   slow pool during humification&#34; (Jones et al. 2017 TGARS, p.5)
        rh[1,...] = rh[1,...] * (1 - self.constants.f_structural)
        # T_mult, W_mult same for each pool
        return (rh, (f_tsoil, f_smsf, conc_O2, mm_O2))

    def run(self, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: `None`)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, fields_gpp, fields_rh):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve initial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            gpp, e_mult = self.gpp(
                zip(hdf.index(t + self._t0, *fields_gpp), fields_gpp))
            rh, rh_diag = self.rh(
                state, zip(hdf.index(t + self._t0, *fields_rh), fields_rh))
            npp = gpp * self.constants.CUE
            d_soc = self.soc(rh, t + self._t0)
            # Record fluxes for this time step
            self.fluxes.update(&#39;gpp&#39;, t, gpp)
            self.fluxes.update(&#39;rh&#39;, t, rh.sum(axis = 0))
            self.fluxes.update(&#39;nee&#39;, t, rh.sum(axis = 0) - npp)
            if self._debug:
                f_tsoil, f_smsf, conc_O2, mm_O2 = rh_diag
                self.state.update(&#39;f_tsoil&#39;, t, f_tsoil)
                self.state.update(&#39;f_smsf&#39;, t, f_smsf)
                self.state.update(&#39;conc_O2&#39;, t, conc_O2)
                self.state.update(&#39;mm_O2&#39;, t, mm_O2)
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS) as hdf:
            fields_gpp = [&#39;apar&#39;, &#39;tmin&#39;, &#39;vpd&#39;, &#39;ft&#39;, &#39;smrz&#39;]
            fields_rh = [&#39;tsoil&#39;, &#39;smsf&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(t, fields_gpp, fields_rh)
                    self._time_idx += 1
                    progress.update(t)

    def soc(self, rh, t):
        &#39;&#39;&#39;
        Calculate change in soil organic carbon (SOC) for a single time step.

        Parameters
        ----------
        rh : numpy.ndarray
            `(3 x N x M)` array of RH at the current time step
        t : int
            Current time step

        Returns
        -------
        numpy.ndarray
        &#39;&#39;&#39;
        # Change in SOC according to diff. eq. in Jones et al. (2017)
        doy = self._doy[t] - 1 # Get DOY on [1,365] then on [0,364] for Python
        litter = self.constants.litterfall[doy,...]
        dc1 = (litter * self.constants.f_metabolic) - rh[0,...]
        dc2 = (litter * (1 - self.constants.f_metabolic)) - rh[1,...]
        dc3 = (self.constants.f_structural * rh[1,...]) - rh[2,...]
        return (dc1, dc2, dc3)


class L4CDAMM(L4CForwardProcessPoint):
    &#39;&#39;&#39;
    L4C-DAMM model, coupling the L4C GPP and SOC models to the DAMM RH model.
    L4C computes daily GPP and litterfall, then DAMM computes RH, which L4C
    then uses to compute change in SOC.

    In debug mode, diagnostics includes the substrate and O2 concentrations as
    well as the half-saturation (MM) constants for substrate and O2. The MM
    constant for substrate reported is the minimum across the three substrate
    pools.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    rh_model : AbstractDAMM
        The class of DAMM model to use for RH calculations
    use_l4c_cue : bool
        True to use the CUE parameters from L4C instead of those fit by
        L4C-DAMM (Default: True)
    use_legacy_pft : bool
        True to use the L4C Nature Run v7.2 &#34;legacy&#34; PFT map (&#34;lc_dom&#34;)
        for the PFT class assignments of each pixel (Default: True)
    stream : bool
        True to use `L4CStreamingInputDataset` instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    PFT_CODES = range(1, 9)
    SOIL_DEPTH_CM = 5
    DIAGNOSTICS_INDEX = (&#39;conc_Sx&#39;, &#39;conc_O2&#39;, &#39;v_max&#39;, &#39;mm_O2&#39;, &#39;mm_Sx&#39;)
    STATE_INDEX = (&#39;soc1&#39;, &#39;soc2&#39;, &#39;soc3&#39;)
    V_MAX_SCALE = 1e12 # Factor by which to scale Vmax before exporting

    def __init__(
            self, config, rh_model = DAMMDecompositionModel2,
            use_l4c_cue = True, use_legacy_pft = True, stream = True,
            verbose = True, debug = False):
        super().__init__(config, stream, verbose, debug)
        assert &#39;rh_parameters&#39; in config.keys(),\
            &#39;Coupled L4C-DAMM model requires &#34;rh_parameters&#34; configuration key&#39;
        if debug and self.V_MAX_SCALE != 1:
            print(&#39;WARNING: V_MAX_SCALE is non-unity: V_max should not be interpreted physically&#39;)
        self.DAMM = rh_model
        with open(config[&#39;rh_parameters&#39;], &#39;rb&#39;) as file:
            data_dict = pickle.load(file)
            # Add NaNs to position 0 so that PFT numeric id == index value
            params = np.vstack((
                [np.nan] * data_dict[&#39;parameters&#39;].shape[1],
                data_dict[&#39;parameters&#39;]))

        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS) as hdf:
            if use_legacy_pft:
                self._pft = hdf[&#39;legacy/lc_dom&#39;][:].swapaxes(0, 1)
            else:
                self._pft = hdf[&#39;state/PFT&#39;][:]
            # Set invalid PFT codes to PFT 0
            self._pft = np.where(self._pft &gt; max(self.PFT_CODES), 0, self._pft)
            # Vectorize the DAMM parameters
            self._rh_params = [
                params[self._pft,i] for i in range(0, params.shape[1])
            ]
            # Read in porosity, copy to 1-km subgrid
            self._porosity = hdf[&#39;state/porosity&#39;][:][:,np.newaxis]\
                .repeat(81, axis = 1)
            # Option to use CUE parameters fit in L4C-DAMM...
            if not use_l4c_cue:
                # Convert annual NPP sum to annual GPP sum (using L4C CUE)
                gpp_sum = hdf[&#39;state/npp_sum&#39;][:] / self.constants.CUE
                # Then, change CUE constant
                p = data_dict[&#39;metadata&#39;].index(&#39;CUE&#39;)
                cue = np.hstack((np.nan, data_dict[&#39;parameters&#39;][:,p]))
                self.constants.CUE = cue[self._pft]
                npp_sum = gpp_sum * self.constants.CUE
                # Calculate daily litterfall based on the annual NPP sum
                self.constants.add(
                    npp_sum / self.DAYS_PER_YEAR, &#39;litterfall&#39;)

    def rh(self, state, drivers):
        &#39;&#39;&#39;
        Calculate heterotrophic respiration (RH) for a single time step.

        Parameters
        ----------
        state : numpy.ndarray
            `(3 x N x M)` array of current SOC state in each pool
        drivers : list or tuple
            Nested sequence of (driver: `numpy.ndarray`, label: `str`) pairs

        Returns
        -------
        numpy.ndarray
            Heterotrophic respiration (g C m-2 day-1)
        &#39;&#39;&#39;
        tsoil, smsf = drivers
        # NOTE: Converting from &#34;wetness&#34; to volumetric water content (VWC)
        #   (in % units); this requires multiplying (wetness * porosity) as
        #   (wetness = VWC / porosity)
        vwc = 100 * np.multiply(smsf / 100, self._porosity)
        damm = self.DAMM(self._rh_params, self.SOIL_DEPTH_CM)
        # Convert SOC from g m-2 to g cm-3
        substrate = [
            np.array(s)
            for s in g_cm3_to_g_m2(state, self.SOIL_DEPTH_CM).tolist()
        ]
        rh = np.stack(
            damm.respiration(substrate, vwc, tsoil, self._porosity), axis = 0)
        if self._debug:
            conc_Sx, conc_O2 = damm.concentrations(
                substrate, vwc, self._porosity)
            v_max = np.stack([ # alpha0, alpha1, and alpha2 are first 3 params
                damm.v_max(tsoil, a) for a in self._rh_params[0:3]
            ], axis = 0)
        else:
            conc_Sx, conc_O2, v_max = (None, None, None)
        # &#34;the adjustment...to account for material transferred into the
        #   slow pool during humification&#34; (Jones et al. 2017 TGARS, p.5)
        rh[1,...] = rh[1,...] * (1 - self.constants.f_structural)
        return (rh, conc_Sx, conc_O2, v_max)

    def run(self, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: None)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, fields_gpp, fields_rh):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve initial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            gpp, e_mult = self.gpp(
                zip(hdf.index(t + self._t0, *fields_gpp), fields_gpp))
            rh, conc_Sx, conc_O2, v_max = self.rh(
                state, hdf.index(t + self._t0, *fields_rh))
            npp = gpp * self.constants.CUE
            d_soc = self.soc(rh)
            # Record fluxes for this time step
            self.fluxes.update(&#39;gpp&#39;, t, gpp)
            self.fluxes.update(&#39;rh&#39;, t, rh.sum(axis = 0))
            self.fluxes.update(&#39;nee&#39;, t, rh.sum(axis = 0) - npp)
            if self._debug:
                self.state.update(&#39;conc_Sx&#39;, t, conc_Sx.sum(axis = 0))
                self.state.update(&#39;conc_O2&#39;, t, conc_O2)
                km_s = km_s_int + (km_s_slope * hdf.index(t + self._t0, &#39;tsoil&#39;)[0])
                self.state.update(&#39;mm_Sx&#39;, t, (conc_Sx / (km_s + conc_Sx)).min(axis = 0))
                self.state.update(&#39;mm_O2&#39;, t, conc_O2 / (km_O2 + conc_O2))
                self.state.update(&#39;v_max&#39;, t,
                    np.multiply(self.V_MAX_SCALE, v_max).mean(axis = 0))
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

        if self._debug:
            # Read in the following parameter values in debug mode
            km_O2 = self._rh_params[self.DAMM.parameter_names.index(&#39;km_O2&#39;)]
            km_s_int = self._rh_params[self.DAMM.parameter_names.index(&#39;km_s_int&#39;)]
            km_s_slope = self._rh_params[self.DAMM.parameter_names.index(&#39;km_s_slope&#39;)]
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS) as hdf:
            fields_gpp = [&#39;apar&#39;, &#39;tmin&#39;, &#39;vpd&#39;, &#39;ft&#39;, &#39;smrz&#39;]
            fields_rh = [&#39;tsoil&#39;, &#39;smsf&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(t, fields_gpp, fields_rh)
                    self._time_idx += 1
                    progress.update(t)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CDAMM"><code class="flex name class">
<span>class <span class="ident">L4CDAMM</span></span>
<span>(</span><span>config, rh_model=pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel2, use_l4c_cue=True, use_legacy_pft=True, stream=True, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>L4C-DAMM model, coupling the L4C GPP and SOC models to the DAMM RH model.
L4C computes daily GPP and litterfall, then DAMM computes RH, which L4C
then uses to compute change in SOC.</p>
<p>In debug mode, diagnostics includes the substrate and O2 concentrations as
well as the half-saturation (MM) constants for substrate and O2. The MM
constant for substrate reported is the minimum across the three substrate
pools.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of configuration parameters</dd>
<dt><strong><code>rh_model</code></strong> :&ensp;<code>AbstractDAMM</code></dt>
<dd>The class of DAMM model to use for RH calculations</dd>
<dt><strong><code>use_l4c_cue</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use the CUE parameters from L4C instead of those fit by
L4C-DAMM (Default: True)</dd>
<dt><strong><code>use_legacy_pft</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use the L4C Nature Run v7.2 "legacy" PFT map ("lc_dom")
for the PFT class assignments of each pixel (Default: True)</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use <code>L4CStreamingInputDataset</code> instead of reading in all driver
data; this reduces memory use but increases I/O</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to print all output to stdout</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to store additional diagnostic information from each time step</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CDAMM(L4CForwardProcessPoint):
    &#39;&#39;&#39;
    L4C-DAMM model, coupling the L4C GPP and SOC models to the DAMM RH model.
    L4C computes daily GPP and litterfall, then DAMM computes RH, which L4C
    then uses to compute change in SOC.

    In debug mode, diagnostics includes the substrate and O2 concentrations as
    well as the half-saturation (MM) constants for substrate and O2. The MM
    constant for substrate reported is the minimum across the three substrate
    pools.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    rh_model : AbstractDAMM
        The class of DAMM model to use for RH calculations
    use_l4c_cue : bool
        True to use the CUE parameters from L4C instead of those fit by
        L4C-DAMM (Default: True)
    use_legacy_pft : bool
        True to use the L4C Nature Run v7.2 &#34;legacy&#34; PFT map (&#34;lc_dom&#34;)
        for the PFT class assignments of each pixel (Default: True)
    stream : bool
        True to use `L4CStreamingInputDataset` instead of reading in all driver
        data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    PFT_CODES = range(1, 9)
    SOIL_DEPTH_CM = 5
    DIAGNOSTICS_INDEX = (&#39;conc_Sx&#39;, &#39;conc_O2&#39;, &#39;v_max&#39;, &#39;mm_O2&#39;, &#39;mm_Sx&#39;)
    STATE_INDEX = (&#39;soc1&#39;, &#39;soc2&#39;, &#39;soc3&#39;)
    V_MAX_SCALE = 1e12 # Factor by which to scale Vmax before exporting

    def __init__(
            self, config, rh_model = DAMMDecompositionModel2,
            use_l4c_cue = True, use_legacy_pft = True, stream = True,
            verbose = True, debug = False):
        super().__init__(config, stream, verbose, debug)
        assert &#39;rh_parameters&#39; in config.keys(),\
            &#39;Coupled L4C-DAMM model requires &#34;rh_parameters&#34; configuration key&#39;
        if debug and self.V_MAX_SCALE != 1:
            print(&#39;WARNING: V_MAX_SCALE is non-unity: V_max should not be interpreted physically&#39;)
        self.DAMM = rh_model
        with open(config[&#39;rh_parameters&#39;], &#39;rb&#39;) as file:
            data_dict = pickle.load(file)
            # Add NaNs to position 0 so that PFT numeric id == index value
            params = np.vstack((
                [np.nan] * data_dict[&#39;parameters&#39;].shape[1],
                data_dict[&#39;parameters&#39;]))

        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS) as hdf:
            if use_legacy_pft:
                self._pft = hdf[&#39;legacy/lc_dom&#39;][:].swapaxes(0, 1)
            else:
                self._pft = hdf[&#39;state/PFT&#39;][:]
            # Set invalid PFT codes to PFT 0
            self._pft = np.where(self._pft &gt; max(self.PFT_CODES), 0, self._pft)
            # Vectorize the DAMM parameters
            self._rh_params = [
                params[self._pft,i] for i in range(0, params.shape[1])
            ]
            # Read in porosity, copy to 1-km subgrid
            self._porosity = hdf[&#39;state/porosity&#39;][:][:,np.newaxis]\
                .repeat(81, axis = 1)
            # Option to use CUE parameters fit in L4C-DAMM...
            if not use_l4c_cue:
                # Convert annual NPP sum to annual GPP sum (using L4C CUE)
                gpp_sum = hdf[&#39;state/npp_sum&#39;][:] / self.constants.CUE
                # Then, change CUE constant
                p = data_dict[&#39;metadata&#39;].index(&#39;CUE&#39;)
                cue = np.hstack((np.nan, data_dict[&#39;parameters&#39;][:,p]))
                self.constants.CUE = cue[self._pft]
                npp_sum = gpp_sum * self.constants.CUE
                # Calculate daily litterfall based on the annual NPP sum
                self.constants.add(
                    npp_sum / self.DAYS_PER_YEAR, &#39;litterfall&#39;)

    def rh(self, state, drivers):
        &#39;&#39;&#39;
        Calculate heterotrophic respiration (RH) for a single time step.

        Parameters
        ----------
        state : numpy.ndarray
            `(3 x N x M)` array of current SOC state in each pool
        drivers : list or tuple
            Nested sequence of (driver: `numpy.ndarray`, label: `str`) pairs

        Returns
        -------
        numpy.ndarray
            Heterotrophic respiration (g C m-2 day-1)
        &#39;&#39;&#39;
        tsoil, smsf = drivers
        # NOTE: Converting from &#34;wetness&#34; to volumetric water content (VWC)
        #   (in % units); this requires multiplying (wetness * porosity) as
        #   (wetness = VWC / porosity)
        vwc = 100 * np.multiply(smsf / 100, self._porosity)
        damm = self.DAMM(self._rh_params, self.SOIL_DEPTH_CM)
        # Convert SOC from g m-2 to g cm-3
        substrate = [
            np.array(s)
            for s in g_cm3_to_g_m2(state, self.SOIL_DEPTH_CM).tolist()
        ]
        rh = np.stack(
            damm.respiration(substrate, vwc, tsoil, self._porosity), axis = 0)
        if self._debug:
            conc_Sx, conc_O2 = damm.concentrations(
                substrate, vwc, self._porosity)
            v_max = np.stack([ # alpha0, alpha1, and alpha2 are first 3 params
                damm.v_max(tsoil, a) for a in self._rh_params[0:3]
            ], axis = 0)
        else:
            conc_Sx, conc_O2, v_max = (None, None, None)
        # &#34;the adjustment...to account for material transferred into the
        #   slow pool during humification&#34; (Jones et al. 2017 TGARS, p.5)
        rh[1,...] = rh[1,...] * (1 - self.constants.f_structural)
        return (rh, conc_Sx, conc_O2, v_max)

    def run(self, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: None)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, fields_gpp, fields_rh):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve initial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            gpp, e_mult = self.gpp(
                zip(hdf.index(t + self._t0, *fields_gpp), fields_gpp))
            rh, conc_Sx, conc_O2, v_max = self.rh(
                state, hdf.index(t + self._t0, *fields_rh))
            npp = gpp * self.constants.CUE
            d_soc = self.soc(rh)
            # Record fluxes for this time step
            self.fluxes.update(&#39;gpp&#39;, t, gpp)
            self.fluxes.update(&#39;rh&#39;, t, rh.sum(axis = 0))
            self.fluxes.update(&#39;nee&#39;, t, rh.sum(axis = 0) - npp)
            if self._debug:
                self.state.update(&#39;conc_Sx&#39;, t, conc_Sx.sum(axis = 0))
                self.state.update(&#39;conc_O2&#39;, t, conc_O2)
                km_s = km_s_int + (km_s_slope * hdf.index(t + self._t0, &#39;tsoil&#39;)[0])
                self.state.update(&#39;mm_Sx&#39;, t, (conc_Sx / (km_s + conc_Sx)).min(axis = 0))
                self.state.update(&#39;mm_O2&#39;, t, conc_O2 / (km_O2 + conc_O2))
                self.state.update(&#39;v_max&#39;, t,
                    np.multiply(self.V_MAX_SCALE, v_max).mean(axis = 0))
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

        if self._debug:
            # Read in the following parameter values in debug mode
            km_O2 = self._rh_params[self.DAMM.parameter_names.index(&#39;km_O2&#39;)]
            km_s_int = self._rh_params[self.DAMM.parameter_names.index(&#39;km_s_int&#39;)]
            km_s_slope = self._rh_params[self.DAMM.parameter_names.index(&#39;km_s_slope&#39;)]
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS) as hdf:
            fields_gpp = [&#39;apar&#39;, &#39;tmin&#39;, &#39;vpd&#39;, &#39;ft&#39;, &#39;smrz&#39;]
            fields_rh = [&#39;tsoil&#39;, &#39;smsf&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(t, fields_gpp, fields_rh)
                    self._time_idx += 1
                    progress.update(t)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CDAMM.DIAGNOSTICS_INDEX"><code class="name">var <span class="ident">DIAGNOSTICS_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CDAMM.PFT_CODES"><code class="name">var <span class="ident">PFT_CODES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CDAMM.SOIL_DEPTH_CM"><code class="name">var <span class="ident">SOIL_DEPTH_CM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CDAMM.STATE_INDEX"><code class="name">var <span class="ident">STATE_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CDAMM.V_MAX_SCALE"><code class="name">var <span class="ident">V_MAX_SCALE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CDAMM.rh"><code class="name flex">
<span>def <span class="ident">rh</span></span>(<span>self, state, drivers)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate heterotrophic respiration (RH) for a single time step.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd><code>(3 x N x M)</code> array of current SOC state in each pool</dd>
<dt><strong><code>drivers</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>Nested sequence of (driver: <code>numpy.ndarray</code>, label: <code>str</code>) pairs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>Heterotrophic respiration (g C m-2 day-1)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rh(self, state, drivers):
    &#39;&#39;&#39;
    Calculate heterotrophic respiration (RH) for a single time step.

    Parameters
    ----------
    state : numpy.ndarray
        `(3 x N x M)` array of current SOC state in each pool
    drivers : list or tuple
        Nested sequence of (driver: `numpy.ndarray`, label: `str`) pairs

    Returns
    -------
    numpy.ndarray
        Heterotrophic respiration (g C m-2 day-1)
    &#39;&#39;&#39;
    tsoil, smsf = drivers
    # NOTE: Converting from &#34;wetness&#34; to volumetric water content (VWC)
    #   (in % units); this requires multiplying (wetness * porosity) as
    #   (wetness = VWC / porosity)
    vwc = 100 * np.multiply(smsf / 100, self._porosity)
    damm = self.DAMM(self._rh_params, self.SOIL_DEPTH_CM)
    # Convert SOC from g m-2 to g cm-3
    substrate = [
        np.array(s)
        for s in g_cm3_to_g_m2(state, self.SOIL_DEPTH_CM).tolist()
    ]
    rh = np.stack(
        damm.respiration(substrate, vwc, tsoil, self._porosity), axis = 0)
    if self._debug:
        conc_Sx, conc_O2 = damm.concentrations(
            substrate, vwc, self._porosity)
        v_max = np.stack([ # alpha0, alpha1, and alpha2 are first 3 params
            damm.v_max(tsoil, a) for a in self._rh_params[0:3]
        ], axis = 0)
    else:
        conc_Sx, conc_O2, v_max = (None, None, None)
    # &#34;the adjustment...to account for material transferred into the
    #   slow pool during humification&#34; (Jones et al. 2017 TGARS, p.5)
    rh[1,...] = rh[1,...] * (1 - self.constants.f_structural)
    return (rh, conc_Sx, conc_O2, v_max)</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CDAMM.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, steps=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A forward run in serial over multiple time steps; currently works in
streaming mode ONLY.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>steps</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of time steps to run or None to run through the end of the
available time steps (exhaust driver data) (Default: None)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, steps = None):
    &#39;&#39;&#39;
    A forward run in serial over multiple time steps; currently works in
    streaming mode ONLY.

    Parameters
    ----------
    steps : int
        Number of time steps to run or None to run through the end of the
        available time steps (exhaust driver data) (Default: None)
    &#39;&#39;&#39;
    @suppress_warnings
    def step(t, fields_gpp, fields_rh):
        &#39;Calculate fluxes, new states for the next time step t&#39;
        if t == 0:
            # Retrieve initial SOC pool sizes
            state = self.state_initial[0:3,0,...]
        else:
            # Retrieve SOC in each pool from prior step
            state = self.state.data[0:3,t-1,...]
        # Calculate fluxes, new states
        gpp, e_mult = self.gpp(
            zip(hdf.index(t + self._t0, *fields_gpp), fields_gpp))
        rh, conc_Sx, conc_O2, v_max = self.rh(
            state, hdf.index(t + self._t0, *fields_rh))
        npp = gpp * self.constants.CUE
        d_soc = self.soc(rh)
        # Record fluxes for this time step
        self.fluxes.update(&#39;gpp&#39;, t, gpp)
        self.fluxes.update(&#39;rh&#39;, t, rh.sum(axis = 0))
        self.fluxes.update(&#39;nee&#39;, t, rh.sum(axis = 0) - npp)
        if self._debug:
            self.state.update(&#39;conc_Sx&#39;, t, conc_Sx.sum(axis = 0))
            self.state.update(&#39;conc_O2&#39;, t, conc_O2)
            km_s = km_s_int + (km_s_slope * hdf.index(t + self._t0, &#39;tsoil&#39;)[0])
            self.state.update(&#39;mm_Sx&#39;, t, (conc_Sx / (km_s + conc_Sx)).min(axis = 0))
            self.state.update(&#39;mm_O2&#39;, t, conc_O2 / (km_O2 + conc_O2))
            self.state.update(&#39;v_max&#39;, t,
                np.multiply(self.V_MAX_SCALE, v_max).mean(axis = 0))
        # Update the SOC state
        for p in range(1, 4):
            if t == 0:
                # At time t=0, we have no state to advance, so update
                #   the state at t=0 based on the initial state
                delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                self.state.update(
                    &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
            else:
                self.state.advance(
                    &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

    if self._debug:
        # Read in the following parameter values in debug mode
        km_O2 = self._rh_params[self.DAMM.parameter_names.index(&#39;km_O2&#39;)]
        km_s_int = self._rh_params[self.DAMM.parameter_names.index(&#39;km_s_int&#39;)]
        km_s_slope = self._rh_params[self.DAMM.parameter_names.index(&#39;km_s_slope&#39;)]
    with L4CStreamingInputDataset(
            self.file_path, self.CONSTANTS, self.BOUNDS) as hdf:
        fields_gpp = [&#39;apar&#39;, &#39;tmin&#39;, &#39;vpd&#39;, &#39;ft&#39;, &#39;smrz&#39;]
        fields_rh = [&#39;tsoil&#39;, &#39;smsf&#39;]
        num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
        with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
            for t in range(self._time_idx + 1, num_steps):
                step(t, fields_gpp, fields_rh)
                self._time_idx += 1
                progress.update(t)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain">constrain</a></code></li>
<li><code><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp">gpp</a></code></li>
<li><code><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint.soc" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.soc">soc</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition"><code class="flex name class">
<span>class <span class="ident">L4CEnhancedDecomposition</span></span>
<span>(</span><span>config, stream=True, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Variation on SMAP L4C model, with two improvements to the SOC deomposition
model:</p>
<ol>
<li>The RH sub-model is modified to include an O2 diffusion limitation.
Driver data are the same as for any L4C Science run, so additional
configuration data must be provided: "soc_data_path" and
"extra_parameters".</li>
<li>The SOC sub-model is modified to include a litterfall phenology.
Driver data are the same as for any L4C Science run, except that
litterfall is different.</li>
</ol>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of configuration parameters</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use <code>L4CStreamingInputDataset</code> instead of reading in all
driver data; this reduces memory use but increases I/O</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to print all output to stdout</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to store additional diagnostic information from each time step</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CEnhancedDecomposition(L4CPhenologyProcess):
    &#39;&#39;&#39;
    Variation on SMAP L4C model, with two improvements to the SOC deomposition
    model:

    1. The RH sub-model is modified to include an O2 diffusion limitation.
        Driver data are the same as for any L4C Science run, so additional
        configuration data must be provided: &#34;soc_data_path&#34; and
        &#34;extra_parameters&#34;.
    2. The SOC sub-model is modified to include a litterfall phenology.
        Driver data are the same as for any L4C Science run, except that
        litterfall is different.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    stream : bool
        True to use `L4CStreamingInputDataset` instead of reading in all
        driver data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    PFT_CODES = range(1, 9)
    DIAGNOSTICS_INDEX = (&#39;f_tsoil&#39;, &#39;f_smsf&#39;, &#39;conc_O2&#39;, &#39;mm_O2&#39;)
    STATE_INDEX = (&#39;soc1&#39;, &#39;soc2&#39;, &#39;soc3&#39;)
    AIR_FRAC_O2 = 0.2095 # Liters of O2 per liter of air (20.95%)

    def __init__(
            self, config, stream = True, verbose = True, debug = False):
        super().__init__(
            config = config, stream = stream, verbose = verbose, debug = debug)
        # For the litterfall phenology: It is necessary to have a way to look
        #   up the day of year for indexing the litterfall array, which is
        #   (365 x N x 81)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            dt = [datetime.date(*t[:-1]) for t in hdf[&#39;time&#39;][:].tolist()]
            self._doy = ordinals365(dt)
        # For the O2 diffusion limit: Read in porosity, copy to 1-km subgrid
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            self._porosity = hdf[&#39;state/porosity&#39;][:][:,np.newaxis]\
                .repeat(81, axis = 1)

    def concentration_O2(self, soil_vwc):
        &#39;&#39;&#39;
        Concentration of O2 given soil vegetation water content (VWC).

        Parameters
        ----------
        soil_vwc : float or numpy.ndarray
            The soil moisture volumetric water content (m3 m-3)

        Returns
        -------
        float or numpy.ndarray
            The O2 concentration in soil pore spaces (dimensionless, L L-1)
        &#39;&#39;&#39;
        d_gas = self._extra_params[&#39;d_gas&#39;]
        return d_gas * self.AIR_FRAC_O2 * np.power(
            self._porosity - soil_vwc, 4/3)

    def rh(self, state, drivers):
        &#39;&#39;&#39;
        Calculate heterotrophic respiration (RH) for a single time step.

        Parameters
        ----------
        state : numpy.ndarray
            `(3 x N x M)` array of current SOC state in each pool
        drivers : list or tuple
            Nested sequence of (driver: `numpy.ndarray`, label: `str`) pairs

        Returns
        -------
        numpy.ndarray
            Heterotrophic respiration (g C m-2 day-1)
        &#39;&#39;&#39;
        # Translate Tsoil and SMSF into environmental constraints on RH
        tsoil, smsf = drivers
        f_tsoil = self.constrain(*tsoil)
        f_smsf = self.constrain(*smsf)
        smsf, _ = smsf # Pop off the label &#34;smsf&#34; and just get the data
        # NOTE: Converting from &#34;wetness&#34; to volumetric water content (VWC)
        #   (in % units); this requires multiplying (wetness * porosity) as
        #   (wetness = VWC / porosity)
        soil_vwc = np.multiply(smsf / 100, self._porosity)
        conc_O2 = self.concentration_O2(soil_vwc)
        mm_O2 = conc_O2 / (self._extra_params[&#39;km_oxy&#39;] + conc_O2)
        # Take the minimum of the SMSF and Soil VWC constraint
        k_mult = f_tsoil * np.min(np.stack((f_smsf, mm_O2)), axis = 0)
        k_mult = k_mult[np.newaxis,...].repeat(3, axis = 0)
        # NOTE: These are true decay rates for 2nd and 3rd pools, so it
        #   is straightforward to multiply them against SOC
        rh = k_mult * self.constants.decay_rates * state
        # &#34;the adjustment...to account for material transferred into the
        #   slow pool during humification&#34; (Jones et al. 2017 TGARS, p.5)
        rh[1,...] = rh[1,...] * (1 - self.constants.f_structural)
        # T_mult, W_mult same for each pool
        return (rh, (f_tsoil, f_smsf, conc_O2, mm_O2))

    def run(self, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: `None`)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, fields_gpp, fields_rh):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve initial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            gpp, e_mult = self.gpp(
                zip(hdf.index(t + self._t0, *fields_gpp), fields_gpp))
            rh, rh_diag = self.rh(
                state, zip(hdf.index(t + self._t0, *fields_rh), fields_rh))
            npp = gpp * self.constants.CUE
            d_soc = self.soc(rh, t + self._t0)
            # Record fluxes for this time step
            self.fluxes.update(&#39;gpp&#39;, t, gpp)
            self.fluxes.update(&#39;rh&#39;, t, rh.sum(axis = 0))
            self.fluxes.update(&#39;nee&#39;, t, rh.sum(axis = 0) - npp)
            if self._debug:
                f_tsoil, f_smsf, conc_O2, mm_O2 = rh_diag
                self.state.update(&#39;f_tsoil&#39;, t, f_tsoil)
                self.state.update(&#39;f_smsf&#39;, t, f_smsf)
                self.state.update(&#39;conc_O2&#39;, t, conc_O2)
                self.state.update(&#39;mm_O2&#39;, t, mm_O2)
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS) as hdf:
            fields_gpp = [&#39;apar&#39;, &#39;tmin&#39;, &#39;vpd&#39;, &#39;ft&#39;, &#39;smrz&#39;]
            fields_rh = [&#39;tsoil&#39;, &#39;smsf&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(t, fields_gpp, fields_rh)
                    self._time_idx += 1
                    progress.update(t)

    def soc(self, rh, t):
        &#39;&#39;&#39;
        Calculate change in soil organic carbon (SOC) for a single time step.

        Parameters
        ----------
        rh : numpy.ndarray
            `(3 x N x M)` array of RH at the current time step
        t : int
            Current time step

        Returns
        -------
        numpy.ndarray
        &#39;&#39;&#39;
        # Change in SOC according to diff. eq. in Jones et al. (2017)
        doy = self._doy[t] - 1 # Get DOY on [1,365] then on [0,364] for Python
        litter = self.constants.litterfall[doy,...]
        dc1 = (litter * self.constants.f_metabolic) - rh[0,...]
        dc2 = (litter * (1 - self.constants.f_metabolic)) - rh[1,...]
        dc3 = (self.constants.f_structural * rh[1,...]) - rh[2,...]
        return (dc1, dc2, dc3)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.phenology.L4CPhenologyProcess" href="phenology.html#pyl4c.apps.l4c.extensions.phenology.L4CPhenologyProcess">L4CPhenologyProcess</a></li>
<li><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.AIR_FRAC_O2"><code class="name">var <span class="ident">AIR_FRAC_O2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.DIAGNOSTICS_INDEX"><code class="name">var <span class="ident">DIAGNOSTICS_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.PFT_CODES"><code class="name">var <span class="ident">PFT_CODES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.STATE_INDEX"><code class="name">var <span class="ident">STATE_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.concentration_O2"><code class="name flex">
<span>def <span class="ident">concentration_O2</span></span>(<span>self, soil_vwc)</span>
</code></dt>
<dd>
<div class="desc"><p>Concentration of O2 given soil vegetation water content (VWC).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>soil_vwc</code></strong> :&ensp;<code>float</code> or <code>numpy.ndarray</code></dt>
<dd>The soil moisture volumetric water content (m3 m-3)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code> or <code>numpy.ndarray</code></dt>
<dd>The O2 concentration in soil pore spaces (dimensionless, L L-1)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concentration_O2(self, soil_vwc):
    &#39;&#39;&#39;
    Concentration of O2 given soil vegetation water content (VWC).

    Parameters
    ----------
    soil_vwc : float or numpy.ndarray
        The soil moisture volumetric water content (m3 m-3)

    Returns
    -------
    float or numpy.ndarray
        The O2 concentration in soil pore spaces (dimensionless, L L-1)
    &#39;&#39;&#39;
    d_gas = self._extra_params[&#39;d_gas&#39;]
    return d_gas * self.AIR_FRAC_O2 * np.power(
        self._porosity - soil_vwc, 4/3)</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.rh"><code class="name flex">
<span>def <span class="ident">rh</span></span>(<span>self, state, drivers)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate heterotrophic respiration (RH) for a single time step.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd><code>(3 x N x M)</code> array of current SOC state in each pool</dd>
<dt><strong><code>drivers</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>Nested sequence of (driver: <code>numpy.ndarray</code>, label: <code>str</code>) pairs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>Heterotrophic respiration (g C m-2 day-1)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rh(self, state, drivers):
    &#39;&#39;&#39;
    Calculate heterotrophic respiration (RH) for a single time step.

    Parameters
    ----------
    state : numpy.ndarray
        `(3 x N x M)` array of current SOC state in each pool
    drivers : list or tuple
        Nested sequence of (driver: `numpy.ndarray`, label: `str`) pairs

    Returns
    -------
    numpy.ndarray
        Heterotrophic respiration (g C m-2 day-1)
    &#39;&#39;&#39;
    # Translate Tsoil and SMSF into environmental constraints on RH
    tsoil, smsf = drivers
    f_tsoil = self.constrain(*tsoil)
    f_smsf = self.constrain(*smsf)
    smsf, _ = smsf # Pop off the label &#34;smsf&#34; and just get the data
    # NOTE: Converting from &#34;wetness&#34; to volumetric water content (VWC)
    #   (in % units); this requires multiplying (wetness * porosity) as
    #   (wetness = VWC / porosity)
    soil_vwc = np.multiply(smsf / 100, self._porosity)
    conc_O2 = self.concentration_O2(soil_vwc)
    mm_O2 = conc_O2 / (self._extra_params[&#39;km_oxy&#39;] + conc_O2)
    # Take the minimum of the SMSF and Soil VWC constraint
    k_mult = f_tsoil * np.min(np.stack((f_smsf, mm_O2)), axis = 0)
    k_mult = k_mult[np.newaxis,...].repeat(3, axis = 0)
    # NOTE: These are true decay rates for 2nd and 3rd pools, so it
    #   is straightforward to multiply them against SOC
    rh = k_mult * self.constants.decay_rates * state
    # &#34;the adjustment...to account for material transferred into the
    #   slow pool during humification&#34; (Jones et al. 2017 TGARS, p.5)
    rh[1,...] = rh[1,...] * (1 - self.constants.f_structural)
    # T_mult, W_mult same for each pool
    return (rh, (f_tsoil, f_smsf, conc_O2, mm_O2))</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, steps=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A forward run in serial over multiple time steps; currently works in
streaming mode ONLY.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>steps</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of time steps to run or None to run through the end of the
available time steps (exhaust driver data) (Default: <code>None</code>)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, steps = None):
    &#39;&#39;&#39;
    A forward run in serial over multiple time steps; currently works in
    streaming mode ONLY.

    Parameters
    ----------
    steps : int
        Number of time steps to run or None to run through the end of the
        available time steps (exhaust driver data) (Default: `None`)
    &#39;&#39;&#39;
    @suppress_warnings
    def step(t, fields_gpp, fields_rh):
        &#39;Calculate fluxes, new states for the next time step t&#39;
        if t == 0:
            # Retrieve initial SOC pool sizes
            state = self.state_initial[0:3,0,...]
        else:
            # Retrieve SOC in each pool from prior step
            state = self.state.data[0:3,t-1,...]
        # Calculate fluxes, new states
        gpp, e_mult = self.gpp(
            zip(hdf.index(t + self._t0, *fields_gpp), fields_gpp))
        rh, rh_diag = self.rh(
            state, zip(hdf.index(t + self._t0, *fields_rh), fields_rh))
        npp = gpp * self.constants.CUE
        d_soc = self.soc(rh, t + self._t0)
        # Record fluxes for this time step
        self.fluxes.update(&#39;gpp&#39;, t, gpp)
        self.fluxes.update(&#39;rh&#39;, t, rh.sum(axis = 0))
        self.fluxes.update(&#39;nee&#39;, t, rh.sum(axis = 0) - npp)
        if self._debug:
            f_tsoil, f_smsf, conc_O2, mm_O2 = rh_diag
            self.state.update(&#39;f_tsoil&#39;, t, f_tsoil)
            self.state.update(&#39;f_smsf&#39;, t, f_smsf)
            self.state.update(&#39;conc_O2&#39;, t, conc_O2)
            self.state.update(&#39;mm_O2&#39;, t, mm_O2)
        # Update the SOC state
        for p in range(1, 4):
            if t == 0:
                # At time t=0, we have no state to advance, so update
                #   the state at t=0 based on the initial state
                delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                self.state.update(
                    &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
            else:
                self.state.advance(
                    &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))
    with L4CStreamingInputDataset(
            self.file_path, self.CONSTANTS, self.BOUNDS) as hdf:
        fields_gpp = [&#39;apar&#39;, &#39;tmin&#39;, &#39;vpd&#39;, &#39;ft&#39;, &#39;smrz&#39;]
        fields_rh = [&#39;tsoil&#39;, &#39;smsf&#39;]
        num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
        with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
            for t in range(self._time_idx + 1, num_steps):
                step(t, fields_gpp, fields_rh)
                self._time_idx += 1
                progress.update(t)</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.soc"><code class="name flex">
<span>def <span class="ident">soc</span></span>(<span>self, rh, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate change in soil organic carbon (SOC) for a single time step.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rh</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd><code>(3 x N x M)</code> array of RH at the current time step</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>int</code></dt>
<dd>Current time step</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soc(self, rh, t):
    &#39;&#39;&#39;
    Calculate change in soil organic carbon (SOC) for a single time step.

    Parameters
    ----------
    rh : numpy.ndarray
        `(3 x N x M)` array of RH at the current time step
    t : int
        Current time step

    Returns
    -------
    numpy.ndarray
    &#39;&#39;&#39;
    # Change in SOC according to diff. eq. in Jones et al. (2017)
    doy = self._doy[t] - 1 # Get DOY on [1,365] then on [0,364] for Python
    litter = self.constants.litterfall[doy,...]
    dc1 = (litter * self.constants.f_metabolic) - rh[0,...]
    dc2 = (litter * (1 - self.constants.f_metabolic)) - rh[1,...]
    dc3 = (self.constants.f_structural * rh[1,...]) - rh[2,...]
    return (dc1, dc2, dc3)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.extensions.phenology.L4CPhenologyProcess" href="phenology.html#pyl4c.apps.l4c.extensions.phenology.L4CPhenologyProcess">L4CPhenologyProcess</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.phenology.L4CPhenologyProcess.constrain" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain">constrain</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.phenology.L4CPhenologyProcess.gpp" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp">gpp</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="SMAP Mission Homepage" href="https://smap.jpl.nasa.gov/">
<img src="https://arthur-e.github.io/pyl4c/templates/images/logo_SMAP.jpg" alt="">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyl4c.apps.l4c.extensions" href="index.html">pyl4c.apps.l4c.extensions</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CDAMM" href="#pyl4c.apps.l4c.extensions.coupling.L4CDAMM">L4CDAMM</a></code></h4>
<ul class="two-column">
<li><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CDAMM.DIAGNOSTICS_INDEX" href="#pyl4c.apps.l4c.extensions.coupling.L4CDAMM.DIAGNOSTICS_INDEX">DIAGNOSTICS_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CDAMM.PFT_CODES" href="#pyl4c.apps.l4c.extensions.coupling.L4CDAMM.PFT_CODES">PFT_CODES</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CDAMM.SOIL_DEPTH_CM" href="#pyl4c.apps.l4c.extensions.coupling.L4CDAMM.SOIL_DEPTH_CM">SOIL_DEPTH_CM</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CDAMM.STATE_INDEX" href="#pyl4c.apps.l4c.extensions.coupling.L4CDAMM.STATE_INDEX">STATE_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CDAMM.V_MAX_SCALE" href="#pyl4c.apps.l4c.extensions.coupling.L4CDAMM.V_MAX_SCALE">V_MAX_SCALE</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CDAMM.rh" href="#pyl4c.apps.l4c.extensions.coupling.L4CDAMM.rh">rh</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CDAMM.run" href="#pyl4c.apps.l4c.extensions.coupling.L4CDAMM.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition" href="#pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition">L4CEnhancedDecomposition</a></code></h4>
<ul class="two-column">
<li><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.AIR_FRAC_O2" href="#pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.AIR_FRAC_O2">AIR_FRAC_O2</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.DIAGNOSTICS_INDEX" href="#pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.DIAGNOSTICS_INDEX">DIAGNOSTICS_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.PFT_CODES" href="#pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.PFT_CODES">PFT_CODES</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.STATE_INDEX" href="#pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.STATE_INDEX">STATE_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.concentration_O2" href="#pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.concentration_O2">concentration_O2</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.rh" href="#pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.rh">rh</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.run" href="#pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.run">run</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.soc" href="#pyl4c.apps.l4c.extensions.coupling.L4CEnhancedDecomposition.soc">soc</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>