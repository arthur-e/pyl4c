<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyl4c.apps.l4c.extensions.damm API documentation</title>
<meta name="description" content="The Dual Arrhenius Michaelis-Menten (DAMM) soil decomposition model (from
Davidson et al. 2012) …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:35%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyl4c.apps.l4c.extensions.damm</code></h1>
</header>
<section id="section-intro">
<p>The Dual Arrhenius Michaelis-Menten (DAMM) soil decomposition model (from
Davidson et al. 2012).</p>
<p><span><span class="MathJax_Preview">
R_H = V_{\mathrm{max}}\, \frac{S_X}{K_{M_S} + S_X} \frac{O_2}{K_{M_{O_2}} + O_2}
</span><script type="math/tex; mode=display">
R_H = V_{\mathrm{max}}\, \frac{S_X}{K_{M_S} + S_X} \frac{O_2}{K_{M_{O_2}} + O_2}
</script></span></p>
<p>NOTE: The only term in the equation that is not unitless (either intrinsically
or because the units cancel out) is <code>V_max</code>; therefore, the units of alpha,
which determine the units of <code>V_max</code>, ultimately determine the units of
respiration.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">r&#39;&#39;&#39;
The Dual Arrhenius Michaelis-Menten (DAMM) soil decomposition model (from
Davidson et al. 2012).

$$
R_H = V_{\mathrm{max}}\, \frac{S_X}{K_{M_S} + S_X} \frac{O_2}{K_{M_{O_2}} + O_2}
$$

NOTE: The only term in the equation that is not unitless (either intrinsically
or because the units cancel out) is `V_max`; therefore, the units of alpha,
which determine the units of `V_max`, ultimately determine the units of
respiration.
&#39;&#39;&#39;

import numpy as np
from pyl4c import Namespace

class AbstractDAMM(object):
    &#39;&#39;&#39;
    Abstract Dual Arrhenius Michaelis-Menten (DAMM) model framework. Not
    intended for end-user instantiation.
    &#39;&#39;&#39;
    def cbar0(self, litterfall, soil_m, soil_t, porosity, fmet, fstr):
        &#39;&#39;&#39;
        An alternative method for estimating the initital C pool sizes, this
        analytical approaches solves for C storage after setting the
        differential equation governing change in C to zero. See README for
        the equations. The C storage magnitudes tend to be higher because
        `V_max` is very small compared to litterfall, leading to very large
        empirical C storage estimates.

        Parameters
        ----------
        litterfall : numpy.ndarray
            Average daily litterfall [g C cm-3 day-1]
        soil_m : numpy.ndarray
            365-day soil moisture (%) climatology (365 x N ...)
        soil_t : numpy.ndarray
            365-day soil temperature (°K) climatology (365 x N ...)
        porosity : numpy.ndarray
            Total porosity, between [0, 1]
        fmet : float
            Fraction of daily litterfall entering metabolic pool
        fstr : float
            Fraction of structural pool transferred to the recalcitrant pool
            during &#34;humification&#34;

        Returns
        -------
        tuple
            (c0, c1, c2) numpy.ndarray instances, one for each of the
            steady-state C pools (Units: g cm-3)
        &#39;&#39;&#39;
        # Calculate the DAMM parameters needed in the steady-state C eq.
        alpha0, alpha1, alpha2, p, d_liq = (
            self.get(p)
            for p in (&#39;alpha0&#39;, &#39;alpha1&#39;, &#39;alpha2&#39;, &#39;p&#39;, &#39;d_liq&#39;)
        )
        try:
            km_s = self.params[self.labels.index(&#39;km_s&#39;)]
        except ValueError:
            km_s_int, km_s_slope = (
                self.get(p)
                for p in (&#39;km_s_int&#39;, &#39;km_s_slope&#39;)
            )
            km_s = km_s_int + (km_s_slope * soil_t)

        # Convert from [Mg C cm-3 hr-1] to [g C cm-3 day-1]
        vmax0 = self.v_max(soil_t, alpha0) * 1e6 * 24
        vmax1 = self.v_max(soil_t, alpha1) * 1e6 * 24
        vmax2 = self.v_max(soil_t, alpha2) * 1e6 * 24
        _, conc_O2 = self.concentrations(np.nan, soil_m, porosity)
        mm_O2 = conc_O2 / (self.get(&#39;km_O2&#39;) + conc_O2)
        sx_coef = np.multiply(p * d_liq, np.power(soil_m / 100, 3))
        c0 = (litterfall * fmet * km_s) / (sx_coef * (
            (vmax0 * mm_O2) - (litterfall * fmet)))
        c1 = (litterfall * (1 - fmet) * km_s) / (sx_coef * (
            (vmax1 * mm_O2) - (litterfall * (1 - fmet))))
        c2 = -(vmax1 * c1 * fstr * km_s) / (
            (sx_coef * (((vmax1 * c1 * fstr) + (vmax2 * c1)))) + (vmax2 * km_s))
        substrate_by_pool = []
        # Empirical C is now the steady-state value for each day of the
        #   climatological year; calculate the daily average
        for empirical_C in (c0, c1, c2):
            # Calculate mean across 365 days
            substrate_by_pool.append(np.nanmean(
                np.where(empirical_C &lt; 0, 0, empirical_C), axis = 0))
        return substrate_by_pool

    def cbar(self, rh, soil_m, soil_t, porosity, perc = 80):
        r&#39;&#39;&#39;
        As in the L4C calibration, calculate the empirical C storage, based on
        observed RH, since we don&#39;t yet know how much C we have to burn. Note
        that this SINGLE value per (flux tower) site is used as a &#34;constant
        effective SOC factor&#34; (Jones et al. 2017) throughout calibration, for
        every time step. This is because C substrate pools are assumed to be
        in the steady state for calibration. The empirical C storage
        magnitudes estimated by this function compare well with the
        SoilGrids 250m global 0-5 cm SOC density estimates of 10-60 kg m-2.

        $$
        \bar{C} = \frac{R_H\, k_{M_{S_x}}}{(p\, D_{\mathrm{liq}}\, \theta^3)
            [V_{\mathrm{max}}\, [O_2](k_{M_{O_2}} + [O_2])^{-1} - R_H]}
        $$

        Parameters
        ----------
        rh : numpy.ndarray
            RH in g C m-2 day-1
        soil_m : numpy.ndarray
            Soil moisture (%)
        soil_t : numpy.ndarray
            Soil temperature (°K)
        porosity : numpy.ndarray
            Total porosity, between [0, 1]
        perc : int or float
            Empirical Cbar percentile to return

        Returns
        -------
        tuple
            (c0, c1, c2) numpy.ndarray instances, one for each of the
            steady-state C pools (Units: g cm-3)
        &#39;&#39;&#39;
        # Calculate the DAMM parameters needed in the steady-state C eq.
        alpha0, alpha1, alpha2, ea, p, d_liq = (
            self.get(p)
            for p in (&#39;alpha0&#39;, &#39;alpha1&#39;, &#39;alpha2&#39;, &#39;ea&#39;, &#39;p&#39;, &#39;d_liq&#39;)
        )
        try:
            km_s = self.params[self.labels.index(&#39;km_s&#39;)]
        except ValueError:
            km_s_int, km_s_slope = (
                self.get(p)
                for p in (&#39;km_s_int&#39;, &#39;km_s_slope&#39;)
            )
            km_s = km_s_int + (km_s_slope * soil_t)

        # Let&#39;s do this in the units of km_s, because substrate is needed
        #   in these units (g C cm-3)
        #   -- rh is in g m-2 day-1
        #   -- km_s is in g cm-3
        #   -- v_max is in Mg cm-3 hr-1
        # Calculate coefficients for substrate concentration
        sx_coef = np.multiply(p * d_liq, np.power(soil_m / 100, 3))
        # Calculate oxygen concentration at reaction site; then MM constraint
        _, conc_O2 = self.concentrations(np.nan, soil_m, porosity)
        mm_O2 = conc_O2 / (self.get(&#39;km_O2&#39;) + conc_O2) # (dimensionless)
        # Convert g C m-2 to g C m-3, then denominator from m-3 to cm-3
        rh = (rh / self.constants.soil_depth_m) / 1e6
        # Estimate each soil C pool (differentiated by base rate or alpha)
        substrate_by_pool = []
        for alpha in (alpha0, alpha1, alpha2):
            v_max_i = self.v_max(soil_t, alpha, ea) # Calculate base rate
            v_max_i = (v_max_i * 1e6) # Convert Mg C to g C
            empirical_C = np.divide(
                np.multiply(rh, km_s),
                np.multiply(sx_coef, np.subtract( # Hourly to daily Vmax
                    np.multiply(v_max_i * 24, mm_O2), rh)))
            # This empirical approach may result in C values &lt; 0; assign 0
            substrate_by_pool.append(
                np.nanpercentile(
                    np.where(empirical_C &lt; 0, 0, empirical_C), perc, axis = 0))
        return substrate_by_pool

    def concentrations(self, substrate, soil_m, porosity):
        &#39;&#39;&#39;
        For a single C pool, returns substrate and oxygen concentrations.
        Units for C substrate are g C cm-3 (same as input argument) and units
        for O2 are dimensionless--essentially, it&#39;s `d_gas` times the proportion
        of total volume (soil + water + air) occupied by O2.

        Parameters
        ----------
        substrate : numpy.ndarray
            Soil C substrate (g cm-3)
        soil_m : numpy.ndarray
            Soil moisture (%)
        porosity : numpy.ndarray
            Total porosity, between [0, 1]

        Returns
        -------
        tuple
            `(conc_Sx, conc_O2)` where `conc_Sx` is the concentration of
            substrate, `conc_O2` is the concentration of O2
        &#39;&#39;&#39;
        air_frac_O2 = 0.2095 # L O2 L-1 air (20.95%)
        p = self.get(&#39;p&#39;)
        d_liq = self.get(&#39;d_liq&#39;)
        d_gas = self.get(&#39;d_gas&#39;)
        # Calculate substrate concentration at reaction site
        conc_Sx = np.multiply(substrate,
            np.multiply(p * d_liq, np.power(soil_m / 100, 3)))
        # Calculate oxygen concentration at reaction site; then MM constraint
        a = (porosity - (soil_m / 100))
        conc_O2 = d_gas * air_frac_O2 * np.power(np.where(a &lt; 0, 0, a), (4/3))
        return (conc_Sx, conc_O2)

    def get(self, parameter):
        &#39;&#39;&#39;
        Retrieves a parameter value whether it is fixed or a free parameter.
        This provides flexibility for versions of the model that may differ
        in free versus fixed parameters. Constants take precedence--if a value
        was fit but a constant value is found, the constant is used.

        Parameters
        ----------
        parameter : str
            Name of the parameter to retrieve
        &#39;&#39;&#39;
        if hasattr(self.constants, parameter):
            return getattr(self.constants, parameter)
        return self.params[self.labels.index(parameter)]

    def total_respiration(self, *args, **kwargs):
        &#39;&#39;&#39;
        Calculates the sum of respiration in each C pool. See `respiration()`.

        Returns
        -------
        numpy.ndarray
        &#39;&#39;&#39;
        rh = self.respiration(*args, **kwargs)
        respiration = np.zeros(rh[0].shape)
        for i in range(0, len(rh)):
            np.add(respiration, rh[i], out = respiration)
        return respiration

    def v_max(self, soil_t, alpha, ea = None):
        &#39;&#39;&#39;
        For a single C pool, returns maximum rate on enzymatic reaction in
        Mg C cm-3 hr-1. NOTE: Units of base rate (megagrams, Mg) are chosen
        to improve convergence in model fitting.

        Parameters
        ----------
        soil_t : numpy.ndarray
            Soil temperature (°K)
        alpha : numpy.ndarray
            Base rate/ pre-exponential factor (Mg C cm-3 hr-1)
        ea : numpy.ndarray
            Activation energy (kJ mol-1)

        Returns
        -------
        numpy.ndarray
        &#39;&#39;&#39;
        ea = self.get(&#39;ea&#39;) if ea is None else ea
        r_gas = 8.314472e-3 # Universal gas constant (kJ K-1 mol-1)
        return np.multiply( # Mg C cm-3 hr-1
            alpha, np.exp(-np.divide(ea, np.multiply(r_gas, soil_t))))


class DAMMDecompositionModel(AbstractDAMM):
    &#39;&#39;&#39;
    The DAMM decomposition model as reported by Davidson et al. (2012), with
    some changes: Support for multiple soil C pools; Additional free
    parameters (not bragging about it, these have to be fit); and Changed the
    units of the pre-exponential factor to better condition optimization.

    Free parameters are:

    - `alpha`: Pre-exponential factor of enzymatic reaction with `S_x`
               (Mg C cm-3 hr-1), note this is *Megagrams* of C...
    - `ea`:    Activation energy of enzymatic reaction with `S_x` (kJ mol-1)
    - `km_s`:  Michaelis-Menten coefficient for subtrate, using the constant-
               value form (g C cm-3)
    - `p`:     Proportion of `C_total` that is soluble
    - `d_liq`: Diffusion coefficient of substrate in liquid phase
    - `d_gas`: Diffusion coefficient of `O_2` in air

    NOTE: CUE is potentially another free parameter, but it has no relevance
    in running DAMM, only in fitting the model with unknown C storage/
    substrate.
    &#39;&#39;&#39;
    parameter_names = (
        &#39;alpha0&#39;, &#39;alpha1&#39;, &#39;alpha2&#39;, &#39;ea&#39;, &#39;km_s&#39;, &#39;p&#39;, &#39;d_liq&#39;, &#39;d_gas&#39;)

    def __init__(self, params = None, soil_depth_cm = 5, km_O2 = 0.121):
        self.constants = Namespace()
        self.constants.add(&#39;km_O2&#39;, km_O2)
        self.constants.add(&#39;soil_depth_cm&#39;, soil_depth_cm)
        self.constants.add(&#39;soil_depth_m&#39;, soil_depth_cm / 100)
        self.params = params
        if params is None:
            # Use parameters from Davidson et al. (2012)
            self.params = (53.8, 0, 0, 72.26, 9.95e-7, 4.14e-4, 3.17, 1.67, np.nan)

    def respiration(self, substrate, soil_m, soil_t, porosity):
        &#39;&#39;&#39;
        Calculates daily total RH for all soil pools, g C m-2 day-1.

        Parameters
        ----------
        substrate : numpy.ndarray
            Soil C substrate (g cm-3) in each pool (3-tuple)
        soil_m : numpy.ndarray
            Soil moisture (%)
        soil_t : numpy.ndarray
            Soil temperature (°K)
        porosity : numpy.ndarray
            Total porosity, between [0, 1]

        Returns
        -------
        tuple
            `(rh0, rh1, rh2)` numpy.ndarray instances, one for each of the
            C pools (Units: g m-2 day-1)
        &#39;&#39;&#39;
        assert len(substrate) == 3,\
            &#39;Need a substrate value for each of 3 pools&#39;
        alpha0, alpha1, alpha2, ea, km_s, p, d_liq = (
            self.params[i] for i in range(0, 7)
        )
        respiration = []
        for i, alpha_i in enumerate((alpha0, alpha1, alpha2)):
            v_max_i = self.v_max(soil_t, alpha_i, ea)
            sx_i, conc_O2 = self.concentrations(substrate[i], soil_m, porosity)
            # Calculate Michaelis-Menten coefficients
            mm_sx = sx_i / (km_s + sx_i) # Units (g C cm-3) cancel out (dimensionless)
            mm_O2 = conc_O2 / (self.constants.km_O2 + conc_O2) # (dimensionless)
            rh = v_max_i * mm_sx * mm_O2 # Mg C cm-3 hr-1; need g C m-2 day-1
            # First convert Mg C to g C, then cm-3 to cm-2, then from
            #   cm-2 to m-2, then from hourly to a daily flux (24 hours/ day)
            resp = (((1e6 * rh) * self.constants.soil_depth_cm) * 1e4) * 24
            respiration.append(np.where(resp &lt; 0, 0, resp))
        return respiration


class DAMMDecompositionModel2(AbstractDAMM):
    &#39;&#39;&#39;
    The DAMM decomposition model as reported by Davidson et al. (2012), with
    some changes: Support for multiple soil C pools; Additional free
    parameters (not bragging about it, these have to be fit); and Changed the
    units of the pre-exponential factor to better condition optimization.
    This model assumes that the Michaelis-Menten coefficient for substrate is
    *not constant* w.r.t. temperature (the slope-intercept form of km_s). It
    also allows any free parameter to be specified as a constant.

    Free parameters are:

    - `alpha`:      Pre-exponential factor of enzymatic reaction with `S_x`
                    (Mg C cm-3 hr-1), note this is *Megagrams* of C...
    - `ea`:         Activation energy of enzymatic reaction with `S_x`
                    (kJ mol-1)
    - `km_s_int`:   Intercept of Michaelis-Menten (MM) coefficient for
                    substrate (g C cm-3)
    - `km_s_slope`: Slope of Michaelis-Menten (MM) coefficient for
                    substrate (g C cm-3 K-1)
    - `p`:          Proportion of `C_total` that is soluble
    - `d_liq`:      Diffusion coefficient of substrate in liquid phase
    - `d_gas`:      Diffusion coefficient of `O_2` in air
    - `km_O2`:      Half-saturation (MM) coefficient for diffusion of O2

    NOTE: CUE is potentially another free parameter, but it has no relevance
    in running DAMM, only in fitting the model with unknown C storage/
    substrate.
    &#39;&#39;&#39;
    parameter_names = (
        &#39;alpha0&#39;, &#39;alpha1&#39;, &#39;alpha2&#39;, &#39;ea&#39;, &#39;km_s_int&#39;, &#39;km_s_slope&#39;,
        &#39;p&#39;, &#39;d_liq&#39;, &#39;d_gas&#39;, &#39;km_O2&#39;)

    def __init__(self, params, soil_depth_cm = 5, **kwargs):
        self.constants = Namespace()
        self.constants.add(&#39;soil_depth_cm&#39;, soil_depth_cm)
        self.constants.add(&#39;soil_depth_m&#39;, soil_depth_cm / 100)
        self.labels = list(self.parameter_names).copy()
        self.params = params
        for key, value in kwargs.items():
            self.constants.add(key, value)
            # Don&#39;t allow constants to appear in the parameters list
            if key in self.labels:
                # May need to re-build parameters list
                self.labels.remove(key)
        for name in self.parameter_names:
            assert name in self.labels or hasattr(self.constants, name),\
                &#39;Required parameter &#34;%s&#34; must be specified either as a constant nor a free parameter&#39; % name

    def respiration(self, substrate, soil_m, soil_t, porosity):
        &#39;&#39;&#39;
        Calculates daily total RH for all soil pools, g C m-2 day-1.

        Parameters
        ----------
        substrate : numpy.ndarray
            Soil C substrate (g cm-3) in each pool (3-tuple)
        soil_m : numpy.ndarray
            Soil moisture (%)
        soil_t : numpy.ndarray
            Soil temperature (°K)
        porosity : numpy.ndarray
            Total porosity, between [0, 1]

        Returns
        -------
        tuple
            (rh0, rh1, rh2) numpy.ndarray instances, one for each of the
            C pools (Units: g m-2 day-1)
        &#39;&#39;&#39;
        assert len(substrate) == 3,\
            &#39;Need a substrate value for each of 3 pools&#39;
        alpha0, alpha1, alpha2, ea, km_s_int, km_s_slope = (
            self.params[i] for i in range(0, 6)
        )
        respiration = []
        for i, a_i in enumerate((alpha0, alpha1, alpha2)):
            v_max_i = self.v_max(soil_t, a_i, ea)
            sx_i, conc_O2 = self.concentrations(
                np.array(substrate[i]), soil_m, porosity)
            # Calculate Michaelis-Menten coefficients
            km_s = km_s_int + (km_s_slope * soil_t)
            mm_sx = sx_i / (km_s + sx_i) # Units (g C cm-3) cancel out
            mm_O2 = conc_O2 / (self.get(&#39;km_O2&#39;) + conc_O2) # (dim.less)
            rh = v_max_i * mm_sx * mm_O2 # Mg C cm-3 hr-1
            # First convert Mg C to g C, then cm-3 to cm-2, then from
            #   cm-2 to m-2, then from hourly to a daily flux (24 hours/ day)
            resp = (((1e6 * rh) * self.constants.soil_depth_cm) * 1e4) * 24
            respiration.append(np.where(resp &lt; 0, 0, resp))
        return respiration


def g_m2_to_g_cm3(value, soil_depth_cm = 5):
    &#39;&#39;&#39;
    Converts flux/ SOC stock from g m-2 to g cm-3.

    Parameters
    ----------
    value : int or float
        Value in g m-2
    soil_depth_cm : int
        Depth of the soil, in centimeters

    Returns
    -------
    float
        Value in g cm-3
    &#39;&#39;&#39;
    return (value / (soil_depth_cm / 100)) / 1e6


def g_cm3_to_g_m2(value, soil_depth_cm = 5):
    &#39;&#39;&#39;
    Converts flux/ SOC stock from g cm-3 to g m-2.

    Parameters
    ----------
    value : int or float
        Value in g cm-3
    soil_depth_cm : int
        Depth of the soil, in centimeters

    Returns
    -------
    float
        Value in g m-2
    &#39;&#39;&#39;
    return (value * soil_depth_cm) * 1e4


if __name__ == &#39;__main__&#39;:
    # Test model implementation matches the description by Davidson et al.
    #   (2012, Table 3) by running...
    # Here we also show that the code is vectorized.
    substrate = (np.array(0.048).repeat(4).reshape((2,2)),
    np.zeros((2,2)), np.zeros((2,2)))
    soil_temp = np.array(273.15 + 37.7).repeat(4).reshape((2,2))
    soil_moisture = np.array(50).repeat(4).reshape((2,2))
    porosity = np.array(1 - (0.8 / 2.52)).repeat(4).reshape((2,2))

    damm = DAMMDecompositionModel(soil_depth_cm = 10)
    rh = damm.respiration(substrate, soil_moisture, soil_temp, porosity)
    assert np.all(rh[0].round(2) == 19.04), &#39;DAMMDecompositionModel: Failed test&#39;
    print(&#39;DAMMDecompositionModel: Passed test&#39;)

    # km_s_int = 0 # Back-solved for km_s_slope given km_s = 9.95e-7
    # km_s_slope = 3.2009e-09
    damm = DAMMDecompositionModel2(
        #        alpha        E_a   km_s_slope        p D_liq D_gas
        params = (53.8, 0, 0, 72.26, 0, 3.2e-9, 4.14e-4, 3.17, 1.67, np.nan),
        km_O2 = 0.121, soil_depth_cm = 10)
    rh = damm.respiration(substrate, soil_moisture, soil_temp, porosity)
    assert np.all(rh[0].round(2) == 19.04), &#39;DAMMDecompositionModel2: Failed test&#39;
    print(&#39;DAMMDecompositionModel2: Passed test&#39;)

    # Vectorization in parameters
    damm = DAMMDecompositionModel2(
        params = (
            np.array([53.8, 56.81]), np.array([0, 8.297]), np.array([0, 6.27e-2]),
            np.array([72.26, 71.13]), np.array([0, -6.28e-3]), np.array([3.2e-9, 2.34e-5]),
            np.array([4.14e-4, 0.126]), np.array([3.17, 23.309]), np.array([1.67, 4.648]),
            np.array([0.121, 8.367e-2])),
        soil_depth_cm = 10)
    rh = damm.respiration([0.048, 0, 0], 50, 310.85, 0.6825)
    assert np.all(rh[0].round(2) == 19.04), &#39;DAMMDecompositionModel2: Failed test&#39;
    print(&#39;DAMMDecompositionModel2: Passed test&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyl4c.apps.l4c.extensions.damm.g_cm3_to_g_m2"><code class="name flex">
<span>def <span class="ident">g_cm3_to_g_m2</span></span>(<span>value, soil_depth_cm=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts flux/ SOC stock from g cm-3 to g m-2.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Value in g cm-3</dd>
<dt><strong><code>soil_depth_cm</code></strong> :&ensp;<code>int</code></dt>
<dd>Depth of the soil, in centimeters</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Value in g m-2</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g_cm3_to_g_m2(value, soil_depth_cm = 5):
    &#39;&#39;&#39;
    Converts flux/ SOC stock from g cm-3 to g m-2.

    Parameters
    ----------
    value : int or float
        Value in g cm-3
    soil_depth_cm : int
        Depth of the soil, in centimeters

    Returns
    -------
    float
        Value in g m-2
    &#39;&#39;&#39;
    return (value * soil_depth_cm) * 1e4</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.extensions.damm.g_m2_to_g_cm3"><code class="name flex">
<span>def <span class="ident">g_m2_to_g_cm3</span></span>(<span>value, soil_depth_cm=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts flux/ SOC stock from g m-2 to g cm-3.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Value in g m-2</dd>
<dt><strong><code>soil_depth_cm</code></strong> :&ensp;<code>int</code></dt>
<dd>Depth of the soil, in centimeters</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Value in g cm-3</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g_m2_to_g_cm3(value, soil_depth_cm = 5):
    &#39;&#39;&#39;
    Converts flux/ SOC stock from g m-2 to g cm-3.

    Parameters
    ----------
    value : int or float
        Value in g m-2
    soil_depth_cm : int
        Depth of the soil, in centimeters

    Returns
    -------
    float
        Value in g cm-3
    &#39;&#39;&#39;
    return (value / (soil_depth_cm / 100)) / 1e6</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyl4c.apps.l4c.extensions.damm.AbstractDAMM"><code class="flex name class">
<span>class <span class="ident">AbstractDAMM</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract Dual Arrhenius Michaelis-Menten (DAMM) model framework. Not
intended for end-user instantiation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractDAMM(object):
    &#39;&#39;&#39;
    Abstract Dual Arrhenius Michaelis-Menten (DAMM) model framework. Not
    intended for end-user instantiation.
    &#39;&#39;&#39;
    def cbar0(self, litterfall, soil_m, soil_t, porosity, fmet, fstr):
        &#39;&#39;&#39;
        An alternative method for estimating the initital C pool sizes, this
        analytical approaches solves for C storage after setting the
        differential equation governing change in C to zero. See README for
        the equations. The C storage magnitudes tend to be higher because
        `V_max` is very small compared to litterfall, leading to very large
        empirical C storage estimates.

        Parameters
        ----------
        litterfall : numpy.ndarray
            Average daily litterfall [g C cm-3 day-1]
        soil_m : numpy.ndarray
            365-day soil moisture (%) climatology (365 x N ...)
        soil_t : numpy.ndarray
            365-day soil temperature (°K) climatology (365 x N ...)
        porosity : numpy.ndarray
            Total porosity, between [0, 1]
        fmet : float
            Fraction of daily litterfall entering metabolic pool
        fstr : float
            Fraction of structural pool transferred to the recalcitrant pool
            during &#34;humification&#34;

        Returns
        -------
        tuple
            (c0, c1, c2) numpy.ndarray instances, one for each of the
            steady-state C pools (Units: g cm-3)
        &#39;&#39;&#39;
        # Calculate the DAMM parameters needed in the steady-state C eq.
        alpha0, alpha1, alpha2, p, d_liq = (
            self.get(p)
            for p in (&#39;alpha0&#39;, &#39;alpha1&#39;, &#39;alpha2&#39;, &#39;p&#39;, &#39;d_liq&#39;)
        )
        try:
            km_s = self.params[self.labels.index(&#39;km_s&#39;)]
        except ValueError:
            km_s_int, km_s_slope = (
                self.get(p)
                for p in (&#39;km_s_int&#39;, &#39;km_s_slope&#39;)
            )
            km_s = km_s_int + (km_s_slope * soil_t)

        # Convert from [Mg C cm-3 hr-1] to [g C cm-3 day-1]
        vmax0 = self.v_max(soil_t, alpha0) * 1e6 * 24
        vmax1 = self.v_max(soil_t, alpha1) * 1e6 * 24
        vmax2 = self.v_max(soil_t, alpha2) * 1e6 * 24
        _, conc_O2 = self.concentrations(np.nan, soil_m, porosity)
        mm_O2 = conc_O2 / (self.get(&#39;km_O2&#39;) + conc_O2)
        sx_coef = np.multiply(p * d_liq, np.power(soil_m / 100, 3))
        c0 = (litterfall * fmet * km_s) / (sx_coef * (
            (vmax0 * mm_O2) - (litterfall * fmet)))
        c1 = (litterfall * (1 - fmet) * km_s) / (sx_coef * (
            (vmax1 * mm_O2) - (litterfall * (1 - fmet))))
        c2 = -(vmax1 * c1 * fstr * km_s) / (
            (sx_coef * (((vmax1 * c1 * fstr) + (vmax2 * c1)))) + (vmax2 * km_s))
        substrate_by_pool = []
        # Empirical C is now the steady-state value for each day of the
        #   climatological year; calculate the daily average
        for empirical_C in (c0, c1, c2):
            # Calculate mean across 365 days
            substrate_by_pool.append(np.nanmean(
                np.where(empirical_C &lt; 0, 0, empirical_C), axis = 0))
        return substrate_by_pool

    def cbar(self, rh, soil_m, soil_t, porosity, perc = 80):
        r&#39;&#39;&#39;
        As in the L4C calibration, calculate the empirical C storage, based on
        observed RH, since we don&#39;t yet know how much C we have to burn. Note
        that this SINGLE value per (flux tower) site is used as a &#34;constant
        effective SOC factor&#34; (Jones et al. 2017) throughout calibration, for
        every time step. This is because C substrate pools are assumed to be
        in the steady state for calibration. The empirical C storage
        magnitudes estimated by this function compare well with the
        SoilGrids 250m global 0-5 cm SOC density estimates of 10-60 kg m-2.

        $$
        \bar{C} = \frac{R_H\, k_{M_{S_x}}}{(p\, D_{\mathrm{liq}}\, \theta^3)
            [V_{\mathrm{max}}\, [O_2](k_{M_{O_2}} + [O_2])^{-1} - R_H]}
        $$

        Parameters
        ----------
        rh : numpy.ndarray
            RH in g C m-2 day-1
        soil_m : numpy.ndarray
            Soil moisture (%)
        soil_t : numpy.ndarray
            Soil temperature (°K)
        porosity : numpy.ndarray
            Total porosity, between [0, 1]
        perc : int or float
            Empirical Cbar percentile to return

        Returns
        -------
        tuple
            (c0, c1, c2) numpy.ndarray instances, one for each of the
            steady-state C pools (Units: g cm-3)
        &#39;&#39;&#39;
        # Calculate the DAMM parameters needed in the steady-state C eq.
        alpha0, alpha1, alpha2, ea, p, d_liq = (
            self.get(p)
            for p in (&#39;alpha0&#39;, &#39;alpha1&#39;, &#39;alpha2&#39;, &#39;ea&#39;, &#39;p&#39;, &#39;d_liq&#39;)
        )
        try:
            km_s = self.params[self.labels.index(&#39;km_s&#39;)]
        except ValueError:
            km_s_int, km_s_slope = (
                self.get(p)
                for p in (&#39;km_s_int&#39;, &#39;km_s_slope&#39;)
            )
            km_s = km_s_int + (km_s_slope * soil_t)

        # Let&#39;s do this in the units of km_s, because substrate is needed
        #   in these units (g C cm-3)
        #   -- rh is in g m-2 day-1
        #   -- km_s is in g cm-3
        #   -- v_max is in Mg cm-3 hr-1
        # Calculate coefficients for substrate concentration
        sx_coef = np.multiply(p * d_liq, np.power(soil_m / 100, 3))
        # Calculate oxygen concentration at reaction site; then MM constraint
        _, conc_O2 = self.concentrations(np.nan, soil_m, porosity)
        mm_O2 = conc_O2 / (self.get(&#39;km_O2&#39;) + conc_O2) # (dimensionless)
        # Convert g C m-2 to g C m-3, then denominator from m-3 to cm-3
        rh = (rh / self.constants.soil_depth_m) / 1e6
        # Estimate each soil C pool (differentiated by base rate or alpha)
        substrate_by_pool = []
        for alpha in (alpha0, alpha1, alpha2):
            v_max_i = self.v_max(soil_t, alpha, ea) # Calculate base rate
            v_max_i = (v_max_i * 1e6) # Convert Mg C to g C
            empirical_C = np.divide(
                np.multiply(rh, km_s),
                np.multiply(sx_coef, np.subtract( # Hourly to daily Vmax
                    np.multiply(v_max_i * 24, mm_O2), rh)))
            # This empirical approach may result in C values &lt; 0; assign 0
            substrate_by_pool.append(
                np.nanpercentile(
                    np.where(empirical_C &lt; 0, 0, empirical_C), perc, axis = 0))
        return substrate_by_pool

    def concentrations(self, substrate, soil_m, porosity):
        &#39;&#39;&#39;
        For a single C pool, returns substrate and oxygen concentrations.
        Units for C substrate are g C cm-3 (same as input argument) and units
        for O2 are dimensionless--essentially, it&#39;s `d_gas` times the proportion
        of total volume (soil + water + air) occupied by O2.

        Parameters
        ----------
        substrate : numpy.ndarray
            Soil C substrate (g cm-3)
        soil_m : numpy.ndarray
            Soil moisture (%)
        porosity : numpy.ndarray
            Total porosity, between [0, 1]

        Returns
        -------
        tuple
            `(conc_Sx, conc_O2)` where `conc_Sx` is the concentration of
            substrate, `conc_O2` is the concentration of O2
        &#39;&#39;&#39;
        air_frac_O2 = 0.2095 # L O2 L-1 air (20.95%)
        p = self.get(&#39;p&#39;)
        d_liq = self.get(&#39;d_liq&#39;)
        d_gas = self.get(&#39;d_gas&#39;)
        # Calculate substrate concentration at reaction site
        conc_Sx = np.multiply(substrate,
            np.multiply(p * d_liq, np.power(soil_m / 100, 3)))
        # Calculate oxygen concentration at reaction site; then MM constraint
        a = (porosity - (soil_m / 100))
        conc_O2 = d_gas * air_frac_O2 * np.power(np.where(a &lt; 0, 0, a), (4/3))
        return (conc_Sx, conc_O2)

    def get(self, parameter):
        &#39;&#39;&#39;
        Retrieves a parameter value whether it is fixed or a free parameter.
        This provides flexibility for versions of the model that may differ
        in free versus fixed parameters. Constants take precedence--if a value
        was fit but a constant value is found, the constant is used.

        Parameters
        ----------
        parameter : str
            Name of the parameter to retrieve
        &#39;&#39;&#39;
        if hasattr(self.constants, parameter):
            return getattr(self.constants, parameter)
        return self.params[self.labels.index(parameter)]

    def total_respiration(self, *args, **kwargs):
        &#39;&#39;&#39;
        Calculates the sum of respiration in each C pool. See `respiration()`.

        Returns
        -------
        numpy.ndarray
        &#39;&#39;&#39;
        rh = self.respiration(*args, **kwargs)
        respiration = np.zeros(rh[0].shape)
        for i in range(0, len(rh)):
            np.add(respiration, rh[i], out = respiration)
        return respiration

    def v_max(self, soil_t, alpha, ea = None):
        &#39;&#39;&#39;
        For a single C pool, returns maximum rate on enzymatic reaction in
        Mg C cm-3 hr-1. NOTE: Units of base rate (megagrams, Mg) are chosen
        to improve convergence in model fitting.

        Parameters
        ----------
        soil_t : numpy.ndarray
            Soil temperature (°K)
        alpha : numpy.ndarray
            Base rate/ pre-exponential factor (Mg C cm-3 hr-1)
        ea : numpy.ndarray
            Activation energy (kJ mol-1)

        Returns
        -------
        numpy.ndarray
        &#39;&#39;&#39;
        ea = self.get(&#39;ea&#39;) if ea is None else ea
        r_gas = 8.314472e-3 # Universal gas constant (kJ K-1 mol-1)
        return np.multiply( # Mg C cm-3 hr-1
            alpha, np.exp(-np.divide(ea, np.multiply(r_gas, soil_t))))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel" href="#pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel">DAMMDecompositionModel</a></li>
<li><a title="pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel2" href="#pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel2">DAMMDecompositionModel2</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.cbar"><code class="name flex">
<span>def <span class="ident">cbar</span></span>(<span>self, rh, soil_m, soil_t, porosity, perc=80)</span>
</code></dt>
<dd>
<div class="desc"><p>As in the L4C calibration, calculate the empirical C storage, based on
observed RH, since we don't yet know how much C we have to burn. Note
that this SINGLE value per (flux tower) site is used as a "constant
effective SOC factor" (Jones et al. 2017) throughout calibration, for
every time step. This is because C substrate pools are assumed to be
in the steady state for calibration. The empirical C storage
magnitudes estimated by this function compare well with the
SoilGrids 250m global 0-5 cm SOC density estimates of 10-60 kg m-2.</p>
<p><span><span class="MathJax_Preview">
\bar{C} = \frac{R_H\, k_{M_{S_x}}}{(p\, D_{\mathrm{liq}}\, \theta^3)
[V_{\mathrm{max}}\, [O_2](k_{M_{O_2}} + [O_2])^{-1} - R_H]}
</span><script type="math/tex; mode=display">
\bar{C} = \frac{R_H\, k_{M_{S_x}}}{(p\, D_{\mathrm{liq}}\, \theta^3)
[V_{\mathrm{max}}\, [O_2](k_{M_{O_2}} + [O_2])^{-1} - R_H]}
</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rh</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>RH in g C m-2 day-1</dd>
<dt><strong><code>soil_m</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Soil moisture (%)</dd>
<dt><strong><code>soil_t</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Soil temperature (°K)</dd>
<dt><strong><code>porosity</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Total porosity, between [0, 1]</dd>
<dt><strong><code>perc</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Empirical Cbar percentile to return</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(c0, c1, c2) numpy.ndarray instances, one for each of the
steady-state C pools (Units: g cm-3)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cbar(self, rh, soil_m, soil_t, porosity, perc = 80):
    r&#39;&#39;&#39;
    As in the L4C calibration, calculate the empirical C storage, based on
    observed RH, since we don&#39;t yet know how much C we have to burn. Note
    that this SINGLE value per (flux tower) site is used as a &#34;constant
    effective SOC factor&#34; (Jones et al. 2017) throughout calibration, for
    every time step. This is because C substrate pools are assumed to be
    in the steady state for calibration. The empirical C storage
    magnitudes estimated by this function compare well with the
    SoilGrids 250m global 0-5 cm SOC density estimates of 10-60 kg m-2.

    $$
    \bar{C} = \frac{R_H\, k_{M_{S_x}}}{(p\, D_{\mathrm{liq}}\, \theta^3)
        [V_{\mathrm{max}}\, [O_2](k_{M_{O_2}} + [O_2])^{-1} - R_H]}
    $$

    Parameters
    ----------
    rh : numpy.ndarray
        RH in g C m-2 day-1
    soil_m : numpy.ndarray
        Soil moisture (%)
    soil_t : numpy.ndarray
        Soil temperature (°K)
    porosity : numpy.ndarray
        Total porosity, between [0, 1]
    perc : int or float
        Empirical Cbar percentile to return

    Returns
    -------
    tuple
        (c0, c1, c2) numpy.ndarray instances, one for each of the
        steady-state C pools (Units: g cm-3)
    &#39;&#39;&#39;
    # Calculate the DAMM parameters needed in the steady-state C eq.
    alpha0, alpha1, alpha2, ea, p, d_liq = (
        self.get(p)
        for p in (&#39;alpha0&#39;, &#39;alpha1&#39;, &#39;alpha2&#39;, &#39;ea&#39;, &#39;p&#39;, &#39;d_liq&#39;)
    )
    try:
        km_s = self.params[self.labels.index(&#39;km_s&#39;)]
    except ValueError:
        km_s_int, km_s_slope = (
            self.get(p)
            for p in (&#39;km_s_int&#39;, &#39;km_s_slope&#39;)
        )
        km_s = km_s_int + (km_s_slope * soil_t)

    # Let&#39;s do this in the units of km_s, because substrate is needed
    #   in these units (g C cm-3)
    #   -- rh is in g m-2 day-1
    #   -- km_s is in g cm-3
    #   -- v_max is in Mg cm-3 hr-1
    # Calculate coefficients for substrate concentration
    sx_coef = np.multiply(p * d_liq, np.power(soil_m / 100, 3))
    # Calculate oxygen concentration at reaction site; then MM constraint
    _, conc_O2 = self.concentrations(np.nan, soil_m, porosity)
    mm_O2 = conc_O2 / (self.get(&#39;km_O2&#39;) + conc_O2) # (dimensionless)
    # Convert g C m-2 to g C m-3, then denominator from m-3 to cm-3
    rh = (rh / self.constants.soil_depth_m) / 1e6
    # Estimate each soil C pool (differentiated by base rate or alpha)
    substrate_by_pool = []
    for alpha in (alpha0, alpha1, alpha2):
        v_max_i = self.v_max(soil_t, alpha, ea) # Calculate base rate
        v_max_i = (v_max_i * 1e6) # Convert Mg C to g C
        empirical_C = np.divide(
            np.multiply(rh, km_s),
            np.multiply(sx_coef, np.subtract( # Hourly to daily Vmax
                np.multiply(v_max_i * 24, mm_O2), rh)))
        # This empirical approach may result in C values &lt; 0; assign 0
        substrate_by_pool.append(
            np.nanpercentile(
                np.where(empirical_C &lt; 0, 0, empirical_C), perc, axis = 0))
    return substrate_by_pool</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.cbar0"><code class="name flex">
<span>def <span class="ident">cbar0</span></span>(<span>self, litterfall, soil_m, soil_t, porosity, fmet, fstr)</span>
</code></dt>
<dd>
<div class="desc"><p>An alternative method for estimating the initital C pool sizes, this
analytical approaches solves for C storage after setting the
differential equation governing change in C to zero. See README for
the equations. The C storage magnitudes tend to be higher because
<code>V_max</code> is very small compared to litterfall, leading to very large
empirical C storage estimates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>litterfall</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Average daily litterfall [g C cm-3 day-1]</dd>
<dt><strong><code>soil_m</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>365-day soil moisture (%) climatology (365 x N &hellip;)</dd>
<dt><strong><code>soil_t</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>365-day soil temperature (°K) climatology (365 x N &hellip;)</dd>
<dt><strong><code>porosity</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Total porosity, between [0, 1]</dd>
<dt><strong><code>fmet</code></strong> :&ensp;<code>float</code></dt>
<dd>Fraction of daily litterfall entering metabolic pool</dd>
<dt><strong><code>fstr</code></strong> :&ensp;<code>float</code></dt>
<dd>Fraction of structural pool transferred to the recalcitrant pool
during "humification"</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(c0, c1, c2) numpy.ndarray instances, one for each of the
steady-state C pools (Units: g cm-3)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cbar0(self, litterfall, soil_m, soil_t, porosity, fmet, fstr):
    &#39;&#39;&#39;
    An alternative method for estimating the initital C pool sizes, this
    analytical approaches solves for C storage after setting the
    differential equation governing change in C to zero. See README for
    the equations. The C storage magnitudes tend to be higher because
    `V_max` is very small compared to litterfall, leading to very large
    empirical C storage estimates.

    Parameters
    ----------
    litterfall : numpy.ndarray
        Average daily litterfall [g C cm-3 day-1]
    soil_m : numpy.ndarray
        365-day soil moisture (%) climatology (365 x N ...)
    soil_t : numpy.ndarray
        365-day soil temperature (°K) climatology (365 x N ...)
    porosity : numpy.ndarray
        Total porosity, between [0, 1]
    fmet : float
        Fraction of daily litterfall entering metabolic pool
    fstr : float
        Fraction of structural pool transferred to the recalcitrant pool
        during &#34;humification&#34;

    Returns
    -------
    tuple
        (c0, c1, c2) numpy.ndarray instances, one for each of the
        steady-state C pools (Units: g cm-3)
    &#39;&#39;&#39;
    # Calculate the DAMM parameters needed in the steady-state C eq.
    alpha0, alpha1, alpha2, p, d_liq = (
        self.get(p)
        for p in (&#39;alpha0&#39;, &#39;alpha1&#39;, &#39;alpha2&#39;, &#39;p&#39;, &#39;d_liq&#39;)
    )
    try:
        km_s = self.params[self.labels.index(&#39;km_s&#39;)]
    except ValueError:
        km_s_int, km_s_slope = (
            self.get(p)
            for p in (&#39;km_s_int&#39;, &#39;km_s_slope&#39;)
        )
        km_s = km_s_int + (km_s_slope * soil_t)

    # Convert from [Mg C cm-3 hr-1] to [g C cm-3 day-1]
    vmax0 = self.v_max(soil_t, alpha0) * 1e6 * 24
    vmax1 = self.v_max(soil_t, alpha1) * 1e6 * 24
    vmax2 = self.v_max(soil_t, alpha2) * 1e6 * 24
    _, conc_O2 = self.concentrations(np.nan, soil_m, porosity)
    mm_O2 = conc_O2 / (self.get(&#39;km_O2&#39;) + conc_O2)
    sx_coef = np.multiply(p * d_liq, np.power(soil_m / 100, 3))
    c0 = (litterfall * fmet * km_s) / (sx_coef * (
        (vmax0 * mm_O2) - (litterfall * fmet)))
    c1 = (litterfall * (1 - fmet) * km_s) / (sx_coef * (
        (vmax1 * mm_O2) - (litterfall * (1 - fmet))))
    c2 = -(vmax1 * c1 * fstr * km_s) / (
        (sx_coef * (((vmax1 * c1 * fstr) + (vmax2 * c1)))) + (vmax2 * km_s))
    substrate_by_pool = []
    # Empirical C is now the steady-state value for each day of the
    #   climatological year; calculate the daily average
    for empirical_C in (c0, c1, c2):
        # Calculate mean across 365 days
        substrate_by_pool.append(np.nanmean(
            np.where(empirical_C &lt; 0, 0, empirical_C), axis = 0))
    return substrate_by_pool</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.concentrations"><code class="name flex">
<span>def <span class="ident">concentrations</span></span>(<span>self, substrate, soil_m, porosity)</span>
</code></dt>
<dd>
<div class="desc"><p>For a single C pool, returns substrate and oxygen concentrations.
Units for C substrate are g C cm-3 (same as input argument) and units
for O2 are dimensionless&ndash;essentially, it's <code>d_gas</code> times the proportion
of total volume (soil + water + air) occupied by O2.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>substrate</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Soil C substrate (g cm-3)</dd>
<dt><strong><code>soil_m</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Soil moisture (%)</dd>
<dt><strong><code>porosity</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Total porosity, between [0, 1]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd><code>(conc_Sx, conc_O2)</code> where <code>conc_Sx</code> is the concentration of
substrate, <code>conc_O2</code> is the concentration of O2</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concentrations(self, substrate, soil_m, porosity):
    &#39;&#39;&#39;
    For a single C pool, returns substrate and oxygen concentrations.
    Units for C substrate are g C cm-3 (same as input argument) and units
    for O2 are dimensionless--essentially, it&#39;s `d_gas` times the proportion
    of total volume (soil + water + air) occupied by O2.

    Parameters
    ----------
    substrate : numpy.ndarray
        Soil C substrate (g cm-3)
    soil_m : numpy.ndarray
        Soil moisture (%)
    porosity : numpy.ndarray
        Total porosity, between [0, 1]

    Returns
    -------
    tuple
        `(conc_Sx, conc_O2)` where `conc_Sx` is the concentration of
        substrate, `conc_O2` is the concentration of O2
    &#39;&#39;&#39;
    air_frac_O2 = 0.2095 # L O2 L-1 air (20.95%)
    p = self.get(&#39;p&#39;)
    d_liq = self.get(&#39;d_liq&#39;)
    d_gas = self.get(&#39;d_gas&#39;)
    # Calculate substrate concentration at reaction site
    conc_Sx = np.multiply(substrate,
        np.multiply(p * d_liq, np.power(soil_m / 100, 3)))
    # Calculate oxygen concentration at reaction site; then MM constraint
    a = (porosity - (soil_m / 100))
    conc_O2 = d_gas * air_frac_O2 * np.power(np.where(a &lt; 0, 0, a), (4/3))
    return (conc_Sx, conc_O2)</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, parameter)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a parameter value whether it is fixed or a free parameter.
This provides flexibility for versions of the model that may differ
in free versus fixed parameters. Constants take precedence&ndash;if a value
was fit but a constant value is found, the constant is used.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parameter</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the parameter to retrieve</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, parameter):
    &#39;&#39;&#39;
    Retrieves a parameter value whether it is fixed or a free parameter.
    This provides flexibility for versions of the model that may differ
    in free versus fixed parameters. Constants take precedence--if a value
    was fit but a constant value is found, the constant is used.

    Parameters
    ----------
    parameter : str
        Name of the parameter to retrieve
    &#39;&#39;&#39;
    if hasattr(self.constants, parameter):
        return getattr(self.constants, parameter)
    return self.params[self.labels.index(parameter)]</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.total_respiration"><code class="name flex">
<span>def <span class="ident">total_respiration</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the sum of respiration in each C pool. See <code>respiration()</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def total_respiration(self, *args, **kwargs):
    &#39;&#39;&#39;
    Calculates the sum of respiration in each C pool. See `respiration()`.

    Returns
    -------
    numpy.ndarray
    &#39;&#39;&#39;
    rh = self.respiration(*args, **kwargs)
    respiration = np.zeros(rh[0].shape)
    for i in range(0, len(rh)):
        np.add(respiration, rh[i], out = respiration)
    return respiration</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.v_max"><code class="name flex">
<span>def <span class="ident">v_max</span></span>(<span>self, soil_t, alpha, ea=None)</span>
</code></dt>
<dd>
<div class="desc"><p>For a single C pool, returns maximum rate on enzymatic reaction in
Mg C cm-3 hr-1. NOTE: Units of base rate (megagrams, Mg) are chosen
to improve convergence in model fitting.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>soil_t</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Soil temperature (°K)</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Base rate/ pre-exponential factor (Mg C cm-3 hr-1)</dd>
<dt><strong><code>ea</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Activation energy (kJ mol-1)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def v_max(self, soil_t, alpha, ea = None):
    &#39;&#39;&#39;
    For a single C pool, returns maximum rate on enzymatic reaction in
    Mg C cm-3 hr-1. NOTE: Units of base rate (megagrams, Mg) are chosen
    to improve convergence in model fitting.

    Parameters
    ----------
    soil_t : numpy.ndarray
        Soil temperature (°K)
    alpha : numpy.ndarray
        Base rate/ pre-exponential factor (Mg C cm-3 hr-1)
    ea : numpy.ndarray
        Activation energy (kJ mol-1)

    Returns
    -------
    numpy.ndarray
    &#39;&#39;&#39;
    ea = self.get(&#39;ea&#39;) if ea is None else ea
    r_gas = 8.314472e-3 # Universal gas constant (kJ K-1 mol-1)
    return np.multiply( # Mg C cm-3 hr-1
        alpha, np.exp(-np.divide(ea, np.multiply(r_gas, soil_t))))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel"><code class="flex name class">
<span>class <span class="ident">DAMMDecompositionModel</span></span>
<span>(</span><span>params=None, soil_depth_cm=5, km_O2=0.121)</span>
</code></dt>
<dd>
<div class="desc"><p>The DAMM decomposition model as reported by Davidson et al. (2012), with
some changes: Support for multiple soil C pools; Additional free
parameters (not bragging about it, these have to be fit); and Changed the
units of the pre-exponential factor to better condition optimization.</p>
<p>Free parameters are:</p>
<ul>
<li><code>alpha</code>: Pre-exponential factor of enzymatic reaction with <code>S_x</code>
(Mg C cm-3 hr-1), note this is <em>Megagrams</em> of C&hellip;</li>
<li><code>ea</code>:
Activation energy of enzymatic reaction with <code>S_x</code> (kJ mol-1)</li>
<li><code>km_s</code>:
Michaelis-Menten coefficient for subtrate, using the constant-
value form (g C cm-3)</li>
<li><code>p</code>:
Proportion of <code>C_total</code> that is soluble</li>
<li><code>d_liq</code>: Diffusion coefficient of substrate in liquid phase</li>
<li><code>d_gas</code>: Diffusion coefficient of <code>O_2</code> in air</li>
</ul>
<p>NOTE: CUE is potentially another free parameter, but it has no relevance
in running DAMM, only in fitting the model with unknown C storage/
substrate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DAMMDecompositionModel(AbstractDAMM):
    &#39;&#39;&#39;
    The DAMM decomposition model as reported by Davidson et al. (2012), with
    some changes: Support for multiple soil C pools; Additional free
    parameters (not bragging about it, these have to be fit); and Changed the
    units of the pre-exponential factor to better condition optimization.

    Free parameters are:

    - `alpha`: Pre-exponential factor of enzymatic reaction with `S_x`
               (Mg C cm-3 hr-1), note this is *Megagrams* of C...
    - `ea`:    Activation energy of enzymatic reaction with `S_x` (kJ mol-1)
    - `km_s`:  Michaelis-Menten coefficient for subtrate, using the constant-
               value form (g C cm-3)
    - `p`:     Proportion of `C_total` that is soluble
    - `d_liq`: Diffusion coefficient of substrate in liquid phase
    - `d_gas`: Diffusion coefficient of `O_2` in air

    NOTE: CUE is potentially another free parameter, but it has no relevance
    in running DAMM, only in fitting the model with unknown C storage/
    substrate.
    &#39;&#39;&#39;
    parameter_names = (
        &#39;alpha0&#39;, &#39;alpha1&#39;, &#39;alpha2&#39;, &#39;ea&#39;, &#39;km_s&#39;, &#39;p&#39;, &#39;d_liq&#39;, &#39;d_gas&#39;)

    def __init__(self, params = None, soil_depth_cm = 5, km_O2 = 0.121):
        self.constants = Namespace()
        self.constants.add(&#39;km_O2&#39;, km_O2)
        self.constants.add(&#39;soil_depth_cm&#39;, soil_depth_cm)
        self.constants.add(&#39;soil_depth_m&#39;, soil_depth_cm / 100)
        self.params = params
        if params is None:
            # Use parameters from Davidson et al. (2012)
            self.params = (53.8, 0, 0, 72.26, 9.95e-7, 4.14e-4, 3.17, 1.67, np.nan)

    def respiration(self, substrate, soil_m, soil_t, porosity):
        &#39;&#39;&#39;
        Calculates daily total RH for all soil pools, g C m-2 day-1.

        Parameters
        ----------
        substrate : numpy.ndarray
            Soil C substrate (g cm-3) in each pool (3-tuple)
        soil_m : numpy.ndarray
            Soil moisture (%)
        soil_t : numpy.ndarray
            Soil temperature (°K)
        porosity : numpy.ndarray
            Total porosity, between [0, 1]

        Returns
        -------
        tuple
            `(rh0, rh1, rh2)` numpy.ndarray instances, one for each of the
            C pools (Units: g m-2 day-1)
        &#39;&#39;&#39;
        assert len(substrate) == 3,\
            &#39;Need a substrate value for each of 3 pools&#39;
        alpha0, alpha1, alpha2, ea, km_s, p, d_liq = (
            self.params[i] for i in range(0, 7)
        )
        respiration = []
        for i, alpha_i in enumerate((alpha0, alpha1, alpha2)):
            v_max_i = self.v_max(soil_t, alpha_i, ea)
            sx_i, conc_O2 = self.concentrations(substrate[i], soil_m, porosity)
            # Calculate Michaelis-Menten coefficients
            mm_sx = sx_i / (km_s + sx_i) # Units (g C cm-3) cancel out (dimensionless)
            mm_O2 = conc_O2 / (self.constants.km_O2 + conc_O2) # (dimensionless)
            rh = v_max_i * mm_sx * mm_O2 # Mg C cm-3 hr-1; need g C m-2 day-1
            # First convert Mg C to g C, then cm-3 to cm-2, then from
            #   cm-2 to m-2, then from hourly to a daily flux (24 hours/ day)
            resp = (((1e6 * rh) * self.constants.soil_depth_cm) * 1e4) * 24
            respiration.append(np.where(resp &lt; 0, 0, resp))
        return respiration</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM">AbstractDAMM</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel.parameter_names"><code class="name">var <span class="ident">parameter_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel.respiration"><code class="name flex">
<span>def <span class="ident">respiration</span></span>(<span>self, substrate, soil_m, soil_t, porosity)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates daily total RH for all soil pools, g C m-2 day-1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>substrate</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Soil C substrate (g cm-3) in each pool (3-tuple)</dd>
<dt><strong><code>soil_m</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Soil moisture (%)</dd>
<dt><strong><code>soil_t</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Soil temperature (°K)</dd>
<dt><strong><code>porosity</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Total porosity, between [0, 1]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd><code>(rh0, rh1, rh2)</code> numpy.ndarray instances, one for each of the
C pools (Units: g m-2 day-1)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def respiration(self, substrate, soil_m, soil_t, porosity):
    &#39;&#39;&#39;
    Calculates daily total RH for all soil pools, g C m-2 day-1.

    Parameters
    ----------
    substrate : numpy.ndarray
        Soil C substrate (g cm-3) in each pool (3-tuple)
    soil_m : numpy.ndarray
        Soil moisture (%)
    soil_t : numpy.ndarray
        Soil temperature (°K)
    porosity : numpy.ndarray
        Total porosity, between [0, 1]

    Returns
    -------
    tuple
        `(rh0, rh1, rh2)` numpy.ndarray instances, one for each of the
        C pools (Units: g m-2 day-1)
    &#39;&#39;&#39;
    assert len(substrate) == 3,\
        &#39;Need a substrate value for each of 3 pools&#39;
    alpha0, alpha1, alpha2, ea, km_s, p, d_liq = (
        self.params[i] for i in range(0, 7)
    )
    respiration = []
    for i, alpha_i in enumerate((alpha0, alpha1, alpha2)):
        v_max_i = self.v_max(soil_t, alpha_i, ea)
        sx_i, conc_O2 = self.concentrations(substrate[i], soil_m, porosity)
        # Calculate Michaelis-Menten coefficients
        mm_sx = sx_i / (km_s + sx_i) # Units (g C cm-3) cancel out (dimensionless)
        mm_O2 = conc_O2 / (self.constants.km_O2 + conc_O2) # (dimensionless)
        rh = v_max_i * mm_sx * mm_O2 # Mg C cm-3 hr-1; need g C m-2 day-1
        # First convert Mg C to g C, then cm-3 to cm-2, then from
        #   cm-2 to m-2, then from hourly to a daily flux (24 hours/ day)
        resp = (((1e6 * rh) * self.constants.soil_depth_cm) * 1e4) * 24
        respiration.append(np.where(resp &lt; 0, 0, resp))
    return respiration</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM">AbstractDAMM</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.cbar" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.cbar">cbar</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.cbar0" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.cbar0">cbar0</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.concentrations" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.concentrations">concentrations</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.get" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.get">get</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.total_respiration" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.total_respiration">total_respiration</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.v_max" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.v_max">v_max</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel2"><code class="flex name class">
<span>class <span class="ident">DAMMDecompositionModel2</span></span>
<span>(</span><span>params, soil_depth_cm=5, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The DAMM decomposition model as reported by Davidson et al. (2012), with
some changes: Support for multiple soil C pools; Additional free
parameters (not bragging about it, these have to be fit); and Changed the
units of the pre-exponential factor to better condition optimization.
This model assumes that the Michaelis-Menten coefficient for substrate is
<em>not constant</em> w.r.t. temperature (the slope-intercept form of km_s). It
also allows any free parameter to be specified as a constant.</p>
<p>Free parameters are:</p>
<ul>
<li><code>alpha</code>:
Pre-exponential factor of enzymatic reaction with <code>S_x</code>
(Mg C cm-3 hr-1), note this is <em>Megagrams</em> of C&hellip;</li>
<li><code>ea</code>:
Activation energy of enzymatic reaction with <code>S_x</code>
(kJ mol-1)</li>
<li><code>km_s_int</code>:
Intercept of Michaelis-Menten (MM) coefficient for
substrate (g C cm-3)</li>
<li><code>km_s_slope</code>: Slope of Michaelis-Menten (MM) coefficient for
substrate (g C cm-3 K-1)</li>
<li><code>p</code>:
Proportion of <code>C_total</code> that is soluble</li>
<li><code>d_liq</code>:
Diffusion coefficient of substrate in liquid phase</li>
<li><code>d_gas</code>:
Diffusion coefficient of <code>O_2</code> in air</li>
<li><code>km_O2</code>:
Half-saturation (MM) coefficient for diffusion of O2</li>
</ul>
<p>NOTE: CUE is potentially another free parameter, but it has no relevance
in running DAMM, only in fitting the model with unknown C storage/
substrate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DAMMDecompositionModel2(AbstractDAMM):
    &#39;&#39;&#39;
    The DAMM decomposition model as reported by Davidson et al. (2012), with
    some changes: Support for multiple soil C pools; Additional free
    parameters (not bragging about it, these have to be fit); and Changed the
    units of the pre-exponential factor to better condition optimization.
    This model assumes that the Michaelis-Menten coefficient for substrate is
    *not constant* w.r.t. temperature (the slope-intercept form of km_s). It
    also allows any free parameter to be specified as a constant.

    Free parameters are:

    - `alpha`:      Pre-exponential factor of enzymatic reaction with `S_x`
                    (Mg C cm-3 hr-1), note this is *Megagrams* of C...
    - `ea`:         Activation energy of enzymatic reaction with `S_x`
                    (kJ mol-1)
    - `km_s_int`:   Intercept of Michaelis-Menten (MM) coefficient for
                    substrate (g C cm-3)
    - `km_s_slope`: Slope of Michaelis-Menten (MM) coefficient for
                    substrate (g C cm-3 K-1)
    - `p`:          Proportion of `C_total` that is soluble
    - `d_liq`:      Diffusion coefficient of substrate in liquid phase
    - `d_gas`:      Diffusion coefficient of `O_2` in air
    - `km_O2`:      Half-saturation (MM) coefficient for diffusion of O2

    NOTE: CUE is potentially another free parameter, but it has no relevance
    in running DAMM, only in fitting the model with unknown C storage/
    substrate.
    &#39;&#39;&#39;
    parameter_names = (
        &#39;alpha0&#39;, &#39;alpha1&#39;, &#39;alpha2&#39;, &#39;ea&#39;, &#39;km_s_int&#39;, &#39;km_s_slope&#39;,
        &#39;p&#39;, &#39;d_liq&#39;, &#39;d_gas&#39;, &#39;km_O2&#39;)

    def __init__(self, params, soil_depth_cm = 5, **kwargs):
        self.constants = Namespace()
        self.constants.add(&#39;soil_depth_cm&#39;, soil_depth_cm)
        self.constants.add(&#39;soil_depth_m&#39;, soil_depth_cm / 100)
        self.labels = list(self.parameter_names).copy()
        self.params = params
        for key, value in kwargs.items():
            self.constants.add(key, value)
            # Don&#39;t allow constants to appear in the parameters list
            if key in self.labels:
                # May need to re-build parameters list
                self.labels.remove(key)
        for name in self.parameter_names:
            assert name in self.labels or hasattr(self.constants, name),\
                &#39;Required parameter &#34;%s&#34; must be specified either as a constant nor a free parameter&#39; % name

    def respiration(self, substrate, soil_m, soil_t, porosity):
        &#39;&#39;&#39;
        Calculates daily total RH for all soil pools, g C m-2 day-1.

        Parameters
        ----------
        substrate : numpy.ndarray
            Soil C substrate (g cm-3) in each pool (3-tuple)
        soil_m : numpy.ndarray
            Soil moisture (%)
        soil_t : numpy.ndarray
            Soil temperature (°K)
        porosity : numpy.ndarray
            Total porosity, between [0, 1]

        Returns
        -------
        tuple
            (rh0, rh1, rh2) numpy.ndarray instances, one for each of the
            C pools (Units: g m-2 day-1)
        &#39;&#39;&#39;
        assert len(substrate) == 3,\
            &#39;Need a substrate value for each of 3 pools&#39;
        alpha0, alpha1, alpha2, ea, km_s_int, km_s_slope = (
            self.params[i] for i in range(0, 6)
        )
        respiration = []
        for i, a_i in enumerate((alpha0, alpha1, alpha2)):
            v_max_i = self.v_max(soil_t, a_i, ea)
            sx_i, conc_O2 = self.concentrations(
                np.array(substrate[i]), soil_m, porosity)
            # Calculate Michaelis-Menten coefficients
            km_s = km_s_int + (km_s_slope * soil_t)
            mm_sx = sx_i / (km_s + sx_i) # Units (g C cm-3) cancel out
            mm_O2 = conc_O2 / (self.get(&#39;km_O2&#39;) + conc_O2) # (dim.less)
            rh = v_max_i * mm_sx * mm_O2 # Mg C cm-3 hr-1
            # First convert Mg C to g C, then cm-3 to cm-2, then from
            #   cm-2 to m-2, then from hourly to a daily flux (24 hours/ day)
            resp = (((1e6 * rh) * self.constants.soil_depth_cm) * 1e4) * 24
            respiration.append(np.where(resp &lt; 0, 0, resp))
        return respiration</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM">AbstractDAMM</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel2.parameter_names"><code class="name">var <span class="ident">parameter_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel2.respiration"><code class="name flex">
<span>def <span class="ident">respiration</span></span>(<span>self, substrate, soil_m, soil_t, porosity)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates daily total RH for all soil pools, g C m-2 day-1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>substrate</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Soil C substrate (g cm-3) in each pool (3-tuple)</dd>
<dt><strong><code>soil_m</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Soil moisture (%)</dd>
<dt><strong><code>soil_t</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Soil temperature (°K)</dd>
<dt><strong><code>porosity</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Total porosity, between [0, 1]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(rh0, rh1, rh2) numpy.ndarray instances, one for each of the
C pools (Units: g m-2 day-1)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def respiration(self, substrate, soil_m, soil_t, porosity):
    &#39;&#39;&#39;
    Calculates daily total RH for all soil pools, g C m-2 day-1.

    Parameters
    ----------
    substrate : numpy.ndarray
        Soil C substrate (g cm-3) in each pool (3-tuple)
    soil_m : numpy.ndarray
        Soil moisture (%)
    soil_t : numpy.ndarray
        Soil temperature (°K)
    porosity : numpy.ndarray
        Total porosity, between [0, 1]

    Returns
    -------
    tuple
        (rh0, rh1, rh2) numpy.ndarray instances, one for each of the
        C pools (Units: g m-2 day-1)
    &#39;&#39;&#39;
    assert len(substrate) == 3,\
        &#39;Need a substrate value for each of 3 pools&#39;
    alpha0, alpha1, alpha2, ea, km_s_int, km_s_slope = (
        self.params[i] for i in range(0, 6)
    )
    respiration = []
    for i, a_i in enumerate((alpha0, alpha1, alpha2)):
        v_max_i = self.v_max(soil_t, a_i, ea)
        sx_i, conc_O2 = self.concentrations(
            np.array(substrate[i]), soil_m, porosity)
        # Calculate Michaelis-Menten coefficients
        km_s = km_s_int + (km_s_slope * soil_t)
        mm_sx = sx_i / (km_s + sx_i) # Units (g C cm-3) cancel out
        mm_O2 = conc_O2 / (self.get(&#39;km_O2&#39;) + conc_O2) # (dim.less)
        rh = v_max_i * mm_sx * mm_O2 # Mg C cm-3 hr-1
        # First convert Mg C to g C, then cm-3 to cm-2, then from
        #   cm-2 to m-2, then from hourly to a daily flux (24 hours/ day)
        resp = (((1e6 * rh) * self.constants.soil_depth_cm) * 1e4) * 24
        respiration.append(np.where(resp &lt; 0, 0, resp))
    return respiration</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM">AbstractDAMM</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.cbar" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.cbar">cbar</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.cbar0" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.cbar0">cbar0</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.concentrations" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.concentrations">concentrations</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.get" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.get">get</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.total_respiration" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.total_respiration">total_respiration</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.v_max" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.v_max">v_max</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="SMAP Mission Homepage" href="https://smap.jpl.nasa.gov/">
<img src="https://arthur-e.github.io/pyl4c/templates/images/logo_SMAP.jpg" alt="">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyl4c.apps.l4c.extensions" href="index.html">pyl4c.apps.l4c.extensions</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.extensions.damm.g_cm3_to_g_m2" href="#pyl4c.apps.l4c.extensions.damm.g_cm3_to_g_m2">g_cm3_to_g_m2</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.g_m2_to_g_cm3" href="#pyl4c.apps.l4c.extensions.damm.g_m2_to_g_cm3">g_m2_to_g_cm3</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM">AbstractDAMM</a></code></h4>
<ul class="two-column">
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.cbar" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.cbar">cbar</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.cbar0" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.cbar0">cbar0</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.concentrations" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.concentrations">concentrations</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.get" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.get">get</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.total_respiration" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.total_respiration">total_respiration</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.AbstractDAMM.v_max" href="#pyl4c.apps.l4c.extensions.damm.AbstractDAMM.v_max">v_max</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel" href="#pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel">DAMMDecompositionModel</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel.parameter_names" href="#pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel.parameter_names">parameter_names</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel.respiration" href="#pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel.respiration">respiration</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel2" href="#pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel2">DAMMDecompositionModel2</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel2.parameter_names" href="#pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel2.parameter_names">parameter_names</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel2.respiration" href="#pyl4c.apps.l4c.extensions.damm.DAMMDecompositionModel2.respiration">respiration</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>