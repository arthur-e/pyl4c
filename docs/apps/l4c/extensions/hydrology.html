<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyl4c.apps.l4c.extensions.hydrology API documentation</title>
<meta name="description" content="Variation on L4C model but with vertically stratified soil decomposition and
heterotrophic respiration sub-models based on soil hydrology profile." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:35%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyl4c.apps.l4c.extensions.hydrology</code></h1>
</header>
<section id="section-intro">
<p>Variation on L4C model but with vertically stratified soil decomposition and
heterotrophic respiration sub-models based on soil hydrology profile.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Variation on L4C model but with vertically stratified soil decomposition and
heterotrophic respiration sub-models based on soil hydrology profile.
&#39;&#39;&#39;

import datetime
import pickle
import numpy as np
import h5py
from functools import partial
from pyl4c import suppress_warnings
from pyl4c.science import ordinals365
from pyl4c.stats import linear_constraint
from pyl4c.lib.cli import ProgressBar
from pyl4c.apps.l4c import L4CConstants, L4CState, L4CStratifiedState
from pyl4c.apps.l4c.io import L4CStreamingInputDataset
from pyl4c.apps.l4c.main import L4CForwardProcessPoint

# File paths to the L4SM soil temperature data by layer; the SM profile data from simulation
TSOIL_HDF = &#39;/home/arthur.endsley/DATA/L4_SM_gph_NRv8-3_profile_at_356_tower_sites.h5&#39;
SM_HDF = &#39;/home/arthur.endsley/DATA/L4_C_NRv8-3_soil_moisture_profiles_simulated_at_356_tower_sites.h5&#39;

class O2DiffusionLimitMixin:
    &#39;&#39;&#39;
    Provides an O2 diffusion limit as a mix-in. Not to be instantiated
    directly.
    &#39;&#39;&#39;
    def concentration_O2(self, soil_vwc):
        &#39;Concentration of O2 given soil vegetation water content (VWC)&#39;
        d_gas = self._extra_params[&#39;d_gas&#39;]
        return d_gas * self.AIR_FRAC_O2 * np.power(
            self._porosity - soil_vwc, 4/3)

    def rh(self, state, drivers):
        &#39;&#39;&#39;
        Calculate RH for a single time step.

        Parameters
        ----------
        state : numpy.ndarray
            `(3 x N x M)` array of current SOC state in each pool
        drivers : list or tuple
            Sequence of `numpy.ndarray`: `(tsoil, smsf)` where `tsoil` is the
            the soil temperature and `smsf` is the surface soil moisture, each
            is an (N x M) array

        Returns
        -------
        numpy.ndarray
        &#39;&#39;&#39;
        # Translate Tsoil and SMSF into environmental constraints on RH
        tsoil, smsf = drivers
        # Some classes pass zipped (array, label) pairs for the drivers,
        #   others just pass arrays
        if hasattr(tsoil, &#39;ndim&#39;):
            f_tsoil = self.constrain(tsoil, &#39;tsoil&#39;)
            f_smsf = self.constrain(smsf, &#39;smsf&#39;)
        else:
            f_tsoil = self.constrain(tsoil)
            f_smsf = self.constrain(*smsf)
            smsf, _ = smsf # Pop off the label &#34;smsf&#34; and just get the data
        # NOTE: Converting from &#34;wetness&#34; to volumetric water content (VWC)
        #   (in % units); this requires multiplying (wetness * porosity) as
        #   (wetness = VWC / porosity)
        soil_vwc = np.multiply(smsf / 100, self._porosity)
        conc_O2 = self.concentration_O2(soil_vwc)
        mm_O2 = conc_O2 / (self._extra_params[&#39;km_oxy&#39;] + conc_O2)
        # Take the minimum of the SMSF and Soil VWC constraint
        k_mult = f_tsoil * np.min(np.stack((f_smsf, mm_O2)), axis = 0)
        k_mult = k_mult[np.newaxis,...].repeat(3, axis = 0)
        # NOTE: These are true decay rates for 2nd and 3rd pools, so it
        #   is straightforward to multiply them against SOC
        if self._multilayer:
            rh = k_mult * self.constants.decay_rates[:,None,...] * state
        else:
            rh = k_mult * self.constants.decay_rates * state
        # &#34;the adjustment...to account for material transferred into the
        #   slow pool during humification&#34; (Jones et al. 2017 TGARS, p.5)
        rh[1,...] = rh[1,...] * (1 - self.constants.f_structural)
        # T_mult, W_mult same for each pool
        return (rh, (f_tsoil, f_smsf, conc_O2, mm_O2))


class StratifiedLitterfallMixin:
    &#39;&#39;&#39;
    Provides the CASA litterfall phenology for a vertical soil profile as a
    mix-in; not meant to be instantiated directly.
    &#39;&#39;&#39;
    def soc(self, state, rh, litterfall, t, scheduled = True):
        &#39;&#39;&#39;
        Calculate change in soil organic carbon (SOC) for a single time step.

        Parameters
        ----------
        state : numpy.ndarray
            `(3 x Z x N x M)` array of SOC at the previous time step
        rh : numpy.ndarray
            `(3 x Z x N x M)` array of RH at the current time step
        litterfall : numpy.ndarray
            `(365 x Z x N x M)` array of average daily litterfall throughout
            the 365-day climatological year
        t : int
            Current time step
        scheduled : bool
            True if litterfall is a function of day-of-year (DOY); False if
            litterfall is a pre-computed fraction of daily NPP (Default: True)

        Returns
        -------
        numpy.ndarray
        &#39;&#39;&#39;
        if scheduled:
            doy = self._doy[t] - 1 # Get DOY on [1,365] then on [0,364] for Python
            litter = litterfall[:,doy,...]
        else:
            litter = litterfall
        # Change in Cmet, Cstr, Crec with depth (z)
        shp = state.shape[-2:]
        dc0_dz = (state[0] - np.vstack((np.zeros((1, *shp)), state[0,:-1]))) / self.DELTA_Z
        dc1_dz = (state[1] - np.vstack((np.zeros((1, *shp)), state[1,:-1]))) / self.DELTA_Z
        dc2_dz = (state[1] - np.vstack((np.zeros((1, *shp)), state[2,:-1]))) / self.DELTA_Z
        # Change in diffusivity with depth (z)
        diff0 = self.diffusivity[:,None] * dc0_dz
        diff1 = self.diffusivity[:,None] * dc1_dz
        diff2 = self.diffusivity[:,None] * dc2_dz
        dd0_dz = (diff0 - np.vstack((np.zeros((1, *shp)), diff0[:-1]))) / self.DELTA_Z
        dd1_dz = (diff1 - np.vstack((np.zeros((1, *shp)), diff1[:-1]))) / self.DELTA_Z
        dd2_dz = (diff2 - np.vstack((np.zeros((1, *shp)), diff2[:-1]))) / self.DELTA_Z
        # Change in SOC according to diff. eq. in Jones et al. (2017)
        dc1 = (litter * self.constants.f_metabolic) - rh[0,...] + dd0_dz
        dc2 = (litter * (1 - self.constants.f_metabolic)) - rh[1,...] + dd1_dz
        dc3 = (self.constants.f_structural * rh[1,...]) - rh[2,...] + dd2_dz
        return (dc1, dc2, dc3)


class StratifiedRespirationMixin:
    &#39;&#39;&#39;
    Provides the vertically stratified heterotrophic respiration as a mix-in;
    not meant to be instantiated directly.
    &#39;&#39;&#39;
    @suppress_warnings
    def _load_state(self, hdf, keys):
        &#39;&#39;&#39;
        Overrides original _load_state() so as to allow for vertically
        stratified SOC data.
        &#39;&#39;&#39;
        t = self.config[&#39;time_steps&#39;]
        z = self.DEPTHS.size
        n = self.config[&#39;site_count&#39;]
        soc_path = self.config[&#39;soc_data_path&#39;]
        init_state = []
        new_state = []
        with open(soc_path, &#39;rb&#39;) as file:
            _, soil_organic_carbon = pickle.load(file)
        for p, key in enumerate(keys):
            # Create an empty state array, allocated T time steps
            new_state.append(np.full((1, t, z, n, 81), np.nan))
            if key.startswith(&#39;soc&#39;):
                arr = soil_organic_carbon[p,...].astype(np.float32)
                # Filter out any NoData, which (should) only correspond to
                #   1-km subgrid pixels that are outside the PFT range [1, 8]
                init_state.append(
                    np.where(arr &lt; 0, np.nan, arr).reshape((1, 1, z, n, 81)))
            elif key not in self.DIAGNOSTICS_INDEX:
                init_state.append(
                    np.full((1, 1, z, n, 81), np.nan, dtype = np.float32))
        return (init_state, new_state)

    def _setup_data_storage(self, config, hdf):
        &#39;&#39;&#39;
        Initialize containers for various datasets; including containers with
        vertical discretization.
        &#39;&#39;&#39;
        site_names = hdf[&#39;site_id&#39;][:].tolist()
        shp = (config[&#39;time_steps&#39;], config[&#39;site_count&#39;], 81)
        self._constants = L4CConstants(
            config[&#39;site_count&#39;], self._pft, self.PFT_CODES)
        self._drivers = None
        self._fluxes = L4CState(
            config[&#39;site_count&#39;], np.full((len(self.FLUX_INDEX), *shp),
            np.nan), self.FLUX_INDEX,
            axis_labels = [None, None, site_names, None])
        self._state_by_depth = L4CStratifiedState(
            self.DEPTHS.size, config[&#39;site_count&#39;],
            labels = (&#39;rh&#39;, *self.DIAGNOSTICS_INDEX),
            axis_labels = [
                None, None, self.DEPTHS.ravel().tolist(), site_names, None
            ])
        self._state = L4CStratifiedState(
            self.DEPTHS.size, config[&#39;site_count&#39;], axis_labels = [
                None, None, self.DEPTHS.ravel().tolist(), site_names, None
            ])

    def rh(self, state, drivers):
        &#39;&#39;&#39;
        Calculate heterotrophic respiration (RH) for a single time step.

        Parameters
        ----------
        state : numpy.ndarray
            `(3 x N x M)` array of current SOC state in each pool
        drivers : list or tuple
            Sequence of `numpy.ndarray`: `(tsoil, sm)` where `tsoil` is the
            the soil temperature and `sm` is the soil moisture, each is a
            (Z x N x M) array

        Returns
        -------
        numpy.ndarray
            Heterotrophic respiration (g C m-2 day-1)
        &#39;&#39;&#39;
        # Translate Tsoil and SMSF into environmental constraints on RH
        tsoil, sm = drivers
        f_tsoil = self.constrain(tsoil, &#39;tsoil&#39;)
        f_sm = self.constrain(sm, &#39;smsf&#39;)
        # Extinction rate of heterotrophic respiration with depth, due to
        #   factors OTHER THAN temperature, moisture (Koven et al. 2013)
        f_z = np.exp(
            -np.abs(self.DEPTHS[...,None]) / self.constants.k_depth_decay)
        k_mult = f_tsoil * f_sm
        k_mult = k_mult[np.newaxis,...].repeat(3, axis = 0)
        # NOTE: These are true decay rates for 2nd and 3rd pools, so it
        #   is straightforward to multiply them against SOC
        rh = (k_mult * f_z) * (self.constants.decay_rates[:,None,...] * state)
        # &#34;the adjustment...to account for material transferred into the
        #   slow pool during humification&#34; (Jones et al. 2017 TGARS, p.5)
        rh[1,...] = rh[1,...] * (1 - self.constants.f_structural)
        # T_mult, W_mult same for each pool
        return (rh, (f_tsoil, f_sm))


class L4CStratifiedModel(
        StratifiedRespirationMixin, StratifiedLitterfallMixin,
        L4CForwardProcessPoint):
    &#39;&#39;&#39;
    Variation on SMAP L4C model, but vertically stratified SOC.

    Notes for developers:

    1. The litterfall constant is not set, as the `L4CConstant` class does
    not have support for vertical discretization. Instead, litterfall is
    read in at `L4CStratifiedModel.run()` and consumed by the private
    `step()` method of that function.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    litterfall_schedule : bool
        True if litterfall is a function of day-of-year (DOY); False if
        litterfall is a pre-computed fraction of daily NPP (Default: False)
    stream : bool
        True to use `L4CStreamingInputDataset` instead of reading in all
        driver data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    # All DEPTHS must be positive
    DEPTHS = np.array((0.05, 0.15, 0.35, 0.75, 1.5, 3.0))\
        .reshape((6,1)) # meters
    # Get change in depth (layer thickness)
    DELTA_Z = (DEPTHS - np.vstack((0, DEPTHS[:-1])))\
        .reshape((DEPTHS.size, 1, 1))
    DIFFUSIVITY = 2e-4 # m2 yr-1 (Yi et al. 2020)
    PFT_CODES = range(1, 9)
    CONSTANTS_INDEX = (
        &#39;CUE&#39;, &#39;LUE&#39;, &#39;f_metabolic&#39;, &#39;f_structural&#39;, &#39;decay_rates&#39;,
        &#39;k_depth_decay&#39;)
    DIAGNOSTICS_INDEX = (&#39;f_tsoil&#39;, &#39;f_sm&#39;)
    FLUX_INDEX = (&#39;nee&#39;,) # NOTE: Ignoring GPP; RH tracked separately
    STATE_INDEX = (&#39;soc1&#39;, &#39;soc2&#39;, &#39;soc3&#39;) # NOTE: RH is vertically stratified

    def __init__(
            self, config, litterfall_schedule = False, stream = True,
            verbose = True, debug = False):
        for key in (&#39;extra_parameters&#39;, &#39;soc_data_path&#39;):
            assert key in config.keys(),\
                &#39;L4CPhenologyProcess model requires &#34;%s&#34; configuration key&#39; % key
        super().__init__(
            config = config, stream = stream, verbose = verbose, debug = debug)
        self._multilayer = True # Multi-layer model
        self._scheduled = litterfall_schedule
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            site_names = hdf[&#39;site_id&#39;][:].tolist()
        if config[&#39;extra_parameters&#39;] is not None:
            with open(config[&#39;extra_parameters&#39;], &#39;rb&#39;) as file:
                data_dict = pickle.load(file)
            # Identify the extra parameters
            params = set(data_dict.keys()).difference(self._bplut.keys())
            # In case a parameter doesn&#39;t belong (i.e., they are all NaN),
            #   remove it
            for p in list(params):
                if np.isnan(data_dict[p]).all():
                    print(&#39;WARNING: Ignoring all-NaN parameter &#34;%s&#34;&#39; % p)
                    params.remove(p)
            with h5py.File(self.file_path, &#39;r&#39;) as hdf:
                # Set invalid PFT codes to PFT 0
                self._pft = np.where(self._pft &gt; max(self.PFT_CODES), 0, self._pft)
                # Vectorize the new parameters
                self._extra_params = dict([
                    (p, data_dict[p][self._pft]) for p in params
                ])
        # After Yi et al. (2020), diffusivity declines linearly with depth to
        #   3 meters; also convert to units of m2 day-1
        self.diffusivity = (self.DIFFUSIVITY / 365) *\
            linear_constraint(0, 3, form = &#39;reversed&#39;)(np.abs(self.DEPTHS))
        # Initialize the vertically discretized state
        self.state_by_depth = np.full((
            1 + len(self.DIAGNOSTICS_INDEX), config[&#39;time_steps&#39;],
            self.DEPTHS.size, len(site_names), 81
        ), np.nan, dtype = np.float32)

    @property
    def state_by_depth(self):
        return self._state_by_depth

    @state_by_depth.setter
    def state_by_depth(self, new):
        self._state_by_depth.data = new

    def run(self, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: `None`)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, fields_gpp, soil_t, soil_m, litterfall):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve initial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            gpp, _ = self.gpp(
                zip(hdf.index(t + self._t0, *fields_gpp), fields_gpp))
            rh, k_mult = self.rh(state, (soil_t, soil_m))
            f_tsoil, f_sm = k_mult
            npp = gpp * self.constants.CUE
            # NOTE: Litterfall inputs may not scheduled
            d_soc = self.soc(
                state, rh, litterfall, t + self._t0,
                scheduled = self._scheduled)
            # Update RH in each soil layer, convert from g C m-3 to g C m-2
            rh = np.nansum(rh, axis = 0) * self.DELTA_Z
            self.state_by_depth.update(&#39;rh&#39;, t, rh)
            self.state_by_depth.update(&#39;f_tsoil&#39;, t, f_tsoil)
            self.state_by_depth.update(&#39;f_sm&#39;, t, f_sm)
            # Update NEE, taking sum of RH across all soil layers
            self.fluxes.update(&#39;nee&#39;, t, np.nansum(rh, axis = 0) - npp)
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

        # Load supplemental datasets
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            porosity = hdf[&#39;state/porosity&#39;][:]
        with h5py.File(TSOIL_HDF, &#39;r&#39;) as hdf:
            # Calculate extent of soil layers, given bedrock depth
            bedrock = hdf[&#39;LAND_MODEL_CONSTANTS/depth_to_bedrock_m&#39;][:]
            layer_mask = self.DEPTHS &lt; bedrock
            # &#34;surface_temp&#34; is used for the surface layer (0-5 cm)
            soil_t = []
            soil_t.append(hdf[&#39;L4SM_DAILY_MEAN/surface_temp&#39;][self._t0:,:])
            for i in range(1, self.DEPTHS.size):
                soil_t.append(
                    hdf[&#39;L4SM_DAILY_MEAN/soil_temp_layer%d&#39; % i][self._t0:,:])
            soil_t = np.stack(soil_t)
            # Mask out measurements below bedrock depth
            soil_t.swapaxes(1, 2)[~layer_mask,...] = np.nan
        with h5py.File(SM_HDF, &#39;r&#39;) as hdf:
            soil_m = 100 * np.divide(
                hdf[&#39;soil_moisture_vwc&#39;][:,self._t0:,:], porosity)
            # Clip f(SM) response, as wetness values might be unrealistic
            #   given problems in ice-filled soil layers
            soil_m[soil_m &gt; 100] = 100
            # Mask out measurements below bedrock depth
            soil_m.swapaxes(1, 2)[~layer_mask,...] = np.nan
        porosity = None
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS) as hdf:
            fields_gpp = [&#39;apar&#39;, &#39;tmin&#39;, &#39;vpd&#39;, &#39;ft&#39;, &#39;smrz&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(
                        t, fields_gpp, soil_t[:,t,:,None], soil_m[:,t,:,None],
                        litterfall)
                    self._time_idx += 1
                    progress.update(t)


class L4CStratifiedDiffusionModel(
        O2DiffusionLimitMixin, L4CStratifiedModel):
    &#39;&#39;&#39;
    Variation on SMAP L4C model, but with:

    1. Vertically stratified soil organic carbon (SOC); and
    2. Oxygen diffusion limitation for heterotrophic respiration (RH).

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    litterfall_schedule : bool
        True if litterfall is a function of day-of-year (DOY); False if
        litterfall is a pre-computed fraction of daily NPP (Default: False)
    stream : bool
        True to use `L4CStreamingInputDataset` instead of reading in all
        driver data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    CONSTANTS_INDEX = (
        &#39;CUE&#39;, &#39;LUE&#39;, &#39;f_metabolic&#39;, &#39;f_structural&#39;, &#39;decay_rates&#39;,
        &#39;k_depth_decay&#39;, &#39;d_gas&#39;, &#39;km_oxy&#39;)
    DIAGNOSTICS_INDEX = (&#39;f_tsoil&#39;, &#39;f_sm&#39;, &#39;mm_O2&#39;)
    FLUX_INDEX = (&#39;nee&#39;,) # NOTE: Ignoring GPP; RH tracked separately
    STATE_INDEX = (&#39;soc1&#39;, &#39;soc2&#39;, &#39;soc3&#39;) # NOTE: RH is vertically stratified

    def run(self, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: `None`)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, fields_gpp, soil_t, soil_m, soil_vwc, litterfall):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve initial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            gpp, _ = self.gpp(
                zip(hdf.index(t + self._t0, *fields_gpp), fields_gpp))
            rh, k_mult = self.rh(state, (soil_t, soil_m, soil_vwc))
            f_tsoil, f_sm, mm_O2 = k_mult
            npp = gpp * self.constants.CUE
            # NOTE: Litterfall inputs may not scheduled
            d_soc = self.soc(
                state, rh, litterfall, t + self._t0,
                scheduled = self._scheduled)
            # Update RH in each soil layer, convert from g C m-3 to g C m-2
            rh = np.nansum(rh, axis = 0) * self.DELTA_Z
            self.state_by_depth.update(&#39;rh&#39;, t, rh)
            self.state_by_depth.update(&#39;f_tsoil&#39;, t, f_tsoil)
            self.state_by_depth.update(&#39;f_sm&#39;, t, f_sm)
            self.state_by_depth.update(&#39;mm_O2&#39;, t, mm_O2)
            # Update NEE, taking sum of RH across all soil layers
            self.fluxes.update(&#39;nee&#39;, t, np.nansum(rh, axis = 0) - npp)
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

        # Load supplemental datasets
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            self.porosity = hdf[&#39;state/porosity&#39;][:]
        with h5py.File(TSOIL_HDF, &#39;r&#39;) as hdf:
            # Calculate extent of soil layers, given bedrock depth
            bedrock = hdf[&#39;LAND_MODEL_CONSTANTS/depth_to_bedrock_m&#39;][:]
            layer_mask = self.DEPTHS &lt; bedrock
            # &#34;surface_temp&#34; is used for the surface layer (0-5 cm)
            soil_t = []
            soil_t.append(hdf[&#39;L4SM_DAILY_MEAN/surface_temp&#39;][self._t0:,:])
            for i in range(1, self.DEPTHS.size):
                soil_t.append(
                    hdf[&#39;L4SM_DAILY_MEAN/soil_temp_layer%d&#39; % i][self._t0:,:])
            soil_t = np.stack(soil_t)
            # Mask out measurements below bedrock depth
            soil_t.swapaxes(1, 2)[~layer_mask,...] = np.nan
        with h5py.File(SM_HDF, &#39;r&#39;) as hdf:
            soil_vwc = hdf[&#39;soil_moisture_vwc&#39;][:,self._t0:,:]
            soil_m = 100 * np.divide(soil_vwc, self.porosity)
            # Clip f(SM) response, as wetness values might be unrealistic
            #   given problems in ice-filled soil layers
            soil_m[soil_m &gt; 100] = 100
            # Mask out measurements below bedrock depth
            soil_m.swapaxes(1, 2)[~layer_mask,...] = np.nan
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS) as hdf:
            fields_gpp = [&#39;apar&#39;, &#39;tmin&#39;, &#39;vpd&#39;, &#39;ft&#39;, &#39;smrz&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(
                        t, fields_gpp, soil_t[:,t,:,None], soil_m[:,t,:,None],
                        soil_vwc[:,t,:,None], litterfall)
                    self._time_idx += 1
                    progress.update(t)


class L4CStratifiedLitterfallModel(L4CStratifiedModel):
    &#39;&#39;&#39;
    Variation on SMAP L4C model, but with:

    1. Vertically stratified soil organic carbon (SOC); and
    2. Litterfall phenology, wherein average daily litterfall varies overy a
        365-day climatological year, according to the CASA scheme.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    litterfall_schedule : bool
        NOTE: Cannot be changed, defaults to True; see
        `pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel`
    stream : bool
        True to use `L4CStreamingInputDataset` instead of reading in all
        driver data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    CONSTANTS_INDEX = (
        &#39;CUE&#39;, &#39;LUE&#39;, &#39;f_metabolic&#39;, &#39;f_structural&#39;, &#39;decay_rates&#39;,
        &#39;k_depth_decay&#39;)
    DIAGNOSTICS_INDEX = (&#39;f_tsoil&#39;, &#39;f_sm&#39;)
    FLUX_INDEX = (&#39;nee&#39;,) # NOTE: Ignoring GPP; RH tracked separately
    STATE_INDEX = (&#39;soc1&#39;, &#39;soc2&#39;, &#39;soc3&#39;) # NOTE: RH is vertically stratified

    def __init__(
            self, config, litterfall_schedule = True, stream = True,
            verbose = True, debug = False):
        for key in (&#39;soc_data_path&#39;,):
            assert key in config.keys(),\
                &#39;L4CPhenologyProcess model requires &#34;%s&#34; configuration key&#39; % key
        if &#39;extra_parameters&#39; in config.keys():
            assert config[&#39;extra_parameters&#39;] is None,\
                &#39;L4CStratifiedLitterfallModel does not expect &#34;extra_parameters&#34; in configuration&#39;
        super().__init__(
            config = config, litterfall_schedule = True,
            stream = stream, verbose = verbose, debug = debug)
        # It is necessary to have a way to look up the day of year for
        #   indexing the litterfall array, which is (365 x N x 81)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            dt = [datetime.date(*t[:-1]) for t in hdf[&#39;time&#39;][:].tolist()]
            self._doy = ordinals365(dt)
        # Set the daily litterfall
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        # Overwrite the daily litterfall that was set in the parent model
        self.constants.add(litterfall, &#39;litterfall&#39;)


class L4CStratifiedDiffusionLitterfallModel(L4CStratifiedDiffusionModel):
    &#39;&#39;&#39;
    Variation on SMAP L4C model, but with:

    1. Vertically stratified soil organic carbon (SOC);
    2. Oxygen diffusion limitation for heterotrophic respiration (RH); and
    3. Litterfall phenology, wherein average daily litterfall varies overy a
        365-day climatological year, according to the CASA scheme.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    litterfall_schedule : bool
        NOTE: Cannot be changed, defaults to True; see
        `pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel`
    stream : bool
        True to use `L4CStreamingInputDataset` instead of reading in all
        driver data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    def __init__(
            self, config, litterfall_schedule = True, stream = True,
            verbose = True, debug = False):
        for key in (&#39;extra_parameters&#39;, &#39;soc_data_path&#39;):
            assert key in config.keys(),\
                &#39;L4CPhenologyProcess model requires &#34;%s&#34; configuration key&#39; % key
        super().__init__(
            config = config, litterfall_schedule = True, stream = stream,
            verbose = verbose, debug = debug)
        # It is necessary to have a way to look up the day of year for
        #   indexing the litterfall array, which is (365 x N x 81)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            dt = [datetime.date(*t[:-1]) for t in hdf[&#39;time&#39;][:].tolist()]
            self._doy = ordinals365(dt)
        # Set the daily litterfall
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        # Overwrite the daily litterfall that was set in the parent model
        self.constants.add(litterfall, &#39;litterfall&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionLitterfallModel"><code class="flex name class">
<span>class <span class="ident">L4CStratifiedDiffusionLitterfallModel</span></span>
<span>(</span><span>config, litterfall_schedule=True, stream=True, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Variation on SMAP L4C model, but with:</p>
<ol>
<li>Vertically stratified soil organic carbon (SOC);</li>
<li>Oxygen diffusion limitation for heterotrophic respiration (RH); and</li>
<li>Litterfall phenology, wherein average daily litterfall varies overy a
365-day climatological year, according to the CASA scheme.</li>
</ol>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of configuration parameters</dd>
<dt><strong><code>litterfall_schedule</code></strong> :&ensp;<code>bool</code></dt>
<dd>NOTE: Cannot be changed, defaults to True; see
<code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel">L4CStratifiedModel</a></code></dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use <code>L4CStreamingInputDataset</code> instead of reading in all
driver data; this reduces memory use but increases I/O</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to print all output to stdout</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to store additional diagnostic information from each time step</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CStratifiedDiffusionLitterfallModel(L4CStratifiedDiffusionModel):
    &#39;&#39;&#39;
    Variation on SMAP L4C model, but with:

    1. Vertically stratified soil organic carbon (SOC);
    2. Oxygen diffusion limitation for heterotrophic respiration (RH); and
    3. Litterfall phenology, wherein average daily litterfall varies overy a
        365-day climatological year, according to the CASA scheme.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    litterfall_schedule : bool
        NOTE: Cannot be changed, defaults to True; see
        `pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel`
    stream : bool
        True to use `L4CStreamingInputDataset` instead of reading in all
        driver data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    def __init__(
            self, config, litterfall_schedule = True, stream = True,
            verbose = True, debug = False):
        for key in (&#39;extra_parameters&#39;, &#39;soc_data_path&#39;):
            assert key in config.keys(),\
                &#39;L4CPhenologyProcess model requires &#34;%s&#34; configuration key&#39; % key
        super().__init__(
            config = config, litterfall_schedule = True, stream = stream,
            verbose = verbose, debug = debug)
        # It is necessary to have a way to look up the day of year for
        #   indexing the litterfall array, which is (365 x N x 81)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            dt = [datetime.date(*t[:-1]) for t in hdf[&#39;time&#39;][:].tolist()]
            self._doy = ordinals365(dt)
        # Set the daily litterfall
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        # Overwrite the daily litterfall that was set in the parent model
        self.constants.add(litterfall, &#39;litterfall&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel">L4CStratifiedDiffusionModel</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin" href="#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin">O2DiffusionLimitMixin</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel">L4CStratifiedModel</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin">StratifiedRespirationMixin</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin">StratifiedLitterfallMixin</a></li>
<li><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel">L4CStratifiedDiffusionModel</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.concentration_O2" href="#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.concentration_O2">concentration_O2</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.constrain" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain">constrain</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.gpp" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp">gpp</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.rh" href="#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.rh">rh</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.run" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.run">run</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.soc" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin.soc">soc</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel"><code class="flex name class">
<span>class <span class="ident">L4CStratifiedDiffusionModel</span></span>
<span>(</span><span>config, litterfall_schedule=False, stream=True, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Variation on SMAP L4C model, but with:</p>
<ol>
<li>Vertically stratified soil organic carbon (SOC); and</li>
<li>Oxygen diffusion limitation for heterotrophic respiration (RH).</li>
</ol>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of configuration parameters</dd>
<dt><strong><code>litterfall_schedule</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if litterfall is a function of day-of-year (DOY); False if
litterfall is a pre-computed fraction of daily NPP (Default: False)</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use <code>L4CStreamingInputDataset</code> instead of reading in all
driver data; this reduces memory use but increases I/O</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to print all output to stdout</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to store additional diagnostic information from each time step</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CStratifiedDiffusionModel(
        O2DiffusionLimitMixin, L4CStratifiedModel):
    &#39;&#39;&#39;
    Variation on SMAP L4C model, but with:

    1. Vertically stratified soil organic carbon (SOC); and
    2. Oxygen diffusion limitation for heterotrophic respiration (RH).

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    litterfall_schedule : bool
        True if litterfall is a function of day-of-year (DOY); False if
        litterfall is a pre-computed fraction of daily NPP (Default: False)
    stream : bool
        True to use `L4CStreamingInputDataset` instead of reading in all
        driver data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    CONSTANTS_INDEX = (
        &#39;CUE&#39;, &#39;LUE&#39;, &#39;f_metabolic&#39;, &#39;f_structural&#39;, &#39;decay_rates&#39;,
        &#39;k_depth_decay&#39;, &#39;d_gas&#39;, &#39;km_oxy&#39;)
    DIAGNOSTICS_INDEX = (&#39;f_tsoil&#39;, &#39;f_sm&#39;, &#39;mm_O2&#39;)
    FLUX_INDEX = (&#39;nee&#39;,) # NOTE: Ignoring GPP; RH tracked separately
    STATE_INDEX = (&#39;soc1&#39;, &#39;soc2&#39;, &#39;soc3&#39;) # NOTE: RH is vertically stratified

    def run(self, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: `None`)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, fields_gpp, soil_t, soil_m, soil_vwc, litterfall):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve initial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            gpp, _ = self.gpp(
                zip(hdf.index(t + self._t0, *fields_gpp), fields_gpp))
            rh, k_mult = self.rh(state, (soil_t, soil_m, soil_vwc))
            f_tsoil, f_sm, mm_O2 = k_mult
            npp = gpp * self.constants.CUE
            # NOTE: Litterfall inputs may not scheduled
            d_soc = self.soc(
                state, rh, litterfall, t + self._t0,
                scheduled = self._scheduled)
            # Update RH in each soil layer, convert from g C m-3 to g C m-2
            rh = np.nansum(rh, axis = 0) * self.DELTA_Z
            self.state_by_depth.update(&#39;rh&#39;, t, rh)
            self.state_by_depth.update(&#39;f_tsoil&#39;, t, f_tsoil)
            self.state_by_depth.update(&#39;f_sm&#39;, t, f_sm)
            self.state_by_depth.update(&#39;mm_O2&#39;, t, mm_O2)
            # Update NEE, taking sum of RH across all soil layers
            self.fluxes.update(&#39;nee&#39;, t, np.nansum(rh, axis = 0) - npp)
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

        # Load supplemental datasets
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            self.porosity = hdf[&#39;state/porosity&#39;][:]
        with h5py.File(TSOIL_HDF, &#39;r&#39;) as hdf:
            # Calculate extent of soil layers, given bedrock depth
            bedrock = hdf[&#39;LAND_MODEL_CONSTANTS/depth_to_bedrock_m&#39;][:]
            layer_mask = self.DEPTHS &lt; bedrock
            # &#34;surface_temp&#34; is used for the surface layer (0-5 cm)
            soil_t = []
            soil_t.append(hdf[&#39;L4SM_DAILY_MEAN/surface_temp&#39;][self._t0:,:])
            for i in range(1, self.DEPTHS.size):
                soil_t.append(
                    hdf[&#39;L4SM_DAILY_MEAN/soil_temp_layer%d&#39; % i][self._t0:,:])
            soil_t = np.stack(soil_t)
            # Mask out measurements below bedrock depth
            soil_t.swapaxes(1, 2)[~layer_mask,...] = np.nan
        with h5py.File(SM_HDF, &#39;r&#39;) as hdf:
            soil_vwc = hdf[&#39;soil_moisture_vwc&#39;][:,self._t0:,:]
            soil_m = 100 * np.divide(soil_vwc, self.porosity)
            # Clip f(SM) response, as wetness values might be unrealistic
            #   given problems in ice-filled soil layers
            soil_m[soil_m &gt; 100] = 100
            # Mask out measurements below bedrock depth
            soil_m.swapaxes(1, 2)[~layer_mask,...] = np.nan
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS) as hdf:
            fields_gpp = [&#39;apar&#39;, &#39;tmin&#39;, &#39;vpd&#39;, &#39;ft&#39;, &#39;smrz&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(
                        t, fields_gpp, soil_t[:,t,:,None], soil_m[:,t,:,None],
                        soil_vwc[:,t,:,None], litterfall)
                    self._time_idx += 1
                    progress.update(t)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin" href="#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin">O2DiffusionLimitMixin</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel">L4CStratifiedModel</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin">StratifiedRespirationMixin</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin">StratifiedLitterfallMixin</a></li>
<li><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionLitterfallModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionLitterfallModel">L4CStratifiedDiffusionLitterfallModel</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.CONSTANTS_INDEX"><code class="name">var <span class="ident">CONSTANTS_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.DIAGNOSTICS_INDEX"><code class="name">var <span class="ident">DIAGNOSTICS_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.FLUX_INDEX"><code class="name">var <span class="ident">FLUX_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.STATE_INDEX"><code class="name">var <span class="ident">STATE_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin" href="#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin">O2DiffusionLimitMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.concentration_O2" href="#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.concentration_O2">concentration_O2</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.rh" href="#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.rh">rh</a></code></li>
</ul>
</li>
<li><code><b><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel">L4CStratifiedModel</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.run" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.run">run</a></code></li>
</ul>
</li>
<li><code><b><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel">L4CStratifiedModel</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.constrain" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain">constrain</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.gpp" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp">gpp</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.soc" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin.soc">soc</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel"><code class="flex name class">
<span>class <span class="ident">L4CStratifiedLitterfallModel</span></span>
<span>(</span><span>config, litterfall_schedule=True, stream=True, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Variation on SMAP L4C model, but with:</p>
<ol>
<li>Vertically stratified soil organic carbon (SOC); and</li>
<li>Litterfall phenology, wherein average daily litterfall varies overy a
365-day climatological year, according to the CASA scheme.</li>
</ol>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of configuration parameters</dd>
<dt><strong><code>litterfall_schedule</code></strong> :&ensp;<code>bool</code></dt>
<dd>NOTE: Cannot be changed, defaults to True; see
<code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel">L4CStratifiedModel</a></code></dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use <code>L4CStreamingInputDataset</code> instead of reading in all
driver data; this reduces memory use but increases I/O</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to print all output to stdout</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to store additional diagnostic information from each time step</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CStratifiedLitterfallModel(L4CStratifiedModel):
    &#39;&#39;&#39;
    Variation on SMAP L4C model, but with:

    1. Vertically stratified soil organic carbon (SOC); and
    2. Litterfall phenology, wherein average daily litterfall varies overy a
        365-day climatological year, according to the CASA scheme.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    litterfall_schedule : bool
        NOTE: Cannot be changed, defaults to True; see
        `pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel`
    stream : bool
        True to use `L4CStreamingInputDataset` instead of reading in all
        driver data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    CONSTANTS_INDEX = (
        &#39;CUE&#39;, &#39;LUE&#39;, &#39;f_metabolic&#39;, &#39;f_structural&#39;, &#39;decay_rates&#39;,
        &#39;k_depth_decay&#39;)
    DIAGNOSTICS_INDEX = (&#39;f_tsoil&#39;, &#39;f_sm&#39;)
    FLUX_INDEX = (&#39;nee&#39;,) # NOTE: Ignoring GPP; RH tracked separately
    STATE_INDEX = (&#39;soc1&#39;, &#39;soc2&#39;, &#39;soc3&#39;) # NOTE: RH is vertically stratified

    def __init__(
            self, config, litterfall_schedule = True, stream = True,
            verbose = True, debug = False):
        for key in (&#39;soc_data_path&#39;,):
            assert key in config.keys(),\
                &#39;L4CPhenologyProcess model requires &#34;%s&#34; configuration key&#39; % key
        if &#39;extra_parameters&#39; in config.keys():
            assert config[&#39;extra_parameters&#39;] is None,\
                &#39;L4CStratifiedLitterfallModel does not expect &#34;extra_parameters&#34; in configuration&#39;
        super().__init__(
            config = config, litterfall_schedule = True,
            stream = stream, verbose = verbose, debug = debug)
        # It is necessary to have a way to look up the day of year for
        #   indexing the litterfall array, which is (365 x N x 81)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            dt = [datetime.date(*t[:-1]) for t in hdf[&#39;time&#39;][:].tolist()]
            self._doy = ordinals365(dt)
        # Set the daily litterfall
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        # Overwrite the daily litterfall that was set in the parent model
        self.constants.add(litterfall, &#39;litterfall&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel">L4CStratifiedModel</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin">StratifiedRespirationMixin</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin">StratifiedLitterfallMixin</a></li>
<li><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel.CONSTANTS_INDEX"><code class="name">var <span class="ident">CONSTANTS_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel.DIAGNOSTICS_INDEX"><code class="name">var <span class="ident">DIAGNOSTICS_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel.FLUX_INDEX"><code class="name">var <span class="ident">FLUX_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel.STATE_INDEX"><code class="name">var <span class="ident">STATE_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel">L4CStratifiedModel</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.constrain" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain">constrain</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.gpp" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp">gpp</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.rh" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin.rh">rh</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.run" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.run">run</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.soc" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin.soc">soc</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel"><code class="flex name class">
<span>class <span class="ident">L4CStratifiedModel</span></span>
<span>(</span><span>config, litterfall_schedule=False, stream=True, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Variation on SMAP L4C model, but vertically stratified SOC.</p>
<p>Notes for developers:</p>
<ol>
<li>The litterfall constant is not set, as the <code>L4CConstant</code> class does
not have support for vertical discretization. Instead, litterfall is
read in at <code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.run" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.run">L4CStratifiedModel.run()</a></code> and consumed by the private
<code>step()</code> method of that function.</li>
</ol>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of configuration parameters</dd>
<dt><strong><code>litterfall_schedule</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if litterfall is a function of day-of-year (DOY); False if
litterfall is a pre-computed fraction of daily NPP (Default: False)</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to use <code>L4CStreamingInputDataset</code> instead of reading in all
driver data; this reduces memory use but increases I/O</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to print all output to stdout</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to store additional diagnostic information from each time step</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CStratifiedModel(
        StratifiedRespirationMixin, StratifiedLitterfallMixin,
        L4CForwardProcessPoint):
    &#39;&#39;&#39;
    Variation on SMAP L4C model, but vertically stratified SOC.

    Notes for developers:

    1. The litterfall constant is not set, as the `L4CConstant` class does
    not have support for vertical discretization. Instead, litterfall is
    read in at `L4CStratifiedModel.run()` and consumed by the private
    `step()` method of that function.

    Parameters
    ----------
    config : dict
        Dictionary of configuration parameters
    litterfall_schedule : bool
        True if litterfall is a function of day-of-year (DOY); False if
        litterfall is a pre-computed fraction of daily NPP (Default: False)
    stream : bool
        True to use `L4CStreamingInputDataset` instead of reading in all
        driver data; this reduces memory use but increases I/O
    verbose : bool
        True to print all output to stdout
    debug : bool
        True to store additional diagnostic information from each time step
    &#39;&#39;&#39;
    # All DEPTHS must be positive
    DEPTHS = np.array((0.05, 0.15, 0.35, 0.75, 1.5, 3.0))\
        .reshape((6,1)) # meters
    # Get change in depth (layer thickness)
    DELTA_Z = (DEPTHS - np.vstack((0, DEPTHS[:-1])))\
        .reshape((DEPTHS.size, 1, 1))
    DIFFUSIVITY = 2e-4 # m2 yr-1 (Yi et al. 2020)
    PFT_CODES = range(1, 9)
    CONSTANTS_INDEX = (
        &#39;CUE&#39;, &#39;LUE&#39;, &#39;f_metabolic&#39;, &#39;f_structural&#39;, &#39;decay_rates&#39;,
        &#39;k_depth_decay&#39;)
    DIAGNOSTICS_INDEX = (&#39;f_tsoil&#39;, &#39;f_sm&#39;)
    FLUX_INDEX = (&#39;nee&#39;,) # NOTE: Ignoring GPP; RH tracked separately
    STATE_INDEX = (&#39;soc1&#39;, &#39;soc2&#39;, &#39;soc3&#39;) # NOTE: RH is vertically stratified

    def __init__(
            self, config, litterfall_schedule = False, stream = True,
            verbose = True, debug = False):
        for key in (&#39;extra_parameters&#39;, &#39;soc_data_path&#39;):
            assert key in config.keys(),\
                &#39;L4CPhenologyProcess model requires &#34;%s&#34; configuration key&#39; % key
        super().__init__(
            config = config, stream = stream, verbose = verbose, debug = debug)
        self._multilayer = True # Multi-layer model
        self._scheduled = litterfall_schedule
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            site_names = hdf[&#39;site_id&#39;][:].tolist()
        if config[&#39;extra_parameters&#39;] is not None:
            with open(config[&#39;extra_parameters&#39;], &#39;rb&#39;) as file:
                data_dict = pickle.load(file)
            # Identify the extra parameters
            params = set(data_dict.keys()).difference(self._bplut.keys())
            # In case a parameter doesn&#39;t belong (i.e., they are all NaN),
            #   remove it
            for p in list(params):
                if np.isnan(data_dict[p]).all():
                    print(&#39;WARNING: Ignoring all-NaN parameter &#34;%s&#34;&#39; % p)
                    params.remove(p)
            with h5py.File(self.file_path, &#39;r&#39;) as hdf:
                # Set invalid PFT codes to PFT 0
                self._pft = np.where(self._pft &gt; max(self.PFT_CODES), 0, self._pft)
                # Vectorize the new parameters
                self._extra_params = dict([
                    (p, data_dict[p][self._pft]) for p in params
                ])
        # After Yi et al. (2020), diffusivity declines linearly with depth to
        #   3 meters; also convert to units of m2 day-1
        self.diffusivity = (self.DIFFUSIVITY / 365) *\
            linear_constraint(0, 3, form = &#39;reversed&#39;)(np.abs(self.DEPTHS))
        # Initialize the vertically discretized state
        self.state_by_depth = np.full((
            1 + len(self.DIAGNOSTICS_INDEX), config[&#39;time_steps&#39;],
            self.DEPTHS.size, len(site_names), 81
        ), np.nan, dtype = np.float32)

    @property
    def state_by_depth(self):
        return self._state_by_depth

    @state_by_depth.setter
    def state_by_depth(self, new):
        self._state_by_depth.data = new

    def run(self, steps = None):
        &#39;&#39;&#39;
        A forward run in serial over multiple time steps; currently works in
        streaming mode ONLY.

        Parameters
        ----------
        steps : int
            Number of time steps to run or None to run through the end of the
            available time steps (exhaust driver data) (Default: `None`)
        &#39;&#39;&#39;
        @suppress_warnings
        def step(t, fields_gpp, soil_t, soil_m, litterfall):
            &#39;Calculate fluxes, new states for the next time step t&#39;
            if t == 0:
                # Retrieve initial SOC pool sizes
                state = self.state_initial[0:3,0,...]
            else:
                # Retrieve SOC in each pool from prior step
                state = self.state.data[0:3,t-1,...]
            # Calculate fluxes, new states
            gpp, _ = self.gpp(
                zip(hdf.index(t + self._t0, *fields_gpp), fields_gpp))
            rh, k_mult = self.rh(state, (soil_t, soil_m))
            f_tsoil, f_sm = k_mult
            npp = gpp * self.constants.CUE
            # NOTE: Litterfall inputs may not scheduled
            d_soc = self.soc(
                state, rh, litterfall, t + self._t0,
                scheduled = self._scheduled)
            # Update RH in each soil layer, convert from g C m-3 to g C m-2
            rh = np.nansum(rh, axis = 0) * self.DELTA_Z
            self.state_by_depth.update(&#39;rh&#39;, t, rh)
            self.state_by_depth.update(&#39;f_tsoil&#39;, t, f_tsoil)
            self.state_by_depth.update(&#39;f_sm&#39;, t, f_sm)
            # Update NEE, taking sum of RH across all soil layers
            self.fluxes.update(&#39;nee&#39;, t, np.nansum(rh, axis = 0) - npp)
            # Update the SOC state
            for p in range(1, 4):
                if t == 0:
                    # At time t=0, we have no state to advance, so update
                    #   the state at t=0 based on the initial state
                    delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                    self.state.update(
                        &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
                else:
                    self.state.advance(
                        &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

        # Load supplemental datasets
        with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
            litterfall, _ = pickle.load(file)
        with h5py.File(self.file_path, &#39;r&#39;) as hdf:
            porosity = hdf[&#39;state/porosity&#39;][:]
        with h5py.File(TSOIL_HDF, &#39;r&#39;) as hdf:
            # Calculate extent of soil layers, given bedrock depth
            bedrock = hdf[&#39;LAND_MODEL_CONSTANTS/depth_to_bedrock_m&#39;][:]
            layer_mask = self.DEPTHS &lt; bedrock
            # &#34;surface_temp&#34; is used for the surface layer (0-5 cm)
            soil_t = []
            soil_t.append(hdf[&#39;L4SM_DAILY_MEAN/surface_temp&#39;][self._t0:,:])
            for i in range(1, self.DEPTHS.size):
                soil_t.append(
                    hdf[&#39;L4SM_DAILY_MEAN/soil_temp_layer%d&#39; % i][self._t0:,:])
            soil_t = np.stack(soil_t)
            # Mask out measurements below bedrock depth
            soil_t.swapaxes(1, 2)[~layer_mask,...] = np.nan
        with h5py.File(SM_HDF, &#39;r&#39;) as hdf:
            soil_m = 100 * np.divide(
                hdf[&#39;soil_moisture_vwc&#39;][:,self._t0:,:], porosity)
            # Clip f(SM) response, as wetness values might be unrealistic
            #   given problems in ice-filled soil layers
            soil_m[soil_m &gt; 100] = 100
            # Mask out measurements below bedrock depth
            soil_m.swapaxes(1, 2)[~layer_mask,...] = np.nan
        porosity = None
        with L4CStreamingInputDataset(
                self.file_path, self.CONSTANTS, self.BOUNDS) as hdf:
            fields_gpp = [&#39;apar&#39;, &#39;tmin&#39;, &#39;vpd&#39;, &#39;ft&#39;, &#39;smrz&#39;]
            num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
            with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
                for t in range(self._time_idx + 1, num_steps):
                    step(
                        t, fields_gpp, soil_t[:,t,:,None], soil_m[:,t,:,None],
                        litterfall)
                    self._time_idx += 1
                    progress.update(t)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin">StratifiedRespirationMixin</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin">StratifiedLitterfallMixin</a></li>
<li><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel">L4CStratifiedDiffusionModel</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel">L4CStratifiedLitterfallModel</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.CONSTANTS_INDEX"><code class="name">var <span class="ident">CONSTANTS_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.DELTA_Z"><code class="name">var <span class="ident">DELTA_Z</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.DEPTHS"><code class="name">var <span class="ident">DEPTHS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.DIAGNOSTICS_INDEX"><code class="name">var <span class="ident">DIAGNOSTICS_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.DIFFUSIVITY"><code class="name">var <span class="ident">DIFFUSIVITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.FLUX_INDEX"><code class="name">var <span class="ident">FLUX_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.PFT_CODES"><code class="name">var <span class="ident">PFT_CODES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.STATE_INDEX"><code class="name">var <span class="ident">STATE_INDEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.state_by_depth"><code class="name">var <span class="ident">state_by_depth</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state_by_depth(self):
    return self._state_by_depth</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, steps=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A forward run in serial over multiple time steps; currently works in
streaming mode ONLY.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>steps</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of time steps to run or None to run through the end of the
available time steps (exhaust driver data) (Default: <code>None</code>)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, steps = None):
    &#39;&#39;&#39;
    A forward run in serial over multiple time steps; currently works in
    streaming mode ONLY.

    Parameters
    ----------
    steps : int
        Number of time steps to run or None to run through the end of the
        available time steps (exhaust driver data) (Default: `None`)
    &#39;&#39;&#39;
    @suppress_warnings
    def step(t, fields_gpp, soil_t, soil_m, litterfall):
        &#39;Calculate fluxes, new states for the next time step t&#39;
        if t == 0:
            # Retrieve initial SOC pool sizes
            state = self.state_initial[0:3,0,...]
        else:
            # Retrieve SOC in each pool from prior step
            state = self.state.data[0:3,t-1,...]
        # Calculate fluxes, new states
        gpp, _ = self.gpp(
            zip(hdf.index(t + self._t0, *fields_gpp), fields_gpp))
        rh, k_mult = self.rh(state, (soil_t, soil_m))
        f_tsoil, f_sm = k_mult
        npp = gpp * self.constants.CUE
        # NOTE: Litterfall inputs may not scheduled
        d_soc = self.soc(
            state, rh, litterfall, t + self._t0,
            scheduled = self._scheduled)
        # Update RH in each soil layer, convert from g C m-3 to g C m-2
        rh = np.nansum(rh, axis = 0) * self.DELTA_Z
        self.state_by_depth.update(&#39;rh&#39;, t, rh)
        self.state_by_depth.update(&#39;f_tsoil&#39;, t, f_tsoil)
        self.state_by_depth.update(&#39;f_sm&#39;, t, f_sm)
        # Update NEE, taking sum of RH across all soil layers
        self.fluxes.update(&#39;nee&#39;, t, np.nansum(rh, axis = 0) - npp)
        # Update the SOC state
        for p in range(1, 4):
            if t == 0:
                # At time t=0, we have no state to advance, so update
                #   the state at t=0 based on the initial state
                delta = np.add(self.state_initial[p-1,0,...], d_soc[p-1])
                self.state.update(
                    &#39;soc%d&#39; % p, t, delta, bounds = (0, np.inf))
            else:
                self.state.advance(
                    &#39;soc%d&#39; % p, t, d_soc[p-1], bounds = (0, np.inf))

    # Load supplemental datasets
    with open(self.config[&#39;soc_data_path&#39;], &#39;rb&#39;) as file:
        litterfall, _ = pickle.load(file)
    with h5py.File(self.file_path, &#39;r&#39;) as hdf:
        porosity = hdf[&#39;state/porosity&#39;][:]
    with h5py.File(TSOIL_HDF, &#39;r&#39;) as hdf:
        # Calculate extent of soil layers, given bedrock depth
        bedrock = hdf[&#39;LAND_MODEL_CONSTANTS/depth_to_bedrock_m&#39;][:]
        layer_mask = self.DEPTHS &lt; bedrock
        # &#34;surface_temp&#34; is used for the surface layer (0-5 cm)
        soil_t = []
        soil_t.append(hdf[&#39;L4SM_DAILY_MEAN/surface_temp&#39;][self._t0:,:])
        for i in range(1, self.DEPTHS.size):
            soil_t.append(
                hdf[&#39;L4SM_DAILY_MEAN/soil_temp_layer%d&#39; % i][self._t0:,:])
        soil_t = np.stack(soil_t)
        # Mask out measurements below bedrock depth
        soil_t.swapaxes(1, 2)[~layer_mask,...] = np.nan
    with h5py.File(SM_HDF, &#39;r&#39;) as hdf:
        soil_m = 100 * np.divide(
            hdf[&#39;soil_moisture_vwc&#39;][:,self._t0:,:], porosity)
        # Clip f(SM) response, as wetness values might be unrealistic
        #   given problems in ice-filled soil layers
        soil_m[soil_m &gt; 100] = 100
        # Mask out measurements below bedrock depth
        soil_m.swapaxes(1, 2)[~layer_mask,...] = np.nan
    porosity = None
    with L4CStreamingInputDataset(
            self.file_path, self.CONSTANTS, self.BOUNDS) as hdf:
        fields_gpp = [&#39;apar&#39;, &#39;tmin&#39;, &#39;vpd&#39;, &#39;ft&#39;, &#39;smrz&#39;]
        num_steps = self.config[&#39;time_steps&#39;] if steps is None else steps
        with ProgressBar(num_steps, &#39;Running...&#39;) as progress:
            for t in range(self._time_idx + 1, num_steps):
                step(
                    t, fields_gpp, soil_t[:,t,:,None], soil_m[:,t,:,None],
                    litterfall)
                self._time_idx += 1
                progress.update(t)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin">StratifiedRespirationMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin.rh" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin.rh">rh</a></code></li>
</ul>
</li>
<li><code><b><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin">StratifiedLitterfallMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin.soc" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin.soc">soc</a></code></li>
</ul>
</li>
<li><code><b><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint">L4CForwardProcessPoint</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.constrain">constrain</a></code></li>
<li><code><a title="pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp" href="../main.html#pyl4c.apps.l4c.main.L4CForwardProcessPoint.gpp">gpp</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin"><code class="flex name class">
<span>class <span class="ident">O2DiffusionLimitMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Provides an O2 diffusion limit as a mix-in. Not to be instantiated
directly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class O2DiffusionLimitMixin:
    &#39;&#39;&#39;
    Provides an O2 diffusion limit as a mix-in. Not to be instantiated
    directly.
    &#39;&#39;&#39;
    def concentration_O2(self, soil_vwc):
        &#39;Concentration of O2 given soil vegetation water content (VWC)&#39;
        d_gas = self._extra_params[&#39;d_gas&#39;]
        return d_gas * self.AIR_FRAC_O2 * np.power(
            self._porosity - soil_vwc, 4/3)

    def rh(self, state, drivers):
        &#39;&#39;&#39;
        Calculate RH for a single time step.

        Parameters
        ----------
        state : numpy.ndarray
            `(3 x N x M)` array of current SOC state in each pool
        drivers : list or tuple
            Sequence of `numpy.ndarray`: `(tsoil, smsf)` where `tsoil` is the
            the soil temperature and `smsf` is the surface soil moisture, each
            is an (N x M) array

        Returns
        -------
        numpy.ndarray
        &#39;&#39;&#39;
        # Translate Tsoil and SMSF into environmental constraints on RH
        tsoil, smsf = drivers
        # Some classes pass zipped (array, label) pairs for the drivers,
        #   others just pass arrays
        if hasattr(tsoil, &#39;ndim&#39;):
            f_tsoil = self.constrain(tsoil, &#39;tsoil&#39;)
            f_smsf = self.constrain(smsf, &#39;smsf&#39;)
        else:
            f_tsoil = self.constrain(tsoil)
            f_smsf = self.constrain(*smsf)
            smsf, _ = smsf # Pop off the label &#34;smsf&#34; and just get the data
        # NOTE: Converting from &#34;wetness&#34; to volumetric water content (VWC)
        #   (in % units); this requires multiplying (wetness * porosity) as
        #   (wetness = VWC / porosity)
        soil_vwc = np.multiply(smsf / 100, self._porosity)
        conc_O2 = self.concentration_O2(soil_vwc)
        mm_O2 = conc_O2 / (self._extra_params[&#39;km_oxy&#39;] + conc_O2)
        # Take the minimum of the SMSF and Soil VWC constraint
        k_mult = f_tsoil * np.min(np.stack((f_smsf, mm_O2)), axis = 0)
        k_mult = k_mult[np.newaxis,...].repeat(3, axis = 0)
        # NOTE: These are true decay rates for 2nd and 3rd pools, so it
        #   is straightforward to multiply them against SOC
        if self._multilayer:
            rh = k_mult * self.constants.decay_rates[:,None,...] * state
        else:
            rh = k_mult * self.constants.decay_rates * state
        # &#34;the adjustment...to account for material transferred into the
        #   slow pool during humification&#34; (Jones et al. 2017 TGARS, p.5)
        rh[1,...] = rh[1,...] * (1 - self.constants.f_structural)
        # T_mult, W_mult same for each pool
        return (rh, (f_tsoil, f_smsf, conc_O2, mm_O2))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit" href="cosore.html#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithO2Limit">L4CPrescribedGPPModelWithO2Limit</a></li>
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndO2Limit" href="cosore.html#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfileAndO2Limit">L4CPrescribedGPPModelWithSoilProfileAndO2Limit</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel">L4CStratifiedDiffusionModel</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.concentration_O2"><code class="name flex">
<span>def <span class="ident">concentration_O2</span></span>(<span>self, soil_vwc)</span>
</code></dt>
<dd>
<div class="desc"><p>Concentration of O2 given soil vegetation water content (VWC)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concentration_O2(self, soil_vwc):
    &#39;Concentration of O2 given soil vegetation water content (VWC)&#39;
    d_gas = self._extra_params[&#39;d_gas&#39;]
    return d_gas * self.AIR_FRAC_O2 * np.power(
        self._porosity - soil_vwc, 4/3)</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.rh"><code class="name flex">
<span>def <span class="ident">rh</span></span>(<span>self, state, drivers)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate RH for a single time step.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd><code>(3 x N x M)</code> array of current SOC state in each pool</dd>
<dt><strong><code>drivers</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>Sequence of <code>numpy.ndarray</code>: <code>(tsoil, smsf)</code> where <code>tsoil</code> is the
the soil temperature and <code>smsf</code> is the surface soil moisture, each
is an (N x M) array</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rh(self, state, drivers):
    &#39;&#39;&#39;
    Calculate RH for a single time step.

    Parameters
    ----------
    state : numpy.ndarray
        `(3 x N x M)` array of current SOC state in each pool
    drivers : list or tuple
        Sequence of `numpy.ndarray`: `(tsoil, smsf)` where `tsoil` is the
        the soil temperature and `smsf` is the surface soil moisture, each
        is an (N x M) array

    Returns
    -------
    numpy.ndarray
    &#39;&#39;&#39;
    # Translate Tsoil and SMSF into environmental constraints on RH
    tsoil, smsf = drivers
    # Some classes pass zipped (array, label) pairs for the drivers,
    #   others just pass arrays
    if hasattr(tsoil, &#39;ndim&#39;):
        f_tsoil = self.constrain(tsoil, &#39;tsoil&#39;)
        f_smsf = self.constrain(smsf, &#39;smsf&#39;)
    else:
        f_tsoil = self.constrain(tsoil)
        f_smsf = self.constrain(*smsf)
        smsf, _ = smsf # Pop off the label &#34;smsf&#34; and just get the data
    # NOTE: Converting from &#34;wetness&#34; to volumetric water content (VWC)
    #   (in % units); this requires multiplying (wetness * porosity) as
    #   (wetness = VWC / porosity)
    soil_vwc = np.multiply(smsf / 100, self._porosity)
    conc_O2 = self.concentration_O2(soil_vwc)
    mm_O2 = conc_O2 / (self._extra_params[&#39;km_oxy&#39;] + conc_O2)
    # Take the minimum of the SMSF and Soil VWC constraint
    k_mult = f_tsoil * np.min(np.stack((f_smsf, mm_O2)), axis = 0)
    k_mult = k_mult[np.newaxis,...].repeat(3, axis = 0)
    # NOTE: These are true decay rates for 2nd and 3rd pools, so it
    #   is straightforward to multiply them against SOC
    if self._multilayer:
        rh = k_mult * self.constants.decay_rates[:,None,...] * state
    else:
        rh = k_mult * self.constants.decay_rates * state
    # &#34;the adjustment...to account for material transferred into the
    #   slow pool during humification&#34; (Jones et al. 2017 TGARS, p.5)
    rh[1,...] = rh[1,...] * (1 - self.constants.f_structural)
    # T_mult, W_mult same for each pool
    return (rh, (f_tsoil, f_smsf, conc_O2, mm_O2))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin"><code class="flex name class">
<span>class <span class="ident">StratifiedLitterfallMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Provides the CASA litterfall phenology for a vertical soil profile as a
mix-in; not meant to be instantiated directly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StratifiedLitterfallMixin:
    &#39;&#39;&#39;
    Provides the CASA litterfall phenology for a vertical soil profile as a
    mix-in; not meant to be instantiated directly.
    &#39;&#39;&#39;
    def soc(self, state, rh, litterfall, t, scheduled = True):
        &#39;&#39;&#39;
        Calculate change in soil organic carbon (SOC) for a single time step.

        Parameters
        ----------
        state : numpy.ndarray
            `(3 x Z x N x M)` array of SOC at the previous time step
        rh : numpy.ndarray
            `(3 x Z x N x M)` array of RH at the current time step
        litterfall : numpy.ndarray
            `(365 x Z x N x M)` array of average daily litterfall throughout
            the 365-day climatological year
        t : int
            Current time step
        scheduled : bool
            True if litterfall is a function of day-of-year (DOY); False if
            litterfall is a pre-computed fraction of daily NPP (Default: True)

        Returns
        -------
        numpy.ndarray
        &#39;&#39;&#39;
        if scheduled:
            doy = self._doy[t] - 1 # Get DOY on [1,365] then on [0,364] for Python
            litter = litterfall[:,doy,...]
        else:
            litter = litterfall
        # Change in Cmet, Cstr, Crec with depth (z)
        shp = state.shape[-2:]
        dc0_dz = (state[0] - np.vstack((np.zeros((1, *shp)), state[0,:-1]))) / self.DELTA_Z
        dc1_dz = (state[1] - np.vstack((np.zeros((1, *shp)), state[1,:-1]))) / self.DELTA_Z
        dc2_dz = (state[1] - np.vstack((np.zeros((1, *shp)), state[2,:-1]))) / self.DELTA_Z
        # Change in diffusivity with depth (z)
        diff0 = self.diffusivity[:,None] * dc0_dz
        diff1 = self.diffusivity[:,None] * dc1_dz
        diff2 = self.diffusivity[:,None] * dc2_dz
        dd0_dz = (diff0 - np.vstack((np.zeros((1, *shp)), diff0[:-1]))) / self.DELTA_Z
        dd1_dz = (diff1 - np.vstack((np.zeros((1, *shp)), diff1[:-1]))) / self.DELTA_Z
        dd2_dz = (diff2 - np.vstack((np.zeros((1, *shp)), diff2[:-1]))) / self.DELTA_Z
        # Change in SOC according to diff. eq. in Jones et al. (2017)
        dc1 = (litter * self.constants.f_metabolic) - rh[0,...] + dd0_dz
        dc2 = (litter * (1 - self.constants.f_metabolic)) - rh[1,...] + dd1_dz
        dc3 = (self.constants.f_structural * rh[1,...]) - rh[2,...] + dd2_dz
        return (dc1, dc2, dc3)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile" href="cosore.html#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile">L4CPrescribedGPPModelWithSoilProfile</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel">L4CStratifiedModel</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin.soc"><code class="name flex">
<span>def <span class="ident">soc</span></span>(<span>self, state, rh, litterfall, t, scheduled=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate change in soil organic carbon (SOC) for a single time step.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd><code>(3 x Z x N x M)</code> array of SOC at the previous time step</dd>
<dt><strong><code>rh</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd><code>(3 x Z x N x M)</code> array of RH at the current time step</dd>
<dt><strong><code>litterfall</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd><code>(365 x Z x N x M)</code> array of average daily litterfall throughout
the 365-day climatological year</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>int</code></dt>
<dd>Current time step</dd>
<dt><strong><code>scheduled</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if litterfall is a function of day-of-year (DOY); False if
litterfall is a pre-computed fraction of daily NPP (Default: True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soc(self, state, rh, litterfall, t, scheduled = True):
    &#39;&#39;&#39;
    Calculate change in soil organic carbon (SOC) for a single time step.

    Parameters
    ----------
    state : numpy.ndarray
        `(3 x Z x N x M)` array of SOC at the previous time step
    rh : numpy.ndarray
        `(3 x Z x N x M)` array of RH at the current time step
    litterfall : numpy.ndarray
        `(365 x Z x N x M)` array of average daily litterfall throughout
        the 365-day climatological year
    t : int
        Current time step
    scheduled : bool
        True if litterfall is a function of day-of-year (DOY); False if
        litterfall is a pre-computed fraction of daily NPP (Default: True)

    Returns
    -------
    numpy.ndarray
    &#39;&#39;&#39;
    if scheduled:
        doy = self._doy[t] - 1 # Get DOY on [1,365] then on [0,364] for Python
        litter = litterfall[:,doy,...]
    else:
        litter = litterfall
    # Change in Cmet, Cstr, Crec with depth (z)
    shp = state.shape[-2:]
    dc0_dz = (state[0] - np.vstack((np.zeros((1, *shp)), state[0,:-1]))) / self.DELTA_Z
    dc1_dz = (state[1] - np.vstack((np.zeros((1, *shp)), state[1,:-1]))) / self.DELTA_Z
    dc2_dz = (state[1] - np.vstack((np.zeros((1, *shp)), state[2,:-1]))) / self.DELTA_Z
    # Change in diffusivity with depth (z)
    diff0 = self.diffusivity[:,None] * dc0_dz
    diff1 = self.diffusivity[:,None] * dc1_dz
    diff2 = self.diffusivity[:,None] * dc2_dz
    dd0_dz = (diff0 - np.vstack((np.zeros((1, *shp)), diff0[:-1]))) / self.DELTA_Z
    dd1_dz = (diff1 - np.vstack((np.zeros((1, *shp)), diff1[:-1]))) / self.DELTA_Z
    dd2_dz = (diff2 - np.vstack((np.zeros((1, *shp)), diff2[:-1]))) / self.DELTA_Z
    # Change in SOC according to diff. eq. in Jones et al. (2017)
    dc1 = (litter * self.constants.f_metabolic) - rh[0,...] + dd0_dz
    dc2 = (litter * (1 - self.constants.f_metabolic)) - rh[1,...] + dd1_dz
    dc3 = (self.constants.f_structural * rh[1,...]) - rh[2,...] + dd2_dz
    return (dc1, dc2, dc3)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin"><code class="flex name class">
<span>class <span class="ident">StratifiedRespirationMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Provides the vertically stratified heterotrophic respiration as a mix-in;
not meant to be instantiated directly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StratifiedRespirationMixin:
    &#39;&#39;&#39;
    Provides the vertically stratified heterotrophic respiration as a mix-in;
    not meant to be instantiated directly.
    &#39;&#39;&#39;
    @suppress_warnings
    def _load_state(self, hdf, keys):
        &#39;&#39;&#39;
        Overrides original _load_state() so as to allow for vertically
        stratified SOC data.
        &#39;&#39;&#39;
        t = self.config[&#39;time_steps&#39;]
        z = self.DEPTHS.size
        n = self.config[&#39;site_count&#39;]
        soc_path = self.config[&#39;soc_data_path&#39;]
        init_state = []
        new_state = []
        with open(soc_path, &#39;rb&#39;) as file:
            _, soil_organic_carbon = pickle.load(file)
        for p, key in enumerate(keys):
            # Create an empty state array, allocated T time steps
            new_state.append(np.full((1, t, z, n, 81), np.nan))
            if key.startswith(&#39;soc&#39;):
                arr = soil_organic_carbon[p,...].astype(np.float32)
                # Filter out any NoData, which (should) only correspond to
                #   1-km subgrid pixels that are outside the PFT range [1, 8]
                init_state.append(
                    np.where(arr &lt; 0, np.nan, arr).reshape((1, 1, z, n, 81)))
            elif key not in self.DIAGNOSTICS_INDEX:
                init_state.append(
                    np.full((1, 1, z, n, 81), np.nan, dtype = np.float32))
        return (init_state, new_state)

    def _setup_data_storage(self, config, hdf):
        &#39;&#39;&#39;
        Initialize containers for various datasets; including containers with
        vertical discretization.
        &#39;&#39;&#39;
        site_names = hdf[&#39;site_id&#39;][:].tolist()
        shp = (config[&#39;time_steps&#39;], config[&#39;site_count&#39;], 81)
        self._constants = L4CConstants(
            config[&#39;site_count&#39;], self._pft, self.PFT_CODES)
        self._drivers = None
        self._fluxes = L4CState(
            config[&#39;site_count&#39;], np.full((len(self.FLUX_INDEX), *shp),
            np.nan), self.FLUX_INDEX,
            axis_labels = [None, None, site_names, None])
        self._state_by_depth = L4CStratifiedState(
            self.DEPTHS.size, config[&#39;site_count&#39;],
            labels = (&#39;rh&#39;, *self.DIAGNOSTICS_INDEX),
            axis_labels = [
                None, None, self.DEPTHS.ravel().tolist(), site_names, None
            ])
        self._state = L4CStratifiedState(
            self.DEPTHS.size, config[&#39;site_count&#39;], axis_labels = [
                None, None, self.DEPTHS.ravel().tolist(), site_names, None
            ])

    def rh(self, state, drivers):
        &#39;&#39;&#39;
        Calculate heterotrophic respiration (RH) for a single time step.

        Parameters
        ----------
        state : numpy.ndarray
            `(3 x N x M)` array of current SOC state in each pool
        drivers : list or tuple
            Sequence of `numpy.ndarray`: `(tsoil, sm)` where `tsoil` is the
            the soil temperature and `sm` is the soil moisture, each is a
            (Z x N x M) array

        Returns
        -------
        numpy.ndarray
            Heterotrophic respiration (g C m-2 day-1)
        &#39;&#39;&#39;
        # Translate Tsoil and SMSF into environmental constraints on RH
        tsoil, sm = drivers
        f_tsoil = self.constrain(tsoil, &#39;tsoil&#39;)
        f_sm = self.constrain(sm, &#39;smsf&#39;)
        # Extinction rate of heterotrophic respiration with depth, due to
        #   factors OTHER THAN temperature, moisture (Koven et al. 2013)
        f_z = np.exp(
            -np.abs(self.DEPTHS[...,None]) / self.constants.k_depth_decay)
        k_mult = f_tsoil * f_sm
        k_mult = k_mult[np.newaxis,...].repeat(3, axis = 0)
        # NOTE: These are true decay rates for 2nd and 3rd pools, so it
        #   is straightforward to multiply them against SOC
        rh = (k_mult * f_z) * (self.constants.decay_rates[:,None,...] * state)
        # &#34;the adjustment...to account for material transferred into the
        #   slow pool during humification&#34; (Jones et al. 2017 TGARS, p.5)
        rh[1,...] = rh[1,...] * (1 - self.constants.f_structural)
        # T_mult, W_mult same for each pool
        return (rh, (f_tsoil, f_sm))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile" href="cosore.html#pyl4c.apps.l4c.extensions.cosore.L4CPrescribedGPPModelWithSoilProfile">L4CPrescribedGPPModelWithSoilProfile</a></li>
<li><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel">L4CStratifiedModel</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin.rh"><code class="name flex">
<span>def <span class="ident">rh</span></span>(<span>self, state, drivers)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate heterotrophic respiration (RH) for a single time step.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd><code>(3 x N x M)</code> array of current SOC state in each pool</dd>
<dt><strong><code>drivers</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>Sequence of <code>numpy.ndarray</code>: <code>(tsoil, sm)</code> where <code>tsoil</code> is the
the soil temperature and <code>sm</code> is the soil moisture, each is a
(Z x N x M) array</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>Heterotrophic respiration (g C m-2 day-1)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rh(self, state, drivers):
    &#39;&#39;&#39;
    Calculate heterotrophic respiration (RH) for a single time step.

    Parameters
    ----------
    state : numpy.ndarray
        `(3 x N x M)` array of current SOC state in each pool
    drivers : list or tuple
        Sequence of `numpy.ndarray`: `(tsoil, sm)` where `tsoil` is the
        the soil temperature and `sm` is the soil moisture, each is a
        (Z x N x M) array

    Returns
    -------
    numpy.ndarray
        Heterotrophic respiration (g C m-2 day-1)
    &#39;&#39;&#39;
    # Translate Tsoil and SMSF into environmental constraints on RH
    tsoil, sm = drivers
    f_tsoil = self.constrain(tsoil, &#39;tsoil&#39;)
    f_sm = self.constrain(sm, &#39;smsf&#39;)
    # Extinction rate of heterotrophic respiration with depth, due to
    #   factors OTHER THAN temperature, moisture (Koven et al. 2013)
    f_z = np.exp(
        -np.abs(self.DEPTHS[...,None]) / self.constants.k_depth_decay)
    k_mult = f_tsoil * f_sm
    k_mult = k_mult[np.newaxis,...].repeat(3, axis = 0)
    # NOTE: These are true decay rates for 2nd and 3rd pools, so it
    #   is straightforward to multiply them against SOC
    rh = (k_mult * f_z) * (self.constants.decay_rates[:,None,...] * state)
    # &#34;the adjustment...to account for material transferred into the
    #   slow pool during humification&#34; (Jones et al. 2017 TGARS, p.5)
    rh[1,...] = rh[1,...] * (1 - self.constants.f_structural)
    # T_mult, W_mult same for each pool
    return (rh, (f_tsoil, f_sm))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="SMAP Mission Homepage" href="https://smap.jpl.nasa.gov/">
<img src="https://arthur-e.github.io/pyl4c/templates/images/logo_SMAP.jpg" alt="">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyl4c.apps.l4c.extensions" href="index.html">pyl4c.apps.l4c.extensions</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionLitterfallModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionLitterfallModel">L4CStratifiedDiffusionLitterfallModel</a></code></h4>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel">L4CStratifiedDiffusionModel</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.CONSTANTS_INDEX" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.CONSTANTS_INDEX">CONSTANTS_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.DIAGNOSTICS_INDEX" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.DIAGNOSTICS_INDEX">DIAGNOSTICS_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.FLUX_INDEX" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.FLUX_INDEX">FLUX_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.STATE_INDEX" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedDiffusionModel.STATE_INDEX">STATE_INDEX</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel">L4CStratifiedLitterfallModel</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel.CONSTANTS_INDEX" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel.CONSTANTS_INDEX">CONSTANTS_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel.DIAGNOSTICS_INDEX" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel.DIAGNOSTICS_INDEX">DIAGNOSTICS_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel.FLUX_INDEX" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel.FLUX_INDEX">FLUX_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel.STATE_INDEX" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedLitterfallModel.STATE_INDEX">STATE_INDEX</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel">L4CStratifiedModel</a></code></h4>
<ul class="two-column">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.CONSTANTS_INDEX" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.CONSTANTS_INDEX">CONSTANTS_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.DELTA_Z" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.DELTA_Z">DELTA_Z</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.DEPTHS" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.DEPTHS">DEPTHS</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.DIAGNOSTICS_INDEX" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.DIAGNOSTICS_INDEX">DIAGNOSTICS_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.DIFFUSIVITY" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.DIFFUSIVITY">DIFFUSIVITY</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.FLUX_INDEX" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.FLUX_INDEX">FLUX_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.PFT_CODES" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.PFT_CODES">PFT_CODES</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.STATE_INDEX" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.STATE_INDEX">STATE_INDEX</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.run" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.run">run</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.state_by_depth" href="#pyl4c.apps.l4c.extensions.hydrology.L4CStratifiedModel.state_by_depth">state_by_depth</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin" href="#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin">O2DiffusionLimitMixin</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.concentration_O2" href="#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.concentration_O2">concentration_O2</a></code></li>
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.rh" href="#pyl4c.apps.l4c.extensions.hydrology.O2DiffusionLimitMixin.rh">rh</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin">StratifiedLitterfallMixin</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin.soc" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedLitterfallMixin.soc">soc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin">StratifiedRespirationMixin</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin.rh" href="#pyl4c.apps.l4c.extensions.hydrology.StratifiedRespirationMixin.rh">rh</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>