<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyl4c.apps.l4c API documentation</title>
<meta name="description" content="SMAP Level 4 Carbon (L4C) forward run logic, including data structures for
running an L4C forward simulation. A point (site-level) version of the L4C
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:35%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyl4c.apps.l4c</code></h1>
</header>
<section id="section-intro">
<p>SMAP Level 4 Carbon (L4C) forward run logic, including data structures for
running an L4C forward simulation. A point (site-level) version of the L4C
algorithm can be examined and run in <code><a title="pyl4c.apps.l4c.main" href="main.html">pyl4c.apps.l4c.main</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
SMAP Level 4 Carbon (L4C) forward run logic, including data structures for
running an L4C forward simulation. A point (site-level) version of the L4C
algorithm can be examined and run in `pyl4c.apps.l4c.main`.
&#39;&#39;&#39;

import csv
import datetime
import warnings
import numpy as np
from functools import partial
from pyl4c import suppress_warnings
from pyl4c.lib.cli import ProgressBar

class AbstractData(object):
    &#39;&#39;&#39;
    An abstraction of a data container for running L4C simulations.
    Represents discontinuous locations or &#34;points&#34; on a global EASE-Grid 2.0
    over which to run an L4C simulation. Each &#34;point&#34; has a 1-km subgrid
    associated with the 9-km &#34;point&#34; cell.
    &#39;&#39;&#39;
    @property
    def labels(self):
        return self._data_labels

    @labels.setter
    def labels(self, new_labels):
        self._data_labels = tuple(new_labels)

    @property
    def shape(self):
        if self.data is not None:
            return self.data.shape


class L4CConstants(object):
    &#39;&#39;&#39;
    A namespace for constant values used in running L4C. These constant
    values are broadcast to an array that is conformable with driver data
    for fast and seamless computation in the forward run.

    Parameters
    ----------
    count : int
        Number of point locations (&#34;sites&#34;) used in forward simulation
    pft_array : numpy.ndarray
        Array specifying the PFT at each point location
    valid_pft : Sequence
        The valid PFT codes
    &#39;&#39;&#39;
    def __init__(self, count : int, pft_array, valid_pft = range(1, 10)):
        # Set invalid PFT codes to 0
        self._count = count
        self._pft = np.where(np.in1d(pft_array.ravel(), valid_pft),
            pft_array.ravel(), 0)

    def conformable(self, array):
        &#39;&#39;&#39;
        Creates a `(1) x N x P` array where `P` is the number of PFT classes.
        Useful for guaranteeing that an array is conformable with the other
        arrays it will be concatenated with.

        Parameters
        ----------
        array : numpy.ndarray
        &#39;&#39;&#39;
        assert array.ndim &lt;= 4, &#39;Expected ndim &lt;= 4&#39;
        if array.ndim == 1:
            # A 1D array indicates one value per PFT
            return np.apply_along_axis(
                lambda p: array[p], 0, self._pft
            ).reshape((self._count, 81))
        if array.ndim == 2:
            if array.shape == (self._count, 81):
                return array # Array already conforms
            # A 2D array indicates multiple (&#34;ndim&#34;) values per PFT
            return np.apply_along_axis(
                lambda p: array[:,p], 0, self._pft
            ).reshape((array.shape[0], self._count, 81))
        if array.ndim == 3:
            # i.e., a 365-day climatology
            assert array.shape == (365, self._count, 81),\
                &#39;No support for 3D arrays that do not have 365 elements on axis 0 (i.e., a 365-day climatology)&#39;
            return array
        if array.ndim == 4:
            assert array.shape[-3:] == (365, self._count, 81),\
                &#39;No support for 4D arrays that do not have the following sub-space: (%s)&#39; % &#39; x &#39;.join(map(str, array.shape[-3:]))
            return array

    def add(self, array, label):
        &#39;&#39;&#39;
        Adds a new constant as an attribute on this instance.

        Parameters
        ----------
        array : numpy.ndarray
            The array to add
        label : str
            The name by which this array will be known
        &#39;&#39;&#39;
        setattr(self, label, self.conformable(array))


class L4CDrivers(AbstractData):
    &#39;&#39;&#39;
    Represents a collection of L4C driver variables. Driver variables *drive*
    the model but are not in themselves updated; they are exogenous variables
    with values fixed at the start of the simulation.

    Parameters
    ----------
    count : int
        Number of point locations (&#34;sites&#34;) used in forward simulation
    drivers
    labels
    &#39;&#39;&#39;
    def __init__(self, count, drivers = None, labels = None):
        if drivers is not None and labels is not None:
            if hasattr(drivers, &#39;ndim&#39;):
                matched = drivers.shape[0] == len(labels)
            else:
                matched = len(drivers) == len(labels)
            if not matched:
                raise ValueError(&#39;There should be as many labels as there are driver variables&#39;)
        self._count = count
        self._data = None
        self._data_labels = labels
        # Use appropriate setter function
        self.data = drivers

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, new):
        if new is None:
            self._data = None
        elif hasattr(new, &#39;ndim&#39;):
            self._data = new
        else:
            # Otherwise, concat the sequence of arrays, once made conformable
            self._data = np.concatenate(list(map(
                partial(self.conformable), new)), axis = 0)

    def conformable(self, array):
        &#39;&#39;&#39;
        Given an array, returns representation that conforms to expectations.

        Parameters
        ----------
        array : numpy.ndarray
            Input data array

        Returns
        -------
        numpy.ndarray
            `(1 x T x N x 81)` array
        &#39;&#39;&#39;
        shp = array.shape
        assert (self._count in shp),\
            &#39;Array is not conformable with %d measurement points&#39; % self._count
        assert array.ndim in (2, 3, 4),\
            &#39;Driver variables should have 2, 3, or 4 axes only&#39;

        # Driver data should be (1 x T x N x 81)
        i_idx = shp.index(self._count)
        if array.ndim == 2:
            t = shp[0] if i_idx == 1 else shp[1] # Get size of time axis
            return array.swapaxes(1, i_idx).reshape((t, self._count, 1))\
                    .repeat(81, axis = 2).reshape((1, t, self._count, 81))

        # NOTE: The swapaxes() calls essentially assert place each axis into
        #   its desired position, moved from its inferred position
        j_idx = shp.index(81) if 81 in shp else shp.index(1) # Subgrid axis
        t_idx = set((0, 1, 2)).difference((i_idx, j_idx)).pop() # Time axis
        if array.ndim == 3:
            t = shp[t_idx] # Get the size of the time axis
            if shp[j_idx] == 81:
                return array.swapaxes(1, i_idx).swapaxes(2, j_idx)\
                    .reshape((1, t, self._count, 81))
            return array.swapaxes(1, i_idx).swapaxes(2, j_idx)\
                .reshape((1, t, self._count, 1)).repeat(81, axis = 3)

        if array.ndim == 4:
            return array.swapaxes(1, t_idx).swapaxes(2, i_idx)\
                .swapaxes(3, j_idx)


class L4CState(AbstractData):
    &#39;&#39;&#39;
    Represents a collection of L4C state variables. State variables influence
    the driving of the model; an initial state (at time t=0) is required to
    start running and the variable state might be updated at each time step
    (t) based on the value at step (t-1). State data are stored as
    `M x T x N x 81` arrays.

    Parameters
    ----------
    count : int
        Number of point locations (&#34;sites&#34;) used in forward simulation
    state : numpy.ndarray or None
        (Optional) Initial state
    labels : list or tuple or None
        (Optional) Sequence of labels for each state variable, should be
        the same length as the first axis of the `state` of array
    axis_labels : list or tuple or None
        Names of each axis of the stored state matrix; axes are, in order:
        (state variable, time, site, 81)
    dtype
        The data type to coerce on the state array
    &#39;&#39;&#39;
    def __init__(
            self, count : int, state = None, labels = None,
            axis_labels = None, dtype = np.float32):
        if state is not None and labels is not None:
            if hasattr(state, &#39;ndim&#39;):
                matched = state.shape[0] == len(labels)
            else:
                matched = len(state) == len(labels)
            if not matched:
                raise ValueError(&#39;There should be as many labels as there are state variables&#39;)
        self._axis_labels = axis_labels
        self._count = int(count)
        self._bounds = (0, np.inf)
        self._data = None
        self._data_labels = labels
        self._dtype = dtype
        # Use appropriate setter function
        if state is not None:
            self.data = state.astype(dtype)

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, new):
        if new is None:
            self._data = None
        elif hasattr(new, &#39;ndim&#39;):
            assert new.ndim == 4,\
                &#39;New data array must have 4 axes; should be (M x T x N x 81)&#39;
            self._data = new.astype(self._dtype)
        else:
            # Otherwise, concat the sequence of arrays, once made conformable
            self._data = np.concatenate(
                list(map(self.conformable, new)), axis = 0).astype(self._dtype)

    def _serialize(
            self, state, label, output_path, truncate, time_labels, prec,
            verbose = False):
        &#39;Argument &#34;state&#34; should be length-T sequence of length-N sequences&#39;
        now = datetime.datetime.now().strftime(&#39;%Y-%m-%d&#39;)
        site_labels = list(range(0, self._count))
        if self._axis_labels is not None:
            site_labels = self._axis_labels[-2]
            # Decode UTF-8 strings
            if hasattr(site_labels[0], &#39;decode&#39;):
                site_labels = list(map(lambda x: x.decode(), site_labels))
        with open(output_path, &#39;w&#39;) as file:
            writer = csv.writer(file)
            writer.writerow(
                (&#39;# L4C Model State %s serialized %s&#39; % (label, now),))
            writer.writerow((&#39;site&#39;, &#39;time&#39;, &#39;value&#39;))
            with ProgressBar(len(state), verbose = verbose) as progress:
                if verbose:
                    progress.prefix = &#39;Serializing...&#39;
                for t in range(0, len(state)):
                    for i, label in enumerate(site_labels):
                        # Working with a length-T sequence of length-N lists
                        writer.writerow([
                            label, time_labels[t],
                            format(state[t,i], &#39;.%df&#39; % prec)
                        ])
                    if verbose:
                        progress.update(t)

    @suppress_warnings
    def _serialize_combined(
            self, label, output_path, truncate, time_labels, prec):
        &#39;Serializes the combined (summed) state, summing across fields&#39;
        # Sum across fields, then take the mean across the 1-km subgrid
        state = np.nanmean(self.data.sum(axis = 0), axis = -1)
        if truncate is not None:
            state = state[0:truncate,...].tolist()
        else:
            state = state.tolist()
        self._serialize(
            state, label, output_path, truncate, time_labels, prec)

    def advance(self, label, t, delta = None, func = np.add, bounds = None):
        &#39;&#39;&#39;
        Updates the state data at time (t) based on the prior state (state
        at t-1). NOTE: &#34;delta&#34; is the left argument of the binary function.

        Parameters
        ----------
        label : str
            One of the labels in self.labels
        t : int
            Index of the time step to update
        delta : numpy.ndarray
            LHS of the function (func) to change state (Default: None)
        func : function
            The binary function to use to combine delta and the state
            at time (t-1) (Default: numpy.add).
        bounds : dict
        &#39;&#39;&#39;
        i = self.labels.index(label)
        if delta is not None:
            new_state = func(delta, self._data[i, t-1, ...])
            # Check for out-of-bounds
            if bounds is None:
                self._data[i, t, ...] = new_state
                return

            self._data[i, t, ...] = np.where(
                new_state &gt; bounds[1], bounds[1], np.where(
                    new_state &lt; bounds[0], bounds[0], new_state))

    def conformable(self, array, allocation = 1):
        &#39;&#39;&#39;
        Given an array, returns representation that conforms to expectations.

        Parameters
        ----------
        array : numpy.ndarray
            Input data array
        allocation : int
            Number of time steps to allocate

        Returns
        -------
        numpy.ndarray
            `(1 x T x N x 81)` array
        &#39;&#39;&#39;
        shp = array.shape
        assert (self._count in shp),\
            &#39;Array is not conformable with %d measurement points&#39; % self._count
        assert array.ndim in (2, 3),\
            &#39;State variables should have either 2 or 3 axes only&#39;

        # We want to return a (1 x T x N x 81) array; tests are somewhat
        #   verbose in light of the possibility that self._count = 81
        assert 81 in shp,\
            &#39;State variables must have a 1-km subgrid axis with 81 elements&#39;
        i_idx = shp.index(self._count)
        j_idx = shp.index(81)
        # Add concatenation (axis=0) and time (axis=1) axes, then allocate
        #   T time steps
        if array.ndim == 2:
            return np.concatenate((
                array.swapaxes(i_idx, 0).reshape((1, 1, self._count, 81)),
                np.full((1, allocation - 1, self._count, 81), np.nan)
            ), axis = 1)
        if array.ndim == 3:
            return np.concatenate((
                array.swapaxes(i_idx, 1).swapaxes(j_idx, 2)\
                    .reshape((1, 1, self._count, 81)),
                np.full((1, allocation - 1, self._count, 81), np.nan)
            ), axis = 1)

    def update(self, label, t, array, bounds = None):
        &#39;&#39;&#39;
        Updates the state data with the given label by inserting an array
        at the specified time step (t).

        Parameters
        ----------
        label : str
            One of the labels in self.labels
        t : int
            Index of the time step to update
        array : numpy.ndarray
        bounds : dict
        &#39;&#39;&#39;
        i = self.labels.index(label)
        if bounds is None:
            self._data[i, t, ...] = array
            return

        self._data[i, t, ...] = np.where(
            array &gt; bounds[1], bounds[1], np.where(
                array &lt; bounds[0], bounds[0], array))

    def serialize(
            self, output_tpl, truncate = None, time_labels = None, prec = 3,
            verbose = False):
        &#39;&#39;&#39;
        Dumps the current state to a CSV file. Data on the 1-km subgrid are
        summarized; the mean at each 9-km site is reported.

        Parameters
        ----------
        output_tpl : str
            Template filename for the output CSV file
        truncate : int
            (Optional) Largest time index that will be dumped
        time_labels : list or tuple
            (Optional) A sequence of time labels
        prec : int
            Number of decimal places to include (Default: 1)
        verbose : bool
            True to print progress of serialization
        &#39;&#39;&#39;
        assert truncate is None or (hasattr(truncate, &#39;real&#39;) and not hasattr(truncate, &#39;is_integer&#39;)), &#39;&#34;truncate&#34; must be an integer&#39;
        # Insert a string formatting character for the state&#39;s label
        output_tpl = &#39;.&#39;.join(output_tpl.split(&#39;.&#39;)[:-1])
        output_tpl = &#39;%s_%%s.csv&#39; % output_tpl

        if time_labels is None:
            time_labels = range(0, self.shape[1])
        else:
            assert isinstance(time_labels[0], str),\
                &#39;time_labels must be str type&#39;

        # Check that there are at least as many time labels as time indices
        t_max = truncate if truncate is not None else self.shape[1]
        assert len(time_labels) &gt;= t_max, &#39;Not enough time_labels!&#39;

        # If state represents SOC, combine across the SOC pools
        if all([s.startswith(&#39;soc&#39;) for s in self.labels]):
            self._serialize_combined(
                &#39;SOC&#39;, output_tpl % &#39;SOC&#39;, truncate, time_labels, prec)
            return

        # Take the mean across the 1-km subgrid
        state = self.data
        if self.data.ndim &gt; 3:
            with warnings.catch_warnings():
                warnings.simplefilter(&#39;ignore&#39;)
                state = np.nanmean(self.data, axis = -1)
        print(&#39;Datasets to serialize: %d&#39; % self.shape[0])
        for i in range(0, self.shape[0]):
            self._serialize(
                state[i,...], self.labels[i].upper(),
                output_tpl % self.labels[i].upper(), truncate, time_labels,
                prec, verbose = verbose)


class L4CStratifiedState(L4CState):
    &#39;&#39;&#39;
    Represents a collection of L4C state variables that are potentially
    stratified into vertical layers. State data are stored as
    `M x T x Z x N x 81` arrays, where `M` enumerates the different state
    variables, `Z` enumerates the depths, `T` is the time axis, and `N`
    enumerates the number of sites.

    Parameters
    ----------
    layers : int
        Number of vertical layers
    count : int
        Number of point locations (&#34;sites&#34;) used in forward simulation
    state : numpy.ndarray or None
        (Optional) Initial state
    labels : list or tuple or None
        (Optional) Sequence of labels for each state variable, should be
        the same length as the first axis of the `state` of array
    axis_labels : list or tuple or None
        Names of each axis of the stored state matrix; axes are, in order:
        (state variable, time, site, 81)
    dtype
        The data type to coerce on the state array
    &#39;&#39;&#39;
    def __init__(
            self, layers: int, count: int, state = None, labels = None,
            axis_labels = None, dtype = np.float32):
        self._layers = int(layers)
        if axis_labels is not None:
            assert len(axis_labels) == 5,\
                &#39;&#34;axis_labels&#34; should contain one sequence for each axis (5 axes)&#39;
        super().__init__(
            count = count, state = state, labels = labels,
            axis_labels = axis_labels, dtype = dtype)

    def _serialize(
            self, state, label, output_path, truncate, time_labels, prec,
            verbose = False):
        &#39;Argument &#34;state&#34; should be length-T sequence of length-N sequences&#39;
        now = datetime.datetime.now().strftime(&#39;%Y-%m-%d&#39;)
        site_labels = list(range(0, self._count))
        if self._axis_labels is not None:
            _, _, depth_labels, site_labels, _ = self._axis_labels
            # Decode UTF-8 strings
            if hasattr(site_labels[0], &#39;decode&#39;):
                site_labels = list(map(lambda x: x.decode(), site_labels))
        with open(output_path, &#39;w&#39;) as file:
            writer = csv.writer(file)
            writer.writerow(
                (&#39;# L4C Model State %s serialized %s&#39; % (label, now),))
            writer.writerow((&#39;site&#39;, &#39;depth&#39;, &#39;time&#39;, &#39;value&#39;))
            with ProgressBar(len(state), verbose = verbose) as progress:
                if verbose:
                    progress.prefix = &#39;Serializing...&#39;
                for t in range(0, len(state)):
                    for z, depth in enumerate(depth_labels):
                        for i, site_name in enumerate(site_labels):
                            # Working with a length-T sequence of length-N lists
                            writer.writerow([
                                site_name, depth, time_labels[t],
                                format(state[t][z][i], &#39;.%df&#39; % prec)
                            ])
                        if verbose:
                            progress.update(t)

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, new):
        if new is None:
            self._data = None
        elif hasattr(new, &#39;ndim&#39;):
            assert new.ndim &gt;= 4,\
                &#39;New data array must have at least 4 axes; should be (T x Z x N x 81)&#39;
            self._data = new.astype(self._dtype)
        else:
            # Otherwise, concat the sequence of arrays, once made conformable
            self._data = np.concatenate(
                list(map(self.conformable, new)), axis = 0).astype(self._dtype)

    def conformable(self, array, allocation = 1):
        &#39;&#39;&#39;
        Given an array, returns representation that conforms to expectations.

        Parameters
        ----------
        array : numpy.ndarray
            Input data array
        allocation : int
            Number of time steps to allocate

        Returns
        -------
        numpy.ndarray
            `(1 x T x Z x N x 81)` array
        &#39;&#39;&#39;
        shp = array.shape
        assert (self._count in shp),\
            &#39;Array is not conformable with %d measurement points&#39; % self._count
        assert array.ndim in (3, 4, 5),\
            &#39;State variables should have between 3 and 5 axes only&#39;

        # We want to return a (1 x Z x T x N x 81) array; tests are somewhat
        #   verbose in light of the possibility that self._count = 81
        assert 81 in shp,\
            &#39;State variables must have a 1-km subgrid axis with 81 elements&#39;
        i_idx = shp.index(self._count)
        j_idx = shp.index(81)
        if array.ndim == 3:
            return np.concatenate((
                array.swapaxes(1, i_idx).swapaxes(2, j_idx)\
                    .reshape((1, 1, self._count, 81)),
                np.full((1, allocation - 1, 1, self._count, 81), np.nan)
            ), axis = 1)
        # Arrays of 4D or higher are assumed to have a Z axis
        z_idx = shp.index(self._layers) if self._layers in shp else shp.index(1)
        if array.ndim == 4:
            return np.concatenate((
                array.swapaxes(0, z_idx).swapaxes(2, i_idx).swapaxes(3, j_idx)\
                    .reshape((1, self._layers, 1, self._count, 81)),
                np.full((1, allocation - 1, self._layers, self._count, 81), np.nan),
            ), axis = 1)
        if array.ndim == 5:
            return np.concatenate((
                array.swapaxes(0, z_idx).swapaxes(3, i_idx).swapaxes(4, j_idx)\
                    .reshape((1, self._layers, 1, self._count, 81)),
                np.full((1, allocation - 1, self._layers, self._count, 81), np.nan),
            ), axis = 1)


def report(hdf):
    &#39;&#39;&#39;
    Check that we have everything needed to run L4C, print a report to the
    screen.

    Parameters
    ----------
    hdf : h5py.File
    &#39;&#39;&#39;
    KEYS = (&#39;apar&#39;, &#39;vpd&#39;, &#39;ft&#39;, &#39;tmin&#39;, &#39;tsoil&#39;, &#39;smrz&#39;, &#39;smsf&#39;)

    def find(hdf, prefix, key, pad = 10):
        &#39;Find a key, print the report&#39;
        try:
            field = &#39;%s/%s&#39; % (prefix, key)
            if len(hdf[field].shape) == 2 or key == &#39;fpar&#39;:
                pretty = (&#39;&#34;%s&#34;&#39; % key).ljust(pad)
                print_stats(hdf[field][:], pad, pretty)
            elif len(hdf[field].shape) == 3:
                # Assuming data are enumerated on the first axis
                for i in range(0, hdf[field].shape[0]):
                    pretty = (&#39;&#34;%s&#34; (%d)&#39; % (key, i)).ljust(pad)
                    print_stats(hdf[field][i,...], pad, pretty)
        except KeyError:
            pretty = (&#39;&#34;%s&#34;&#39; % key).ljust(pad)
            print(&#39;-- MISSING %s&#39; % pretty)

    def print_stats(data, pad, pretty):
        shp = &#39; x &#39;.join(map(str, data.shape))
        shp = (&#39;[%s]&#39; % shp).ljust(pad + 7)
        stats = tuple(summarize(data))
        stats_pretty = &#39;&#39;
        if stats[0] is not None:
            stats_pretty = &#39;[%.2f, %.2f]&#39; % (stats[0], stats[2])
            if len(key) &lt; 10:
                print(&#39;-- Found %s %s %s&#39; % (pretty, shp, stats_pretty))
            else:
                print(&#39;-- Found %s&#39; % pretty)
                print(&#39;%s%s %s&#39; % (&#39;&#39;.rjust(pad + 10), shp, stats_pretty))

    def summarize(data, nodata = -9999):
        &#39;Get summary statistics for a field&#39;
        if str(data.dtype).startswith(&#39;int&#39;):
            return (None for i in range(0, 3))
        data[data == -9999] = np.nan
        return (
            getattr(np, f)(data) for f in (&#39;nanmin&#39;, &#39;nanmean&#39;, &#39;nanmax&#39;)
        )

    print(&#39;\nL4C: Validating configuration and input datasets for file:&#39;)
    print(&#39;  %s&#39; % hdf.filename)
    print(&#39;\nL4C: Checking for required driver variables...&#39;)
    for key in KEYS:
        if key == &#39;ft&#39; and key not in hdf[&#39;drivers&#39;].keys():
            find(hdf, &#39;drivers&#39;, &#39;tsurf&#39;)
        elif key == &#39;apar&#39; and key not in hdf[&#39;drivers&#39;].keys():
            find(hdf, &#39;drivers&#39;, &#39;par&#39;)
            find(hdf, &#39;drivers&#39;, &#39;fpar&#39;)
        else:
            find(hdf, &#39;drivers&#39;, key)

    print(&#39;\nL4C: Checking for required state variables...&#39;)
    for key in (&#39;PFT&#39;, &#39;npp_sum&#39;, &#39;soil_organic_carbon&#39;,):
        find(hdf, &#39;state&#39;, key)

    print(&#39;\nL4C: Summarizing metadata...&#39;)
    y1, m1, d1, _ = hdf[&#39;time&#39;][0,...]
    y2, m2, d2, _ = hdf[&#39;time&#39;][-1,...]
    print(&#39;-- First date: %s&#39; % datetime.datetime(y1, m1, d1)\
        .strftime(&#39;%Y-%m-%d&#39;))
    print(&#39;-- Final date: %s&#39; % datetime.datetime(y2, m2, d2)\
        .strftime(&#39;%Y-%m-%d&#39;))
    print(&#39;-- Total length: %d&#39; % hdf[&#39;time&#39;].shape[0])
    print(&#39;&#39;)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyl4c.apps.l4c.extensions" href="extensions/index.html">pyl4c.apps.l4c.extensions</a></code></dt>
<dd>
<div class="desc"><p>These sub-modules were created to support running specific L4C model variants
(which are also implemented in the corresponding sub-module for …</p></div>
</dd>
<dt><code class="name"><a title="pyl4c.apps.l4c.io" href="io.html">pyl4c.apps.l4c.io</a></code></dt>
<dd>
<div class="desc"><p>File input/output handlers for running L4C Science.</p></div>
</dd>
<dt><code class="name"><a title="pyl4c.apps.l4c.main" href="main.html">pyl4c.apps.l4c.main</a></code></dt>
<dd>
<div class="desc"><p>The L4C Science model, for computing a total carbon budget for specific
geographic point locations. This is a "point" version, similar to the Matlab
…</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyl4c.apps.l4c.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>hdf)</span>
</code></dt>
<dd>
<div class="desc"><p>Check that we have everything needed to run L4C, print a report to the
screen.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hdf</code></strong> :&ensp;<code>h5py.File</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report(hdf):
    &#39;&#39;&#39;
    Check that we have everything needed to run L4C, print a report to the
    screen.

    Parameters
    ----------
    hdf : h5py.File
    &#39;&#39;&#39;
    KEYS = (&#39;apar&#39;, &#39;vpd&#39;, &#39;ft&#39;, &#39;tmin&#39;, &#39;tsoil&#39;, &#39;smrz&#39;, &#39;smsf&#39;)

    def find(hdf, prefix, key, pad = 10):
        &#39;Find a key, print the report&#39;
        try:
            field = &#39;%s/%s&#39; % (prefix, key)
            if len(hdf[field].shape) == 2 or key == &#39;fpar&#39;:
                pretty = (&#39;&#34;%s&#34;&#39; % key).ljust(pad)
                print_stats(hdf[field][:], pad, pretty)
            elif len(hdf[field].shape) == 3:
                # Assuming data are enumerated on the first axis
                for i in range(0, hdf[field].shape[0]):
                    pretty = (&#39;&#34;%s&#34; (%d)&#39; % (key, i)).ljust(pad)
                    print_stats(hdf[field][i,...], pad, pretty)
        except KeyError:
            pretty = (&#39;&#34;%s&#34;&#39; % key).ljust(pad)
            print(&#39;-- MISSING %s&#39; % pretty)

    def print_stats(data, pad, pretty):
        shp = &#39; x &#39;.join(map(str, data.shape))
        shp = (&#39;[%s]&#39; % shp).ljust(pad + 7)
        stats = tuple(summarize(data))
        stats_pretty = &#39;&#39;
        if stats[0] is not None:
            stats_pretty = &#39;[%.2f, %.2f]&#39; % (stats[0], stats[2])
            if len(key) &lt; 10:
                print(&#39;-- Found %s %s %s&#39; % (pretty, shp, stats_pretty))
            else:
                print(&#39;-- Found %s&#39; % pretty)
                print(&#39;%s%s %s&#39; % (&#39;&#39;.rjust(pad + 10), shp, stats_pretty))

    def summarize(data, nodata = -9999):
        &#39;Get summary statistics for a field&#39;
        if str(data.dtype).startswith(&#39;int&#39;):
            return (None for i in range(0, 3))
        data[data == -9999] = np.nan
        return (
            getattr(np, f)(data) for f in (&#39;nanmin&#39;, &#39;nanmean&#39;, &#39;nanmax&#39;)
        )

    print(&#39;\nL4C: Validating configuration and input datasets for file:&#39;)
    print(&#39;  %s&#39; % hdf.filename)
    print(&#39;\nL4C: Checking for required driver variables...&#39;)
    for key in KEYS:
        if key == &#39;ft&#39; and key not in hdf[&#39;drivers&#39;].keys():
            find(hdf, &#39;drivers&#39;, &#39;tsurf&#39;)
        elif key == &#39;apar&#39; and key not in hdf[&#39;drivers&#39;].keys():
            find(hdf, &#39;drivers&#39;, &#39;par&#39;)
            find(hdf, &#39;drivers&#39;, &#39;fpar&#39;)
        else:
            find(hdf, &#39;drivers&#39;, key)

    print(&#39;\nL4C: Checking for required state variables...&#39;)
    for key in (&#39;PFT&#39;, &#39;npp_sum&#39;, &#39;soil_organic_carbon&#39;,):
        find(hdf, &#39;state&#39;, key)

    print(&#39;\nL4C: Summarizing metadata...&#39;)
    y1, m1, d1, _ = hdf[&#39;time&#39;][0,...]
    y2, m2, d2, _ = hdf[&#39;time&#39;][-1,...]
    print(&#39;-- First date: %s&#39; % datetime.datetime(y1, m1, d1)\
        .strftime(&#39;%Y-%m-%d&#39;))
    print(&#39;-- Final date: %s&#39; % datetime.datetime(y2, m2, d2)\
        .strftime(&#39;%Y-%m-%d&#39;))
    print(&#39;-- Total length: %d&#39; % hdf[&#39;time&#39;].shape[0])
    print(&#39;&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyl4c.apps.l4c.AbstractData"><code class="flex name class">
<span>class <span class="ident">AbstractData</span></span>
</code></dt>
<dd>
<div class="desc"><p>An abstraction of a data container for running L4C simulations.
Represents discontinuous locations or "points" on a global EASE-Grid 2.0
over which to run an L4C simulation. Each "point" has a 1-km subgrid
associated with the 9-km "point" cell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractData(object):
    &#39;&#39;&#39;
    An abstraction of a data container for running L4C simulations.
    Represents discontinuous locations or &#34;points&#34; on a global EASE-Grid 2.0
    over which to run an L4C simulation. Each &#34;point&#34; has a 1-km subgrid
    associated with the 9-km &#34;point&#34; cell.
    &#39;&#39;&#39;
    @property
    def labels(self):
        return self._data_labels

    @labels.setter
    def labels(self, new_labels):
        self._data_labels = tuple(new_labels)

    @property
    def shape(self):
        if self.data is not None:
            return self.data.shape</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.L4CDrivers" href="#pyl4c.apps.l4c.L4CDrivers">L4CDrivers</a></li>
<li><a title="pyl4c.apps.l4c.L4CState" href="#pyl4c.apps.l4c.L4CState">L4CState</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.AbstractData.labels"><code class="name">var <span class="ident">labels</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def labels(self):
    return self._data_labels</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.AbstractData.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    if self.data is not None:
        return self.data.shape</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyl4c.apps.l4c.L4CConstants"><code class="flex name class">
<span>class <span class="ident">L4CConstants</span></span>
<span>(</span><span>count: int, pft_array, valid_pft=range(1, 10))</span>
</code></dt>
<dd>
<div class="desc"><p>A namespace for constant values used in running L4C. These constant
values are broadcast to an array that is conformable with driver data
for fast and seamless computation in the forward run.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>count</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of point locations ("sites") used in forward simulation</dd>
<dt><strong><code>pft_array</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Array specifying the PFT at each point location</dd>
<dt><strong><code>valid_pft</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>The valid PFT codes</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CConstants(object):
    &#39;&#39;&#39;
    A namespace for constant values used in running L4C. These constant
    values are broadcast to an array that is conformable with driver data
    for fast and seamless computation in the forward run.

    Parameters
    ----------
    count : int
        Number of point locations (&#34;sites&#34;) used in forward simulation
    pft_array : numpy.ndarray
        Array specifying the PFT at each point location
    valid_pft : Sequence
        The valid PFT codes
    &#39;&#39;&#39;
    def __init__(self, count : int, pft_array, valid_pft = range(1, 10)):
        # Set invalid PFT codes to 0
        self._count = count
        self._pft = np.where(np.in1d(pft_array.ravel(), valid_pft),
            pft_array.ravel(), 0)

    def conformable(self, array):
        &#39;&#39;&#39;
        Creates a `(1) x N x P` array where `P` is the number of PFT classes.
        Useful for guaranteeing that an array is conformable with the other
        arrays it will be concatenated with.

        Parameters
        ----------
        array : numpy.ndarray
        &#39;&#39;&#39;
        assert array.ndim &lt;= 4, &#39;Expected ndim &lt;= 4&#39;
        if array.ndim == 1:
            # A 1D array indicates one value per PFT
            return np.apply_along_axis(
                lambda p: array[p], 0, self._pft
            ).reshape((self._count, 81))
        if array.ndim == 2:
            if array.shape == (self._count, 81):
                return array # Array already conforms
            # A 2D array indicates multiple (&#34;ndim&#34;) values per PFT
            return np.apply_along_axis(
                lambda p: array[:,p], 0, self._pft
            ).reshape((array.shape[0], self._count, 81))
        if array.ndim == 3:
            # i.e., a 365-day climatology
            assert array.shape == (365, self._count, 81),\
                &#39;No support for 3D arrays that do not have 365 elements on axis 0 (i.e., a 365-day climatology)&#39;
            return array
        if array.ndim == 4:
            assert array.shape[-3:] == (365, self._count, 81),\
                &#39;No support for 4D arrays that do not have the following sub-space: (%s)&#39; % &#39; x &#39;.join(map(str, array.shape[-3:]))
            return array

    def add(self, array, label):
        &#39;&#39;&#39;
        Adds a new constant as an attribute on this instance.

        Parameters
        ----------
        array : numpy.ndarray
            The array to add
        label : str
            The name by which this array will be known
        &#39;&#39;&#39;
        setattr(self, label, self.conformable(array))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.l4c.L4CConstants.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, array, label)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new constant as an attribute on this instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The array to add</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>The name by which this array will be known</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, array, label):
    &#39;&#39;&#39;
    Adds a new constant as an attribute on this instance.

    Parameters
    ----------
    array : numpy.ndarray
        The array to add
    label : str
        The name by which this array will be known
    &#39;&#39;&#39;
    setattr(self, label, self.conformable(array))</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.L4CConstants.conformable"><code class="name flex">
<span>def <span class="ident">conformable</span></span>(<span>self, array)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a <code>(1) x N x P</code> array where <code>P</code> is the number of PFT classes.
Useful for guaranteeing that an array is conformable with the other
arrays it will be concatenated with.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conformable(self, array):
    &#39;&#39;&#39;
    Creates a `(1) x N x P` array where `P` is the number of PFT classes.
    Useful for guaranteeing that an array is conformable with the other
    arrays it will be concatenated with.

    Parameters
    ----------
    array : numpy.ndarray
    &#39;&#39;&#39;
    assert array.ndim &lt;= 4, &#39;Expected ndim &lt;= 4&#39;
    if array.ndim == 1:
        # A 1D array indicates one value per PFT
        return np.apply_along_axis(
            lambda p: array[p], 0, self._pft
        ).reshape((self._count, 81))
    if array.ndim == 2:
        if array.shape == (self._count, 81):
            return array # Array already conforms
        # A 2D array indicates multiple (&#34;ndim&#34;) values per PFT
        return np.apply_along_axis(
            lambda p: array[:,p], 0, self._pft
        ).reshape((array.shape[0], self._count, 81))
    if array.ndim == 3:
        # i.e., a 365-day climatology
        assert array.shape == (365, self._count, 81),\
            &#39;No support for 3D arrays that do not have 365 elements on axis 0 (i.e., a 365-day climatology)&#39;
        return array
    if array.ndim == 4:
        assert array.shape[-3:] == (365, self._count, 81),\
            &#39;No support for 4D arrays that do not have the following sub-space: (%s)&#39; % &#39; x &#39;.join(map(str, array.shape[-3:]))
        return array</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyl4c.apps.l4c.L4CDrivers"><code class="flex name class">
<span>class <span class="ident">L4CDrivers</span></span>
<span>(</span><span>count, drivers=None, labels=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a collection of L4C driver variables. Driver variables <em>drive</em>
the model but are not in themselves updated; they are exogenous variables
with values fixed at the start of the simulation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>count</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of point locations ("sites") used in forward simulation</dd>
<dt><strong><code>drivers</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>labels</code></strong></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CDrivers(AbstractData):
    &#39;&#39;&#39;
    Represents a collection of L4C driver variables. Driver variables *drive*
    the model but are not in themselves updated; they are exogenous variables
    with values fixed at the start of the simulation.

    Parameters
    ----------
    count : int
        Number of point locations (&#34;sites&#34;) used in forward simulation
    drivers
    labels
    &#39;&#39;&#39;
    def __init__(self, count, drivers = None, labels = None):
        if drivers is not None and labels is not None:
            if hasattr(drivers, &#39;ndim&#39;):
                matched = drivers.shape[0] == len(labels)
            else:
                matched = len(drivers) == len(labels)
            if not matched:
                raise ValueError(&#39;There should be as many labels as there are driver variables&#39;)
        self._count = count
        self._data = None
        self._data_labels = labels
        # Use appropriate setter function
        self.data = drivers

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, new):
        if new is None:
            self._data = None
        elif hasattr(new, &#39;ndim&#39;):
            self._data = new
        else:
            # Otherwise, concat the sequence of arrays, once made conformable
            self._data = np.concatenate(list(map(
                partial(self.conformable), new)), axis = 0)

    def conformable(self, array):
        &#39;&#39;&#39;
        Given an array, returns representation that conforms to expectations.

        Parameters
        ----------
        array : numpy.ndarray
            Input data array

        Returns
        -------
        numpy.ndarray
            `(1 x T x N x 81)` array
        &#39;&#39;&#39;
        shp = array.shape
        assert (self._count in shp),\
            &#39;Array is not conformable with %d measurement points&#39; % self._count
        assert array.ndim in (2, 3, 4),\
            &#39;Driver variables should have 2, 3, or 4 axes only&#39;

        # Driver data should be (1 x T x N x 81)
        i_idx = shp.index(self._count)
        if array.ndim == 2:
            t = shp[0] if i_idx == 1 else shp[1] # Get size of time axis
            return array.swapaxes(1, i_idx).reshape((t, self._count, 1))\
                    .repeat(81, axis = 2).reshape((1, t, self._count, 81))

        # NOTE: The swapaxes() calls essentially assert place each axis into
        #   its desired position, moved from its inferred position
        j_idx = shp.index(81) if 81 in shp else shp.index(1) # Subgrid axis
        t_idx = set((0, 1, 2)).difference((i_idx, j_idx)).pop() # Time axis
        if array.ndim == 3:
            t = shp[t_idx] # Get the size of the time axis
            if shp[j_idx] == 81:
                return array.swapaxes(1, i_idx).swapaxes(2, j_idx)\
                    .reshape((1, t, self._count, 81))
            return array.swapaxes(1, i_idx).swapaxes(2, j_idx)\
                .reshape((1, t, self._count, 1)).repeat(81, axis = 3)

        if array.ndim == 4:
            return array.swapaxes(1, t_idx).swapaxes(2, i_idx)\
                .swapaxes(3, j_idx)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.AbstractData" href="#pyl4c.apps.l4c.AbstractData">AbstractData</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.L4CDrivers.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self):
    return self._data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.l4c.L4CDrivers.conformable"><code class="name flex">
<span>def <span class="ident">conformable</span></span>(<span>self, array)</span>
</code></dt>
<dd>
<div class="desc"><p>Given an array, returns representation that conforms to expectations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Input data array</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd><code>(1 x T x N x 81)</code> array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conformable(self, array):
    &#39;&#39;&#39;
    Given an array, returns representation that conforms to expectations.

    Parameters
    ----------
    array : numpy.ndarray
        Input data array

    Returns
    -------
    numpy.ndarray
        `(1 x T x N x 81)` array
    &#39;&#39;&#39;
    shp = array.shape
    assert (self._count in shp),\
        &#39;Array is not conformable with %d measurement points&#39; % self._count
    assert array.ndim in (2, 3, 4),\
        &#39;Driver variables should have 2, 3, or 4 axes only&#39;

    # Driver data should be (1 x T x N x 81)
    i_idx = shp.index(self._count)
    if array.ndim == 2:
        t = shp[0] if i_idx == 1 else shp[1] # Get size of time axis
        return array.swapaxes(1, i_idx).reshape((t, self._count, 1))\
                .repeat(81, axis = 2).reshape((1, t, self._count, 81))

    # NOTE: The swapaxes() calls essentially assert place each axis into
    #   its desired position, moved from its inferred position
    j_idx = shp.index(81) if 81 in shp else shp.index(1) # Subgrid axis
    t_idx = set((0, 1, 2)).difference((i_idx, j_idx)).pop() # Time axis
    if array.ndim == 3:
        t = shp[t_idx] # Get the size of the time axis
        if shp[j_idx] == 81:
            return array.swapaxes(1, i_idx).swapaxes(2, j_idx)\
                .reshape((1, t, self._count, 81))
        return array.swapaxes(1, i_idx).swapaxes(2, j_idx)\
            .reshape((1, t, self._count, 1)).repeat(81, axis = 3)

    if array.ndim == 4:
        return array.swapaxes(1, t_idx).swapaxes(2, i_idx)\
            .swapaxes(3, j_idx)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyl4c.apps.l4c.L4CState"><code class="flex name class">
<span>class <span class="ident">L4CState</span></span>
<span>(</span><span>count: int, state=None, labels=None, axis_labels=None, dtype=numpy.float32)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a collection of L4C state variables. State variables influence
the driving of the model; an initial state (at time t=0) is required to
start running and the variable state might be updated at each time step
(t) based on the value at step (t-1). State data are stored as
<code>M x T x N x 81</code> arrays.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>count</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of point locations ("sites") used in forward simulation</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>numpy.ndarray</code> or <code>None</code></dt>
<dd>(Optional) Initial state</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>list</code> or <code>tuple</code> or <code>None</code></dt>
<dd>(Optional) Sequence of labels for each state variable, should be
the same length as the first axis of the <code>state</code> of array</dd>
<dt><strong><code>axis_labels</code></strong> :&ensp;<code>list</code> or <code>tuple</code> or <code>None</code></dt>
<dd>Names of each axis of the stored state matrix; axes are, in order:
(state variable, time, site, 81)</dd>
<dt><strong><code>dtype</code></strong></dt>
<dd>The data type to coerce on the state array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CState(AbstractData):
    &#39;&#39;&#39;
    Represents a collection of L4C state variables. State variables influence
    the driving of the model; an initial state (at time t=0) is required to
    start running and the variable state might be updated at each time step
    (t) based on the value at step (t-1). State data are stored as
    `M x T x N x 81` arrays.

    Parameters
    ----------
    count : int
        Number of point locations (&#34;sites&#34;) used in forward simulation
    state : numpy.ndarray or None
        (Optional) Initial state
    labels : list or tuple or None
        (Optional) Sequence of labels for each state variable, should be
        the same length as the first axis of the `state` of array
    axis_labels : list or tuple or None
        Names of each axis of the stored state matrix; axes are, in order:
        (state variable, time, site, 81)
    dtype
        The data type to coerce on the state array
    &#39;&#39;&#39;
    def __init__(
            self, count : int, state = None, labels = None,
            axis_labels = None, dtype = np.float32):
        if state is not None and labels is not None:
            if hasattr(state, &#39;ndim&#39;):
                matched = state.shape[0] == len(labels)
            else:
                matched = len(state) == len(labels)
            if not matched:
                raise ValueError(&#39;There should be as many labels as there are state variables&#39;)
        self._axis_labels = axis_labels
        self._count = int(count)
        self._bounds = (0, np.inf)
        self._data = None
        self._data_labels = labels
        self._dtype = dtype
        # Use appropriate setter function
        if state is not None:
            self.data = state.astype(dtype)

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, new):
        if new is None:
            self._data = None
        elif hasattr(new, &#39;ndim&#39;):
            assert new.ndim == 4,\
                &#39;New data array must have 4 axes; should be (M x T x N x 81)&#39;
            self._data = new.astype(self._dtype)
        else:
            # Otherwise, concat the sequence of arrays, once made conformable
            self._data = np.concatenate(
                list(map(self.conformable, new)), axis = 0).astype(self._dtype)

    def _serialize(
            self, state, label, output_path, truncate, time_labels, prec,
            verbose = False):
        &#39;Argument &#34;state&#34; should be length-T sequence of length-N sequences&#39;
        now = datetime.datetime.now().strftime(&#39;%Y-%m-%d&#39;)
        site_labels = list(range(0, self._count))
        if self._axis_labels is not None:
            site_labels = self._axis_labels[-2]
            # Decode UTF-8 strings
            if hasattr(site_labels[0], &#39;decode&#39;):
                site_labels = list(map(lambda x: x.decode(), site_labels))
        with open(output_path, &#39;w&#39;) as file:
            writer = csv.writer(file)
            writer.writerow(
                (&#39;# L4C Model State %s serialized %s&#39; % (label, now),))
            writer.writerow((&#39;site&#39;, &#39;time&#39;, &#39;value&#39;))
            with ProgressBar(len(state), verbose = verbose) as progress:
                if verbose:
                    progress.prefix = &#39;Serializing...&#39;
                for t in range(0, len(state)):
                    for i, label in enumerate(site_labels):
                        # Working with a length-T sequence of length-N lists
                        writer.writerow([
                            label, time_labels[t],
                            format(state[t,i], &#39;.%df&#39; % prec)
                        ])
                    if verbose:
                        progress.update(t)

    @suppress_warnings
    def _serialize_combined(
            self, label, output_path, truncate, time_labels, prec):
        &#39;Serializes the combined (summed) state, summing across fields&#39;
        # Sum across fields, then take the mean across the 1-km subgrid
        state = np.nanmean(self.data.sum(axis = 0), axis = -1)
        if truncate is not None:
            state = state[0:truncate,...].tolist()
        else:
            state = state.tolist()
        self._serialize(
            state, label, output_path, truncate, time_labels, prec)

    def advance(self, label, t, delta = None, func = np.add, bounds = None):
        &#39;&#39;&#39;
        Updates the state data at time (t) based on the prior state (state
        at t-1). NOTE: &#34;delta&#34; is the left argument of the binary function.

        Parameters
        ----------
        label : str
            One of the labels in self.labels
        t : int
            Index of the time step to update
        delta : numpy.ndarray
            LHS of the function (func) to change state (Default: None)
        func : function
            The binary function to use to combine delta and the state
            at time (t-1) (Default: numpy.add).
        bounds : dict
        &#39;&#39;&#39;
        i = self.labels.index(label)
        if delta is not None:
            new_state = func(delta, self._data[i, t-1, ...])
            # Check for out-of-bounds
            if bounds is None:
                self._data[i, t, ...] = new_state
                return

            self._data[i, t, ...] = np.where(
                new_state &gt; bounds[1], bounds[1], np.where(
                    new_state &lt; bounds[0], bounds[0], new_state))

    def conformable(self, array, allocation = 1):
        &#39;&#39;&#39;
        Given an array, returns representation that conforms to expectations.

        Parameters
        ----------
        array : numpy.ndarray
            Input data array
        allocation : int
            Number of time steps to allocate

        Returns
        -------
        numpy.ndarray
            `(1 x T x N x 81)` array
        &#39;&#39;&#39;
        shp = array.shape
        assert (self._count in shp),\
            &#39;Array is not conformable with %d measurement points&#39; % self._count
        assert array.ndim in (2, 3),\
            &#39;State variables should have either 2 or 3 axes only&#39;

        # We want to return a (1 x T x N x 81) array; tests are somewhat
        #   verbose in light of the possibility that self._count = 81
        assert 81 in shp,\
            &#39;State variables must have a 1-km subgrid axis with 81 elements&#39;
        i_idx = shp.index(self._count)
        j_idx = shp.index(81)
        # Add concatenation (axis=0) and time (axis=1) axes, then allocate
        #   T time steps
        if array.ndim == 2:
            return np.concatenate((
                array.swapaxes(i_idx, 0).reshape((1, 1, self._count, 81)),
                np.full((1, allocation - 1, self._count, 81), np.nan)
            ), axis = 1)
        if array.ndim == 3:
            return np.concatenate((
                array.swapaxes(i_idx, 1).swapaxes(j_idx, 2)\
                    .reshape((1, 1, self._count, 81)),
                np.full((1, allocation - 1, self._count, 81), np.nan)
            ), axis = 1)

    def update(self, label, t, array, bounds = None):
        &#39;&#39;&#39;
        Updates the state data with the given label by inserting an array
        at the specified time step (t).

        Parameters
        ----------
        label : str
            One of the labels in self.labels
        t : int
            Index of the time step to update
        array : numpy.ndarray
        bounds : dict
        &#39;&#39;&#39;
        i = self.labels.index(label)
        if bounds is None:
            self._data[i, t, ...] = array
            return

        self._data[i, t, ...] = np.where(
            array &gt; bounds[1], bounds[1], np.where(
                array &lt; bounds[0], bounds[0], array))

    def serialize(
            self, output_tpl, truncate = None, time_labels = None, prec = 3,
            verbose = False):
        &#39;&#39;&#39;
        Dumps the current state to a CSV file. Data on the 1-km subgrid are
        summarized; the mean at each 9-km site is reported.

        Parameters
        ----------
        output_tpl : str
            Template filename for the output CSV file
        truncate : int
            (Optional) Largest time index that will be dumped
        time_labels : list or tuple
            (Optional) A sequence of time labels
        prec : int
            Number of decimal places to include (Default: 1)
        verbose : bool
            True to print progress of serialization
        &#39;&#39;&#39;
        assert truncate is None or (hasattr(truncate, &#39;real&#39;) and not hasattr(truncate, &#39;is_integer&#39;)), &#39;&#34;truncate&#34; must be an integer&#39;
        # Insert a string formatting character for the state&#39;s label
        output_tpl = &#39;.&#39;.join(output_tpl.split(&#39;.&#39;)[:-1])
        output_tpl = &#39;%s_%%s.csv&#39; % output_tpl

        if time_labels is None:
            time_labels = range(0, self.shape[1])
        else:
            assert isinstance(time_labels[0], str),\
                &#39;time_labels must be str type&#39;

        # Check that there are at least as many time labels as time indices
        t_max = truncate if truncate is not None else self.shape[1]
        assert len(time_labels) &gt;= t_max, &#39;Not enough time_labels!&#39;

        # If state represents SOC, combine across the SOC pools
        if all([s.startswith(&#39;soc&#39;) for s in self.labels]):
            self._serialize_combined(
                &#39;SOC&#39;, output_tpl % &#39;SOC&#39;, truncate, time_labels, prec)
            return

        # Take the mean across the 1-km subgrid
        state = self.data
        if self.data.ndim &gt; 3:
            with warnings.catch_warnings():
                warnings.simplefilter(&#39;ignore&#39;)
                state = np.nanmean(self.data, axis = -1)
        print(&#39;Datasets to serialize: %d&#39; % self.shape[0])
        for i in range(0, self.shape[0]):
            self._serialize(
                state[i,...], self.labels[i].upper(),
                output_tpl % self.labels[i].upper(), truncate, time_labels,
                prec, verbose = verbose)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.AbstractData" href="#pyl4c.apps.l4c.AbstractData">AbstractData</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.L4CStratifiedState" href="#pyl4c.apps.l4c.L4CStratifiedState">L4CStratifiedState</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.L4CState.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self):
    return self._data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.l4c.L4CState.advance"><code class="name flex">
<span>def <span class="ident">advance</span></span>(<span>self, label, t, delta=None, func=&lt;ufunc &#x27;add&#x27;&gt;, bounds=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the state data at time (t) based on the prior state (state
at t-1). NOTE: "delta" is the left argument of the binary function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>One of the labels in self.labels</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the time step to update</dd>
<dt><strong><code>delta</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>LHS of the function (func) to change state (Default: None)</dd>
<dt><strong><code>func</code></strong> :&ensp;<code>function</code></dt>
<dd>The binary function to use to combine delta and the state
at time (t-1) (Default: numpy.add).</dd>
<dt><strong><code>bounds</code></strong> :&ensp;<code>dict</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def advance(self, label, t, delta = None, func = np.add, bounds = None):
    &#39;&#39;&#39;
    Updates the state data at time (t) based on the prior state (state
    at t-1). NOTE: &#34;delta&#34; is the left argument of the binary function.

    Parameters
    ----------
    label : str
        One of the labels in self.labels
    t : int
        Index of the time step to update
    delta : numpy.ndarray
        LHS of the function (func) to change state (Default: None)
    func : function
        The binary function to use to combine delta and the state
        at time (t-1) (Default: numpy.add).
    bounds : dict
    &#39;&#39;&#39;
    i = self.labels.index(label)
    if delta is not None:
        new_state = func(delta, self._data[i, t-1, ...])
        # Check for out-of-bounds
        if bounds is None:
            self._data[i, t, ...] = new_state
            return

        self._data[i, t, ...] = np.where(
            new_state &gt; bounds[1], bounds[1], np.where(
                new_state &lt; bounds[0], bounds[0], new_state))</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.L4CState.conformable"><code class="name flex">
<span>def <span class="ident">conformable</span></span>(<span>self, array, allocation=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Given an array, returns representation that conforms to expectations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Input data array</dd>
<dt><strong><code>allocation</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of time steps to allocate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd><code>(1 x T x N x 81)</code> array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conformable(self, array, allocation = 1):
    &#39;&#39;&#39;
    Given an array, returns representation that conforms to expectations.

    Parameters
    ----------
    array : numpy.ndarray
        Input data array
    allocation : int
        Number of time steps to allocate

    Returns
    -------
    numpy.ndarray
        `(1 x T x N x 81)` array
    &#39;&#39;&#39;
    shp = array.shape
    assert (self._count in shp),\
        &#39;Array is not conformable with %d measurement points&#39; % self._count
    assert array.ndim in (2, 3),\
        &#39;State variables should have either 2 or 3 axes only&#39;

    # We want to return a (1 x T x N x 81) array; tests are somewhat
    #   verbose in light of the possibility that self._count = 81
    assert 81 in shp,\
        &#39;State variables must have a 1-km subgrid axis with 81 elements&#39;
    i_idx = shp.index(self._count)
    j_idx = shp.index(81)
    # Add concatenation (axis=0) and time (axis=1) axes, then allocate
    #   T time steps
    if array.ndim == 2:
        return np.concatenate((
            array.swapaxes(i_idx, 0).reshape((1, 1, self._count, 81)),
            np.full((1, allocation - 1, self._count, 81), np.nan)
        ), axis = 1)
    if array.ndim == 3:
        return np.concatenate((
            array.swapaxes(i_idx, 1).swapaxes(j_idx, 2)\
                .reshape((1, 1, self._count, 81)),
            np.full((1, allocation - 1, self._count, 81), np.nan)
        ), axis = 1)</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.L4CState.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, output_tpl, truncate=None, time_labels=None, prec=3, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Dumps the current state to a CSV file. Data on the 1-km subgrid are
summarized; the mean at each 9-km site is reported.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>output_tpl</code></strong> :&ensp;<code>str</code></dt>
<dd>Template filename for the output CSV file</dd>
<dt><strong><code>truncate</code></strong> :&ensp;<code>int</code></dt>
<dd>(Optional) Largest time index that will be dumped</dd>
<dt><strong><code>time_labels</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>(Optional) A sequence of time labels</dd>
<dt><strong><code>prec</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of decimal places to include (Default: 1)</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to print progress of serialization</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(
        self, output_tpl, truncate = None, time_labels = None, prec = 3,
        verbose = False):
    &#39;&#39;&#39;
    Dumps the current state to a CSV file. Data on the 1-km subgrid are
    summarized; the mean at each 9-km site is reported.

    Parameters
    ----------
    output_tpl : str
        Template filename for the output CSV file
    truncate : int
        (Optional) Largest time index that will be dumped
    time_labels : list or tuple
        (Optional) A sequence of time labels
    prec : int
        Number of decimal places to include (Default: 1)
    verbose : bool
        True to print progress of serialization
    &#39;&#39;&#39;
    assert truncate is None or (hasattr(truncate, &#39;real&#39;) and not hasattr(truncate, &#39;is_integer&#39;)), &#39;&#34;truncate&#34; must be an integer&#39;
    # Insert a string formatting character for the state&#39;s label
    output_tpl = &#39;.&#39;.join(output_tpl.split(&#39;.&#39;)[:-1])
    output_tpl = &#39;%s_%%s.csv&#39; % output_tpl

    if time_labels is None:
        time_labels = range(0, self.shape[1])
    else:
        assert isinstance(time_labels[0], str),\
            &#39;time_labels must be str type&#39;

    # Check that there are at least as many time labels as time indices
    t_max = truncate if truncate is not None else self.shape[1]
    assert len(time_labels) &gt;= t_max, &#39;Not enough time_labels!&#39;

    # If state represents SOC, combine across the SOC pools
    if all([s.startswith(&#39;soc&#39;) for s in self.labels]):
        self._serialize_combined(
            &#39;SOC&#39;, output_tpl % &#39;SOC&#39;, truncate, time_labels, prec)
        return

    # Take the mean across the 1-km subgrid
    state = self.data
    if self.data.ndim &gt; 3:
        with warnings.catch_warnings():
            warnings.simplefilter(&#39;ignore&#39;)
            state = np.nanmean(self.data, axis = -1)
    print(&#39;Datasets to serialize: %d&#39; % self.shape[0])
    for i in range(0, self.shape[0]):
        self._serialize(
            state[i,...], self.labels[i].upper(),
            output_tpl % self.labels[i].upper(), truncate, time_labels,
            prec, verbose = verbose)</code></pre>
</details>
</dd>
<dt id="pyl4c.apps.l4c.L4CState.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, label, t, array, bounds=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the state data with the given label by inserting an array
at the specified time step (t).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>One of the labels in self.labels</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the time step to update</dd>
<dt><strong><code>array</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>bounds</code></strong> :&ensp;<code>dict</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, label, t, array, bounds = None):
    &#39;&#39;&#39;
    Updates the state data with the given label by inserting an array
    at the specified time step (t).

    Parameters
    ----------
    label : str
        One of the labels in self.labels
    t : int
        Index of the time step to update
    array : numpy.ndarray
    bounds : dict
    &#39;&#39;&#39;
    i = self.labels.index(label)
    if bounds is None:
        self._data[i, t, ...] = array
        return

    self._data[i, t, ...] = np.where(
        array &gt; bounds[1], bounds[1], np.where(
            array &lt; bounds[0], bounds[0], array))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyl4c.apps.l4c.L4CStratifiedState"><code class="flex name class">
<span>class <span class="ident">L4CStratifiedState</span></span>
<span>(</span><span>layers: int, count: int, state=None, labels=None, axis_labels=None, dtype=numpy.float32)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a collection of L4C state variables that are potentially
stratified into vertical layers. State data are stored as
<code>M x T x Z x N x 81</code> arrays, where <code>M</code> enumerates the different state
variables, <code>Z</code> enumerates the depths, <code>T</code> is the time axis, and <code>N</code>
enumerates the number of sites.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>layers</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of vertical layers</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of point locations ("sites") used in forward simulation</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>numpy.ndarray</code> or <code>None</code></dt>
<dd>(Optional) Initial state</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>list</code> or <code>tuple</code> or <code>None</code></dt>
<dd>(Optional) Sequence of labels for each state variable, should be
the same length as the first axis of the <code>state</code> of array</dd>
<dt><strong><code>axis_labels</code></strong> :&ensp;<code>list</code> or <code>tuple</code> or <code>None</code></dt>
<dd>Names of each axis of the stored state matrix; axes are, in order:
(state variable, time, site, 81)</dd>
<dt><strong><code>dtype</code></strong></dt>
<dd>The data type to coerce on the state array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L4CStratifiedState(L4CState):
    &#39;&#39;&#39;
    Represents a collection of L4C state variables that are potentially
    stratified into vertical layers. State data are stored as
    `M x T x Z x N x 81` arrays, where `M` enumerates the different state
    variables, `Z` enumerates the depths, `T` is the time axis, and `N`
    enumerates the number of sites.

    Parameters
    ----------
    layers : int
        Number of vertical layers
    count : int
        Number of point locations (&#34;sites&#34;) used in forward simulation
    state : numpy.ndarray or None
        (Optional) Initial state
    labels : list or tuple or None
        (Optional) Sequence of labels for each state variable, should be
        the same length as the first axis of the `state` of array
    axis_labels : list or tuple or None
        Names of each axis of the stored state matrix; axes are, in order:
        (state variable, time, site, 81)
    dtype
        The data type to coerce on the state array
    &#39;&#39;&#39;
    def __init__(
            self, layers: int, count: int, state = None, labels = None,
            axis_labels = None, dtype = np.float32):
        self._layers = int(layers)
        if axis_labels is not None:
            assert len(axis_labels) == 5,\
                &#39;&#34;axis_labels&#34; should contain one sequence for each axis (5 axes)&#39;
        super().__init__(
            count = count, state = state, labels = labels,
            axis_labels = axis_labels, dtype = dtype)

    def _serialize(
            self, state, label, output_path, truncate, time_labels, prec,
            verbose = False):
        &#39;Argument &#34;state&#34; should be length-T sequence of length-N sequences&#39;
        now = datetime.datetime.now().strftime(&#39;%Y-%m-%d&#39;)
        site_labels = list(range(0, self._count))
        if self._axis_labels is not None:
            _, _, depth_labels, site_labels, _ = self._axis_labels
            # Decode UTF-8 strings
            if hasattr(site_labels[0], &#39;decode&#39;):
                site_labels = list(map(lambda x: x.decode(), site_labels))
        with open(output_path, &#39;w&#39;) as file:
            writer = csv.writer(file)
            writer.writerow(
                (&#39;# L4C Model State %s serialized %s&#39; % (label, now),))
            writer.writerow((&#39;site&#39;, &#39;depth&#39;, &#39;time&#39;, &#39;value&#39;))
            with ProgressBar(len(state), verbose = verbose) as progress:
                if verbose:
                    progress.prefix = &#39;Serializing...&#39;
                for t in range(0, len(state)):
                    for z, depth in enumerate(depth_labels):
                        for i, site_name in enumerate(site_labels):
                            # Working with a length-T sequence of length-N lists
                            writer.writerow([
                                site_name, depth, time_labels[t],
                                format(state[t][z][i], &#39;.%df&#39; % prec)
                            ])
                        if verbose:
                            progress.update(t)

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, new):
        if new is None:
            self._data = None
        elif hasattr(new, &#39;ndim&#39;):
            assert new.ndim &gt;= 4,\
                &#39;New data array must have at least 4 axes; should be (T x Z x N x 81)&#39;
            self._data = new.astype(self._dtype)
        else:
            # Otherwise, concat the sequence of arrays, once made conformable
            self._data = np.concatenate(
                list(map(self.conformable, new)), axis = 0).astype(self._dtype)

    def conformable(self, array, allocation = 1):
        &#39;&#39;&#39;
        Given an array, returns representation that conforms to expectations.

        Parameters
        ----------
        array : numpy.ndarray
            Input data array
        allocation : int
            Number of time steps to allocate

        Returns
        -------
        numpy.ndarray
            `(1 x T x Z x N x 81)` array
        &#39;&#39;&#39;
        shp = array.shape
        assert (self._count in shp),\
            &#39;Array is not conformable with %d measurement points&#39; % self._count
        assert array.ndim in (3, 4, 5),\
            &#39;State variables should have between 3 and 5 axes only&#39;

        # We want to return a (1 x Z x T x N x 81) array; tests are somewhat
        #   verbose in light of the possibility that self._count = 81
        assert 81 in shp,\
            &#39;State variables must have a 1-km subgrid axis with 81 elements&#39;
        i_idx = shp.index(self._count)
        j_idx = shp.index(81)
        if array.ndim == 3:
            return np.concatenate((
                array.swapaxes(1, i_idx).swapaxes(2, j_idx)\
                    .reshape((1, 1, self._count, 81)),
                np.full((1, allocation - 1, 1, self._count, 81), np.nan)
            ), axis = 1)
        # Arrays of 4D or higher are assumed to have a Z axis
        z_idx = shp.index(self._layers) if self._layers in shp else shp.index(1)
        if array.ndim == 4:
            return np.concatenate((
                array.swapaxes(0, z_idx).swapaxes(2, i_idx).swapaxes(3, j_idx)\
                    .reshape((1, self._layers, 1, self._count, 81)),
                np.full((1, allocation - 1, self._layers, self._count, 81), np.nan),
            ), axis = 1)
        if array.ndim == 5:
            return np.concatenate((
                array.swapaxes(0, z_idx).swapaxes(3, i_idx).swapaxes(4, j_idx)\
                    .reshape((1, self._layers, 1, self._count, 81)),
                np.full((1, allocation - 1, self._layers, self._count, 81), np.nan),
            ), axis = 1)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyl4c.apps.l4c.L4CState" href="#pyl4c.apps.l4c.L4CState">L4CState</a></li>
<li><a title="pyl4c.apps.l4c.AbstractData" href="#pyl4c.apps.l4c.AbstractData">AbstractData</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyl4c.apps.l4c.L4CStratifiedState.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self):
    return self._data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyl4c.apps.l4c.L4CStratifiedState.conformable"><code class="name flex">
<span>def <span class="ident">conformable</span></span>(<span>self, array, allocation=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Given an array, returns representation that conforms to expectations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Input data array</dd>
<dt><strong><code>allocation</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of time steps to allocate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd><code>(1 x T x Z x N x 81)</code> array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conformable(self, array, allocation = 1):
    &#39;&#39;&#39;
    Given an array, returns representation that conforms to expectations.

    Parameters
    ----------
    array : numpy.ndarray
        Input data array
    allocation : int
        Number of time steps to allocate

    Returns
    -------
    numpy.ndarray
        `(1 x T x Z x N x 81)` array
    &#39;&#39;&#39;
    shp = array.shape
    assert (self._count in shp),\
        &#39;Array is not conformable with %d measurement points&#39; % self._count
    assert array.ndim in (3, 4, 5),\
        &#39;State variables should have between 3 and 5 axes only&#39;

    # We want to return a (1 x Z x T x N x 81) array; tests are somewhat
    #   verbose in light of the possibility that self._count = 81
    assert 81 in shp,\
        &#39;State variables must have a 1-km subgrid axis with 81 elements&#39;
    i_idx = shp.index(self._count)
    j_idx = shp.index(81)
    if array.ndim == 3:
        return np.concatenate((
            array.swapaxes(1, i_idx).swapaxes(2, j_idx)\
                .reshape((1, 1, self._count, 81)),
            np.full((1, allocation - 1, 1, self._count, 81), np.nan)
        ), axis = 1)
    # Arrays of 4D or higher are assumed to have a Z axis
    z_idx = shp.index(self._layers) if self._layers in shp else shp.index(1)
    if array.ndim == 4:
        return np.concatenate((
            array.swapaxes(0, z_idx).swapaxes(2, i_idx).swapaxes(3, j_idx)\
                .reshape((1, self._layers, 1, self._count, 81)),
            np.full((1, allocation - 1, self._layers, self._count, 81), np.nan),
        ), axis = 1)
    if array.ndim == 5:
        return np.concatenate((
            array.swapaxes(0, z_idx).swapaxes(3, i_idx).swapaxes(4, j_idx)\
                .reshape((1, self._layers, 1, self._count, 81)),
            np.full((1, allocation - 1, self._layers, self._count, 81), np.nan),
        ), axis = 1)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyl4c.apps.l4c.L4CState" href="#pyl4c.apps.l4c.L4CState">L4CState</a></b></code>:
<ul class="hlist">
<li><code><a title="pyl4c.apps.l4c.L4CState.advance" href="#pyl4c.apps.l4c.L4CState.advance">advance</a></code></li>
<li><code><a title="pyl4c.apps.l4c.L4CState.serialize" href="#pyl4c.apps.l4c.L4CState.serialize">serialize</a></code></li>
<li><code><a title="pyl4c.apps.l4c.L4CState.update" href="#pyl4c.apps.l4c.L4CState.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="SMAP Mission Homepage" href="https://smap.jpl.nasa.gov/">
<img src="templates/images/logo_SMAP.jpg" alt="">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyl4c.apps" href="../index.html">pyl4c.apps</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyl4c.apps.l4c.extensions" href="extensions/index.html">pyl4c.apps.l4c.extensions</a></code></li>
<li><code><a title="pyl4c.apps.l4c.io" href="io.html">pyl4c.apps.l4c.io</a></code></li>
<li><code><a title="pyl4c.apps.l4c.main" href="main.html">pyl4c.apps.l4c.main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.report" href="#pyl4c.apps.l4c.report">report</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyl4c.apps.l4c.AbstractData" href="#pyl4c.apps.l4c.AbstractData">AbstractData</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.AbstractData.labels" href="#pyl4c.apps.l4c.AbstractData.labels">labels</a></code></li>
<li><code><a title="pyl4c.apps.l4c.AbstractData.shape" href="#pyl4c.apps.l4c.AbstractData.shape">shape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.L4CConstants" href="#pyl4c.apps.l4c.L4CConstants">L4CConstants</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.L4CConstants.add" href="#pyl4c.apps.l4c.L4CConstants.add">add</a></code></li>
<li><code><a title="pyl4c.apps.l4c.L4CConstants.conformable" href="#pyl4c.apps.l4c.L4CConstants.conformable">conformable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.L4CDrivers" href="#pyl4c.apps.l4c.L4CDrivers">L4CDrivers</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.L4CDrivers.conformable" href="#pyl4c.apps.l4c.L4CDrivers.conformable">conformable</a></code></li>
<li><code><a title="pyl4c.apps.l4c.L4CDrivers.data" href="#pyl4c.apps.l4c.L4CDrivers.data">data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.L4CState" href="#pyl4c.apps.l4c.L4CState">L4CState</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.L4CState.advance" href="#pyl4c.apps.l4c.L4CState.advance">advance</a></code></li>
<li><code><a title="pyl4c.apps.l4c.L4CState.conformable" href="#pyl4c.apps.l4c.L4CState.conformable">conformable</a></code></li>
<li><code><a title="pyl4c.apps.l4c.L4CState.data" href="#pyl4c.apps.l4c.L4CState.data">data</a></code></li>
<li><code><a title="pyl4c.apps.l4c.L4CState.serialize" href="#pyl4c.apps.l4c.L4CState.serialize">serialize</a></code></li>
<li><code><a title="pyl4c.apps.l4c.L4CState.update" href="#pyl4c.apps.l4c.L4CState.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyl4c.apps.l4c.L4CStratifiedState" href="#pyl4c.apps.l4c.L4CStratifiedState">L4CStratifiedState</a></code></h4>
<ul class="">
<li><code><a title="pyl4c.apps.l4c.L4CStratifiedState.conformable" href="#pyl4c.apps.l4c.L4CStratifiedState.conformable">conformable</a></code></li>
<li><code><a title="pyl4c.apps.l4c.L4CStratifiedState.data" href="#pyl4c.apps.l4c.L4CStratifiedState.data">data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>